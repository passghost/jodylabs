<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolling Starfield with Player Ship</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="starfield"></canvas>
    <script type="module">
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const stars = [];
        const numStars = 300; // Increased by 200%
        let starSpeedMultiplier = 1.25; // Reduced to half of previous fast value
        let warping = false;
        let warpTimer = 0;

        // Tiny background ships
        const tinyShips = [];
        let tinyShipTimer = 0;
        const tinyShipInterval = 1200; // ~20 seconds at 60fps

for (let i = 0; i < numStars; i++) {
    stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        baseSpeed: (Math.random() * 20 + 10) * 1.1, // Half the previous fast value
        speed: 0, // will be set in updateStars
        size: Math.random() * 2 + 1
    });
}

        // Player ship
        const ship = new Image();
        ship.loaded = false;
        ship.onload = () => { 
            ship.loaded = true; 
            console.log('Player ship loaded');
        };
        ship.onerror = () => {
            ship.loaded = false;
            console.error('Player ship failed to load');
        };
        ship.src = 'Vibrex.png';
        if (ship.complete && ship.naturalWidth !== 0) {
            ship.loaded = true;
            console.log('Player ship loaded (from cache)');
        }
        const shipWidth = 75; // Increased by 50%
        const shipHeight = 75; // Increased by 50%
        let shipX = canvas.width / 2 - shipWidth / 2;
        let shipY = canvas.height / 2 - shipHeight / 2;
        const shipSpeed = 0.375; // Slowed by 4x
        let shipVX = 0;
        let shipVY = 0;
        const shipFriction = 0.92; // Friction for glide effect
        let playerHealth = 100;

        // Enemy ship images
        const enemyShipFilenames = [
            'Eagle5.png',
            'FatFly.png',
            'FrontLineRunner.png',
            'ShipLevel2A.png',
            'sNUBship.png',
            'Thrower.png',
            'Vibrex.png' // Optionally include player ship as enemy
        ];
        const enemyShipImages = enemyShipFilenames.map(filename => {
            const img = new Image();
            img.loaded = false;
            img.onload = () => { 
                img.loaded = true; 
                console.log('Loaded enemy image:', filename);
            };
            img.onerror = () => {
                img.loaded = false;
                console.error('Failed to load enemy image:', filename);
            };
            img.src = filename;
            if (img.complete && img.naturalWidth !== 0) {
                img.loaded = true;
                console.log('Loaded enemy image (from cache):', filename);
            }
            return img;
        });

        // Now that enemyShipImages is defined, assign for tiny ships
        const tinyShipImages = enemyShipImages;

        const keys = {};
        const lasers = [];
        const laserSpeed = 10;
        const laserCooldown = 20; // Faster fire rate for click
        let laserCooldownCounter = 0;
        const flames = [];
import { enemies, spawnEnemies, updateEnemies, drawEnemies, updateEnemyLasers, drawEnemyLasers, checkEnemyLaserHitsPlayer, checkPlayerLaserHitsEnemies, randomizeBoidVars } from './enemyship.js';
import { enemyWeaponTypes, getRandomEnemyWeapon } from './enemyweapons.js';
import { powerups, spawnPowerup, updatePowerups, drawPowerups, checkPowerupCollection } from './powerups.js';
import { fireAllWeapons } from './weapons.js';

// --- Drone Support Ships ---
const drones = [];
const MAX_DRONES = 3;
const DRONE_OFFSET = [
    { x: -90, y: 0 },
    { x: 90, y: 0 },
    { x: 0, y: 90 }
];
const DRONE_FIRE_DELAY = 6;
let droneFireCounter = 0;
        const enemyLasers = [];
        const enemyFireRate = 100;
        // Make enemy fire rate much faster
        const enemyFireRateFast = 40; // Lowered from 100
        let enemyFireCounter = 0;

        // --- ENEMY WEAPON ASSIGNMENT ---
        // On spawn, assign a random weapon to each enemy
        function assignEnemyWeapons() {
            enemies.forEach(enemy => {
                if (!enemy.weaponType) {
                    enemy.weaponType = getRandomEnemyWeapon();
                }
            });
        }

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Draw a faint nebula background
        function drawNebula() {
            // Nebula background removed for performance
        }

        // Star hue for background
if (window.starHue === undefined) window.starHue = 60; // default hue
function setStarHueForLevel() {
    window.starHue = (window.starHue + 60 + Math.floor(Math.random() * 120)) % 360;
}

        function drawStars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawNebula();
            ctx.fillStyle = `hsl(${window.starHue}, 100%, 80%)`;
            stars.forEach(star => {
                ctx.save();
                ctx.shadowBlur = 8;
                ctx.shadowColor = `hsl(${window.starHue}, 100%, 60%)`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Tiny ships: update and draw
        function updateTinyShips() {
            for (let i = tinyShips.length - 1; i >= 0; i--) {
                tinyShips[i].y += tinyShips[i].speed;
                if (tinyShips[i].y > canvas.height + 20) {
                    tinyShips.splice(i, 1);
                }
            }
            // Spawn logic
            tinyShipTimer++;
            if (tinyShipTimer > tinyShipInterval) {
                const count = 1 + Math.floor(Math.random() * 2); // 1 or 2
                for (let i = 0; i < count; i++) {
                    const imgIndex = Math.floor(Math.random() * tinyShipImages.length);
                    tinyShips.push({
                        x: Math.random() * (canvas.width - 40) + 20,
                        y: -30,
                        width: 18 + Math.random() * 8,
                        height: 18 + Math.random() * 8,
                        speed: 8 + Math.random() * 4,
                        imgIndex
                    });
                }
                tinyShipTimer = 0;
            }
        }

        function drawTinyShips() {
            tinyShips.forEach(ship => {
                const img = tinyShipImages[ship.imgIndex];
                ctx.save();
                ctx.globalAlpha = 0.4; // Lowered from 0.55
                ctx.shadowBlur = 0; // Remove glow
                ctx.shadowColor = '#fff';
                if (img.loaded) {
                    ctx.drawImage(img, ship.x, ship.y, ship.width, ship.height);
                } else {
                    ctx.fillStyle = '#888';
                    ctx.fillRect(ship.x, ship.y, ship.width, ship.height);
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        function updateStars() {
            stars.forEach(star => {
                star.speed = star.baseSpeed * starSpeedMultiplier;
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        function drawDrones() {
            drones.forEach((drone, i) => {
                ctx.save();
                ctx.globalAlpha = 0.85;
                ctx.drawImage(ship, drone.x, drone.y, shipWidth * 0.7, shipHeight * 0.7);
                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }
function drawShip() {
    ctx.save();
    // Draw rear red glow first (behind ship)
    if (shipVX < -0.5) {
        // Moving left: diffuse red glow on rear right (classic canvas glow trick)
        ctx.save();
        ctx.shadowBlur = 54;
        ctx.shadowColor = 'rgba(255,40,40,0.75)';
        ctx.globalAlpha = 0.55;
        ctx.beginPath();
        ctx.arc(shipX + shipWidth - 22, shipY + shipHeight - 6, 22, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,40,40,0.45)'; // more opaque, triggers strong blur
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
    } else if (shipVX > 0.5) {
        // Moving right: diffuse red glow on rear left (classic canvas glow trick)
        ctx.save();
        ctx.shadowBlur = 54;
        ctx.shadowColor = 'rgba(255,40,40,0.75)';
        ctx.globalAlpha = 0.55;
        ctx.beginPath();
        ctx.arc(shipX + 22, shipY + shipHeight - 6, 22, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,40,40,0.45)'; // more opaque, triggers strong blur
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
    }
    // Now draw blue glow and ship on top
    ctx.shadowBlur = 32;
    ctx.shadowColor = 'rgba(80,160,255,0.32)';
    ctx.globalAlpha = 0.97;
    ctx.drawImage(ship, shipX, shipY, shipWidth, shipHeight);
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
        }

        function updateShip() {
            // Drones follow player with offset
            drones.forEach((drone, i) => {
                const targetX = shipX + DRONE_OFFSET[i % DRONE_OFFSET.length].x;
                const targetY = shipY + DRONE_OFFSET[i % DRONE_OFFSET.length].y;
                drone.x += (targetX - drone.x) * 0.18;
                drone.y += (targetY - drone.y) * 0.18;
            });
        // WASD controls add velocity, not direct position
        if (keys['w']) shipVY -= shipSpeed;
        if (keys['s']) shipVY += shipSpeed;
        if (keys['a']) shipVX -= shipSpeed * 2.2; // Faster horizontal
        if (keys['d']) shipVX += shipSpeed * 2.2; // Faster horizontal

            // Clamp velocity to prevent excessive speed
            shipVX = Math.max(Math.min(shipVX, 24), -24);
            shipVY = Math.max(Math.min(shipVY, 24), -24);

            // Apply velocity
            shipX += shipVX;
            shipY += shipVY;

            // Friction for glide
            shipVX *= shipFriction;
            shipVY *= shipFriction;

            // Clamp to screen
            if (shipX < 0) { shipX = 0; shipVX = 0; }
            if (shipX > canvas.width - shipWidth) { shipX = canvas.width - shipWidth; shipVX = 0; }
            if (shipY < 0) { shipY = 0; shipVY = 0; }
            if (shipY > canvas.height - shipHeight) { shipY = canvas.height - shipHeight; shipVY = 0; }
        }

        function drawLasers() {
            ctx.save();
            lasers.forEach(laser => {
                if (laser.giant) {
                    ctx.shadowBlur = 8; // Reduced from 32
                    ctx.shadowColor = 'yellow';
                    ctx.fillStyle = 'yellow';
                    ctx.fillRect(laser.x + shipWidth/2 - 8, laser.y - 30, 16, 80);
                } else if (laser.spread) {
                    ctx.shadowBlur = 4; // Reduced from 18
                    ctx.shadowColor = 'orange';
                    ctx.fillStyle = 'orange';
                    ctx.fillRect(laser.x - 2, laser.y, 4, 18);
                } else if (powerupState.double_laser && typeof laser.offset !== 'undefined') {
                    ctx.shadowBlur = 4; // Reduced from 18
                    ctx.shadowColor = 'aqua';
                    ctx.fillStyle = 'aqua';
                    ctx.fillRect(laser.x + laser.offset, laser.y, 2, 14);
                } else {
                    ctx.shadowBlur = 4; // Reduced from 18
                    ctx.shadowColor = '#00fff7';
                    ctx.fillStyle = 'aqua';
                    ctx.fillRect(laser.x + 10, laser.y, 2, 14);
                    ctx.fillRect(laser.x + shipWidth - 12, laser.y, 2, 14);
                }
            });
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function updateLasers() {
            lasers.forEach((laser, index) => {
                if (laser.spread) {
                    laser.x += laser.dx;
                    laser.y += laser.dy;
                } else {
                    laser.y -= laserSpeed;
                }
                if (laser.y < 0 || laser.y > canvas.height || laser.x < 0 || laser.x > canvas.width) {
                    lasers.splice(index, 1);
                }
            });
        }

        let mouseDown = false;
        // Update flame positions and remove small ones
        function updateFlames() {
            for (let i = flames.length - 1; i >= 0; i--) {
                flames[i].y += flames[i].speed;
                flames[i].size -= 0.2;
                if (flames[i].size <= 0) {
                    flames.splice(i, 1);
                }
            }
        }

        // Create a flame behind the ship when firing or moving up
        function createFlame() {
            // Reduce number of flames created for performance
            if ((keys['w'] || keys[' '] || mouseDown) && flames.length < 10) {
                flames.push({
                    x: shipX + shipWidth / 2 + (Math.random()-0.5)*10,
                    y: shipY + shipHeight,
                    size: Math.random() * 5 + 5,
                    speed: Math.random() * 2 + 1
                });
            }
        }
        function fireLasers() {
            // Drones only fire if player is shooting
            let playerIsShooting = (keys[' '] || mouseDown);
            droneFireCounter--;
            if (drones.length > 0 && droneFireCounter <= 0 && playerIsShooting) {
                drones.forEach(drone => {
                    fireAllWeapons({
                        shipX: drone.x,
                        shipY: drone.y,
                        shipWidth,
                        powerupState,
                        lasers,
                        laserSpeed
                    });
                });
                droneFireCounter = DRONE_FIRE_DELAY;
            }
            // Player fires
            let rapidTier = 0;
            for (let i = 5; i >= 1; i--) if (powerupState['rapid_fire' + (i > 1 ? '_' + i : '')]) { rapidTier = i; break; }
            let cooldown = 8;
            if (rapidTier > 0) cooldown = Math.max(2, laserCooldown / (1.5 + rapidTier * 1.2));
            if (playerIsShooting && laserCooldownCounter <= 0) {
                fireAllWeapons({
                    shipX,
                    shipY,
                    shipWidth,
                    powerupState,
                    lasers,
                    laserSpeed
                });
                laserCooldownCounter = cooldown;
            }
            if (laserCooldownCounter > 0) {
                laserCooldownCounter--;
            }
        }

        window.addEventListener('mousedown', () => { mouseDown = true; });
        window.addEventListener('mouseup', () => { mouseDown = false; });

        function drawFlames() {
            flames.forEach(flame => {
                const gradient = ctx.createRadialGradient(flame.x, flame.y, 0, flame.x, flame.y, flame.size);
                gradient.addColorStop(0, 'purple');
                gradient.addColorStop(1, 'blue');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 6; // Reduced from 20
                ctx.shadowColor = 'orange';
                ctx.beginPath();
                ctx.arc(flame.x, flame.y, flame.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
            ctx.save();
            lasers.forEach(laser => {
                // Giant laser: huge, glowing, color by tier
                if (laser.giant) {
                    ctx.shadowBlur = 8; // Reduced from 32
                    ctx.shadowColor = laser.color || 'yellow';
                    ctx.fillStyle = laser.color || 'yellow';
                    ctx.globalAlpha = 0.85;
                    ctx.fillRect(laser.x + shipWidth/2 - (laser.width||16)/2, laser.y - 30, laser.width||16, laser.height||80);
                    ctx.globalAlpha = 1;
                } else if (laser.spread) {
                    ctx.shadowBlur = 4; // Reduced from 18
                    ctx.shadowColor = laser.color || 'orange';
                    ctx.fillStyle = laser.color || 'orange';
                    ctx.globalAlpha = 0.85;
                    ctx.fillRect(laser.x - (laser.width||4)/2, laser.y, laser.width||4, laser.height||18);
                    ctx.globalAlpha = 1;
                } else if (typeof laser.offset !== 'undefined') {
                    ctx.shadowBlur = 4; // Reduced from 18
                    ctx.shadowColor = laser.color || 'aqua';
                    ctx.fillStyle = laser.color || 'aqua';
                    ctx.globalAlpha = 0.85;
                    ctx.fillRect(laser.x + laser.offset, laser.y, laser.width||2, laser.height||14);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.shadowBlur = 4; // Reduced from 18
                    ctx.shadowColor = laser.color || '#00fff7';
                    ctx.fillStyle = laser.color || 'aqua';
                    ctx.globalAlpha = 0.85;
                    ctx.fillRect(laser.x + 10, laser.y, laser.width||2, laser.height||14);
                    ctx.fillRect(laser.x + shipWidth - 12, laser.y, laser.width||2, laser.height||14);
                    ctx.globalAlpha = 1;
                }
            });
            ctx.shadowBlur = 0;
            ctx.restore();
// updateEnemies now imported

// drawEnemyLasers and updateEnemyLasers now imported
//
// To make boids movement more fish-like, tune the variables in enemyship.js:
// - Lower alignment and separation weights, increase cohesion
// - Add more randomness to direction changes
// - Increase max speed and turn rate
//
// Example (in enemyship.js):
//   const BOID_ALIGNMENT = 0.2;
//   const BOID_COHESION = 0.7;
//   const BOID_SEPARATION = 0.15;
//   const BOID_RANDOMNESS = 0.25;
//   const BOID_MAX_SPEED = 10;
//   const BOID_MAX_FORCE = 0.5;

// fireEnemyLasers now imported

// spawnEnemies now imported

        function drawHealthBar(x, y, width, height, health, maxHealth) {
            // Border
            ctx.save();
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#00fff7';
            ctx.strokeRect(x - 2, y - 2, width + 4, height + 4);
            // Background
            const grad = ctx.createLinearGradient(x, y, x + width, y);
            grad.addColorStop(0, '#2a0033');
            grad.addColorStop(1, '#001a33');
            ctx.fillStyle = grad;
            ctx.fillRect(x, y, width, height);
            // Health
            const healthGrad = ctx.createLinearGradient(x, y, x + width, y);
            healthGrad.addColorStop(0, '#00ff99');
            healthGrad.addColorStop(1, '#00fff7');
            ctx.fillStyle = healthGrad;
            ctx.fillRect(x, y, (health / maxHealth) * width, height);
            // Text
            ctx.font = 'bold 18px monospace';
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#00fff7';
            ctx.shadowBlur = 8;
            ctx.fillText('SHIELDS', x + 10, y + height - 5);
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Draw weapon/tier UI indicators
        function drawWeaponTiers() {
            const weaponTypes = [
                { key: 'spread_shot', label: 'Spread', color: '#ff9900' },
                { key: 'double_laser', label: 'Double', color: '#00e6e6' },
                { key: 'piercing', label: 'Pierce', color: '#00ff99' },
                { key: 'rapid_fire', label: 'Rapid', color: '#ff00cc' },
                { key: 'giant_laser', label: 'Giant', color: '#ffff00' }
            ];
            const iconSize = 18;
            const gap = 6;
            let x = 12, y = 40;
            ctx.save();
            ctx.font = 'bold 13px monospace';
            weaponTypes.forEach((w, idx) => {
                // Find tier
                let tier = 0;
                for (let i = 5; i >= 1; i--) {
                    if (powerupState[w.key + (i > 1 ? '_' + i : '')]) {
                        tier = i;
                        break;
                    }
                }
                // Draw icon
                ctx.fillStyle = '#222';
                ctx.globalAlpha = 0.7;
                ctx.fillRect(x, y + idx * (iconSize + gap), iconSize * 2.2, iconSize);
                ctx.globalAlpha = 1;
                ctx.strokeStyle = w.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y + idx * (iconSize + gap), iconSize * 2.2, iconSize);
                ctx.fillStyle = w.color;
                ctx.fillText(w.label, x + 4, y + idx * (iconSize + gap) + 14);
                // Draw tier pips
                for (let t = 1; t <= 5; t++) {
                    ctx.beginPath();
                    ctx.arc(x + 70 + t * 13, y + idx * (iconSize + gap) + iconSize / 2, 4, 0, Math.PI * 2);
                    ctx.fillStyle = t <= tier ? w.color : '#444';
                    ctx.globalAlpha = t <= tier ? 1 : 0.4;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
            ctx.restore();
        }

        // Player laser vs. enemy and enemy laser vs. player collision now handled by enemyship.js
        // Enhanced: spawn powerups on enemy death
        function checkCollisions() {
            // Get destroyed enemy positions
            const destroyed = checkPlayerLaserHitsEnemies(lasers, enemies, shipWidth);
            // For each destroyed, spawn a powerup at the enemy's position
            if (destroyed.length > 0) {
                destroyed.forEach(pos => {
                    spawnPowerup(pos.x - 14, pos.y - 14); // Center orb on enemy
                });
            }
            // Enemy laser vs. player handled by checkEnemyLaserHitsPlayer in main loop
        }

        function animate() {
            assignEnemyWeapons();
            drawStars();
            updateStars();
            updateTinyShips();
            drawTinyShips();
            updateShip();
            drawDrones();
            fireLasers();
            updateLasers();
            drawLasers();
            createFlame();
            updateFlames();
            drawFlames();
            drawShip();
            updateEnemies(canvas);
            drawEnemies(ctx, enemyShipImages);
            // --- Custom enemy firing logic using weapon types ---
            enemyFireCounter--;
            if (enemyFireCounter <= 0) {
                enemies.forEach(enemy => {
                    if (!enemy.weaponType) enemy.weaponType = getRandomEnemyWeapon();
                    // For homing, pass player position
                    if (enemy.weaponType.name === 'homing_missile') {
                        enemy.weaponType.fire(enemy, enemyLasers, shipX + shipWidth/2, shipY + shipHeight/2);
                    } else {
                        enemy.weaponType.fire(enemy, enemyLasers);
                    }
                });
                enemyFireCounter = enemyFireRateFast;
            }
            updateEnemyLasers(enemyLasers, canvas, laserSpeed);
            drawEnemyLasers(ctx, enemyLasers);
            // Powerups
            updatePowerups(canvas);
            drawPowerups(ctx);
            checkCollisions();
            // Powerup collection
            checkPowerupCollection(shipX, shipY, shipWidth, shipHeight, applyPowerup);
            playerHealth = checkEnemyLaserHitsPlayer(enemyLasers, shipX, shipY, shipWidth, shipHeight, playerHealth);
            drawHealthBar(10, 10, 200, 20, playerHealth, 100);
            drawWeaponTiers();

            // Warp effect and infinite waves
            if (!warping && enemies.length === 0) {
                warping = true;
                warpTimer = 0;
                starSpeedMultiplier = 8;
                setStarHueForLevel(); // Change star hue for new level
            }
            if (warping) {
                warpTimer++;
                if (warpTimer < 10) {
                    ctx.save();
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }
                if (warpTimer > 40) {
                    warping = false;
                    starSpeedMultiplier = 1;
                    randomizeBoidVars();
                    spawnEnemies(canvas, enemyShipImages);
                }
            }

            requestAnimationFrame(animate);
        }
        // Apply powerup effects to player weapons
        // Track all possible powerup types and tiers
        let powerupState = {
            double_laser: false,
            double_laser_2: false,
            double_laser_3: false,
            double_laser_4: false,
            double_laser_5: false,
            spread_shot: false,
            spread_shot_2: false,
            spread_shot_3: false,
            spread_shot_4: false,
            spread_shot_5: false,
            piercing: false,
            piercing_2: false,
            piercing_3: false,
            piercing_4: false,
            piercing_5: false,
            rapid_fire: false,
            rapid_fire_2: false,
            rapid_fire_3: false,
            rapid_fire_4: false,
            rapid_fire_5: false,
            giant_laser: false,
            giant_laser_2: false,
            giant_laser_3: false,
            giant_laser_4: false,
            giant_laser_5: false
        };

        // Helper: clear all powerups of a given family (e.g. spread_shot, double_laser, etc)
        function clearPowerupFamily(family) {
            for (const key in powerupState) {
                if (key.startsWith(family)) powerupState[key] = false;
            }
        }

        function applyPowerup(type) {
            // New: If powerup is 'drone', add a drone up to MAX_DRONES
            if (type === 'drone') {
                if (drones.length < MAX_DRONES) {
                    // Spawn drone at player position
                    drones.push({ x: shipX, y: shipY });
                }
                return;
            }
// --- Inject drone powerup into powerup drop logic ---
// This is a quick patch to make drone powerups appear as a rare drop
// (For a more robust system, add to powerups.js)
const originalSpawnPowerup = spawnPowerup;
function spawnPowerupWithDrone(x, y) {
    // 1 in 6 chance to spawn a drone powerup, else normal
    if (Math.random() < 0.17 && drones.length < MAX_DRONES) {
        // Draw a unique orb for drone
        powerups.push({ x, y, type: 'drone', collected: false });
    } else {
        originalSpawnPowerup(x, y);
    }
}
// Override spawnPowerup globally
window.spawnPowerup = spawnPowerupWithDrone;


            // Helper: check if all main powerup families are at tier 5
            function allFamiliesAtMax() {
                const families = ['spread_shot', 'double_laser', 'piercing', 'rapid_fire', 'giant_laser'];
                return families.every(fam => powerupState[fam + '_5']);
            }

            // Helper: get current tier for a family
            function getTier(family) {
                let maxTier = 0;
                for (let i = 5; i >= 1; i--) {
                    if (powerupState[family + (i > 1 ? '_' + i : '')]) {
                        maxTier = i;
                        break;
                    }
                }
                return maxTier;
            }

            // If all families at max, grant drone and reset all tiers for each family
            if (allFamiliesAtMax()) {
                if (drones.length < MAX_DRONES) {
                    drones.push({ x: shipX, y: shipY });
                }
                // For each family, remove all tiers (reset to 0)
                const families = ['spread_shot', 'double_laser', 'piercing', 'rapid_fire', 'giant_laser'];
                families.forEach(fam => {
                    for (let i = 1; i <= 5; i++) {
                        powerupState[fam + (i > 1 ? '_' + i : '')] = false;
                    }
                });
                return;
            }

            // --- Powerup stacking logic: always keep all lower tiers active for every family ---
            function setFamilyTiers(family, n) {
                for (let i = 1; i <= 5; i++) {
                    powerupState[family + (i > 1 ? '_' + i : '')] = i <= n;
                }
            }

            if (type.startsWith('spread_shot')) {
                let tier = 1;
                if (type !== 'spread_shot') {
                    const match = type.match(/spread_shot_(\d)/);
                    if (match) tier = parseInt(match[1]);
                }
                setFamilyTiers('spread_shot', Math.max(getTier('spread_shot'), tier));
            } else if (type.startsWith('double_laser')) {
                let tier = 1;
                if (type !== 'double_laser') {
                    const match = type.match(/double_laser_(\d)/);
                    if (match) tier = parseInt(match[1]);
                }
                setFamilyTiers('double_laser', Math.max(getTier('double_laser'), tier));
            } else if (type.startsWith('piercing')) {
                let tier = 1;
                if (type !== 'piercing') {
                    const match = type.match(/piercing_(\d)/);
                    if (match) tier = parseInt(match[1]);
                }
                setFamilyTiers('piercing', Math.max(getTier('piercing'), tier));
            } else if (type.startsWith('rapid_fire')) {
                let tier = 1;
                if (type !== 'rapid_fire') {
                    const match = type.match(/rapid_fire_(\d)/);
                    if (match) tier = parseInt(match[1]);
                }
                setFamilyTiers('rapid_fire', Math.max(getTier('rapid_fire'), tier));
            } else if (type.startsWith('giant_laser')) {
                let tier = 1;
                if (type !== 'giant_laser') {
                    const match = type.match(/giant_laser_(\d)/);
                    if (match) tier = parseInt(match[1]);
                }
                setFamilyTiers('giant_laser', Math.max(getTier('giant_laser'), tier));
            } else {
                powerupState[type] = true;
            }
        }

        // Wait for all enemy images and player ship to load before starting
        function allEnemyImagesLoaded() {
            return enemyShipImages.every(img => img.loaded);
        }

        function playerShipLoaded() {
            return ship.loaded;
        }

        let gameStarted = false;
        let fallbackTimeout = null;
        function startGameWhenReady() {
            if (gameStarted) return;
            if (playerShipLoaded() && allEnemyImagesLoaded()) {
                gameStarted = true;
                randomizeBoidVars();
                spawnEnemies(canvas, enemyShipImages);
                animate();
                console.log('Game started: all images loaded');
            } else {
                setTimeout(startGameWhenReady, 50);
            }
        }

        // Fallback: start game after 5 seconds even if some images failed
        function fallbackStart() {
            if (!gameStarted) {
                gameStarted = true;
                randomizeBoidVars();
                spawnEnemies(canvas, enemyShipImages);
                animate();
                ctx.save();
                ctx.font = '30px sans-serif';
                ctx.fillStyle = 'red';
                ctx.fillText('Some images failed to load!', 50, 100);
                ctx.restore();
                console.warn('Game started after fallback timeout. Some images may be missing.');
            }
        }

        // Start game when all images are loaded
        startGameWhenReady();
        fallbackTimeout = setTimeout(fallbackStart, 5000);
    </script>
</body>
</html>
