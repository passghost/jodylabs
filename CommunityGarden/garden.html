<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Garden — 4-Frame Community Plants</title>
    <style>
        :root {
            --bg: #0c0f14;
            --panel: #121722;
            --muted: #9aa4b2;
            --accent: #6fe3b4;
            --line: #233045;
            --pin: #e23d3d;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: #e9eef5;
            font: 14px/1.2 system-ui, Segoe UI, Roboto, Inter, sans-serif;
        }

        header {
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--line);
            position: sticky;
            top: 0;
            background: linear-gradient(180deg, rgba(12, 15, 20, .95), rgba(12, 15, 20, .85));
            backdrop-filter: saturate(1.2) blur(6px);
            z-index: 10;
        }

        header h1 {
            font-size: 16px;
            margin: 0;
            letter-spacing: .4px;
        }

        header .caps {
            margin-left: auto;
            color: var(--muted);
        }

        /* small action timer pills */
        .action-timers {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: auto;
        }

        .action-pill {
            padding: 6px 8px;
            border-radius: 10px;
            background: #0f1620;
            border: 1px solid var(--line);
            color: var(--muted);
            font-size: 13px;
        }

        .action-pill.gray {
            opacity: 0.45;
        }

        main {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 14px;
            padding: 14px;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 12px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .25);
        }

        .card h2 {
            margin: 0 0 8px;
            font-size: 14px;
            color: #d5e3f7;
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        button,
        .btn {
            cursor: pointer;
            border: 1px solid var(--line);
            background: #192233;
            color: #dce6f5;
            padding: 6px 8px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
        }

        button[disabled] {
            opacity: .45;
            cursor: not-allowed;
        }

        .note {
            color: var(--muted);
            font-size: 12px;
        }

        canvas.frame {
            border: 1px dashed #3a4c6b;
            background: #0a0f17;
            border-radius: 8px;
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
        }

        .frames {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .picker {
            max-height: 300px;
            overflow: auto;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 4px;
        }

        /* highlight for selected small frame */
        .frame.selected {
            box-shadow: 0 6px 18px rgba(111, 227, 180, 0.12), 0 0 0 3px rgba(111, 227, 180, 0.08);
            outline: 2px solid rgba(111, 227, 180, 0.14);
            border-color: rgba(111, 227, 180, 0.12);
        }

        /* large seed editor canvas (in left panel) */
        canvas.large-seed-canvas {
            width: 320px;
            height: 320px;
            image-rendering: pixelated;
            border-radius: 8px;
            border: 1px solid var(--line);
            background: #071018;
            /* custom pencil cursor (inline SVG) */
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23ffffff" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a1.003 1.003 0 0 0 0-1.41l-2.34-2.34a1.003 1.003 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>') 12 12, auto;
        }

        /* overlay hint placed above the large canvas */
        .canvas-hint {
            position: relative;
            width: 320px;
            margin-top: 8px;
            text-align: center;
            font-size: 12px;
            color: var(--muted);
        }

        .canvas-hint .hint-badge {
            display: inline-block;
            background: rgba(11,21,34,0.9);
            border: 1px solid var(--line);
            padding: 6px 8px;
            border-radius: 8px;
            font-size: 12px;
            color: #cfeee0;
        }

        .seed {
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #0e1420;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }

        .seed img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            border-radius: 6px;
        }

        .field-wrap {
            position: relative;
        }

        /* Field is the viewport. The large plantable area lives inside .world which is pannable/zoomable. */
        #field {
            width: 100%;
            height: 70vh;
            min-height: 420px;
            border-radius: 16px;
            border: 1px solid var(--line);
            position: relative;
            overflow: hidden;
            touch-action: none;
            /* we'll handle touch/pan/zoom manually */
            background: linear-gradient(180deg, #87CEEB 0%, #98D8E8 30%, #B8E6B8 70%, #90EE90 100%);
        }

        /* The world is a very large surface that can be translated and scaled. Use repeating backgrounds to create large colored grassy patches so scrolling is visually obvious. */
        .world {
            position: absolute;
            left: 0;
            top: 0;
            width: 5000px;
            height: 5000px;
            transform-origin: 0 0;
            /* Large patchy background: alternating green tiles and subtle texture */
            background-color: #7ecf7a;
            background-image:
                linear-gradient(180deg, rgba(0, 0, 0, 0.03) 0 1px, transparent 1px),
                repeating-linear-gradient(90deg, rgba(0, 0, 0, 0.02) 0 32px, transparent 32px 64px),
                linear-gradient(135deg, rgba(255, 255, 255, 0.03), rgba(0, 0, 0, 0.03));
            /* create visible larger color patches using background-size / position trick */
            background-blend-mode: multiply, overlay, normal;
            box-shadow: inset 0 0 60px rgba(0, 0, 0, 0.06);
        }

        .plot {
            position: absolute;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
        }

        .plant {
            position: absolute;
            transform: translate(-50%, -100%);
            transition: all .2s ease;
            pointer-events: auto;
            will-change: transform;
        }

        .plant:hover {
            transform: translate(-50%, -100%) scale(1.08);
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
        }

        .plant.selected {
            transform: translate(-50%, -100%) scale(1.1);
            box-shadow: 0 8px 24px rgba(111, 227, 180, 0.12), 0 0 0 3px rgba(111, 227, 180, 0.08);
            outline: 2px solid rgba(111, 227, 180, 0.06);
        }

        /* When a plant is in the seed phase (stage 0) we still want the DOM node
           to exist for selection and highlighting, but hide the visible seed image.
           The element keeps pointer-events so users can select and hover it. */
        .plant.seed-hidden img.stage {
            opacity: 0;
            /* invisible */
            pointer-events: none;
            /* clicks should be handled by the .plant wrapper */
        }

        .plant.seed-hidden {
            /* keep selection visuals enabled */
            background: transparent;
        }

        /* Small visible marker for seeded spots so users can find where they clicked. */
        .plant .seed-dot {
            position: absolute;
            left: 50%;
            bottom: -7px;
            transform: translateX(-50%) rotate(-20deg) scale(1);
            width: 5px;
            height: 8px;
            /* seed-like oval with slightly pointed ends */
            border-radius: 50% 40% 50% 40% / 60% 60% 40% 40%;
            background: linear-gradient(180deg, #45d67a 0%, #1fa65a 100%);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.14);
            pointer-events: none;
            /* let the wrapper handle clicks */
            transition: transform .18s ease, opacity .18s ease;
            opacity: 1;
            z-index: 2;
        }

        .plant:hover .seed-dot,
        .plant.selected .seed-dot {
            transform: translateX(-50%) scale(1.18);
        }

        /* Plant stats bubble */
        #plantStats {
            position: absolute;
            z-index: 50;
            width: 220px;
            max-width: 70%;
            pointer-events: auto;
            opacity: 0;
            transform-origin: left center;
            transition: transform 220ms cubic-bezier(.2, .9, .2, 1), opacity 180ms ease;
            will-change: transform, opacity, left, top;
            transform: translateX(-8px) scale(.98);
        }

        #plantStats.visible {
            opacity: 1;
            transform: translateX(0px) scale(1);
        }

        #plantStats .card {
            background: linear-gradient(180deg, #0b1522, #071018);
            border: 1px solid var(--line);
        }

        #plantStats .close {
            float: right;
            cursor: pointer;
            background: transparent;
            border: none;
            color: var(--muted);
            font-weight: 700;
        }

        .selected-tag {
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: #0c0f14;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            animation: fadeInTag 0.2s ease;
        }

        @keyframes fadeInTag {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-5px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .stage {
            width: 18px;
            height: 18px;
            image-rendering: pixelated;
            border: none;
            background: transparent;
            transition: all .2s ease;
            transform-origin: center bottom;
            display: block;
        }

        .water {
            position: absolute;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            background: #0b1522;
            border: 1px solid var(--line);
            padding: 3px 6px;
            border-radius: 8px;
        }

        .pin {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--pin);
            border-radius: 50%;
            box-shadow: 0 0 0 2px #530, 0 3px 0 #200;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
        }

        .legend {
            display: flex;
            gap: 10px;
            color: var(--muted);
            font-size: 12px;
            align-items: center;
        }

        .legend .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
        }

        .grid {
            background-image:
                /* Subtle soil rows */
                linear-gradient(to right, rgba(139, 69, 19, .1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(139, 69, 19, .1) 1px, transparent 1px);
            background-size: 32px 32px, 32px 32px;
        }

        .toast {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: #0e1522;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 8px 12px;
            color: #dfe9f7;
            box-shadow: 0 8px 20px rgba(0, 0, 0, .35);
        }

        .muted {
            color: var(--muted);
        }
    </style>
</head>

<body>
    <header>
        <h1>🌱 Community Garden (4-Frame Plants)</h1>
        <div class="legend"><span class="dot"></span> <span>Click the field to plant</span></div>
        <div class="action-timers">
            <div id="makeTimer" class="action-pill">Make: <span class="count">--</span></div>
            <div id="pickTimer" class="action-pill">Pick: <span class="count">--</span></div>
            <div id="waterTimer" class="action-pill">Water: <span class="count">--</span></div>
        </div>
    </header>

    <main>
        <!-- Left: Creator -->
        <section class="card">
            <h2>1) Draw 4 frames (seed → sprout → bud → bloom)</h2>
            <div class="row">
                <div class="frames" id="frames"></div>
                <div class="row">
                    <button id="toolPencil">✏️ Pencil</button>
                    <button id="toolEraser">🩹 Eraser</button>
                    <button id="toolFill">🪣 Fill</button>
                    <!-- Shape tools: circle, square, triangle, star -->
                    <button id="toolCircle">⚪ Circle</button>
                    <button id="toolSquare">🔲 Square</button>
                    <button id="toolTriangle">🔺 Triangle</button>
                    <button id="toolStar">⭐ Star</button>
                    <button id="toolStepBack">↶ Undo</button>
                    <label style="display:inline-flex;align-items:center;gap:6px;margin-left:8px">Size
                        <input id="pencilSize" type="range" min="1" max="256" value="4" style="vertical-align:middle;margin-left:6px">
                    </label>
                    <input type="color" id="color" value="#6fe3b4" />
                    <div id="colorPreview" style="width:22px;height:22px;border-radius:6px;border:1px solid var(--line);margin-left:6px"></div>
                </div>
                <div class="row">
                    <button id="clear">Clear frame</button>
                    <button id="prev">◀ Prev</button>
                    <div class="note" id="frameLabel">Frame 1/4</div>
                    <button id="next">Next ▶</button>
                </div>
            </div>
                <div class="row" style="margin-top:8px;">
                <button id="submitSeed">Submit seed (Supabase)</button>
                <span class="note">Upload to Supabase storage. Make cooldown: 2 hours — you can submit a seed every 2 hours.</span>
            </div>
            <div class="note" style="margin-top:6px;">Tip: right-click + drag draws straight lines (desktop). Touch
                supported.</div>
            <div style="margin-top:10px;display:flex;flex-direction:column;gap:8px;align-items:center">
                <div class="canvas-hint"><span class="hint-badge">use thicker lines for less pixelation</span></div>
                <canvas id="largeCanvas" class="large-seed-canvas" width="320" height="320" title="Draw larger seed preview"></canvas>
                <div class="note">Larger seed preview and editor (edits sync to selected small frame)</div>
            </div>
        </section>

        <!-- Center: Field -->
        <section class="card field-wrap">
            <h2>2) Field (click to plant your picked seed)</h2>
            <div id="field" class="grid"></div>
            <div class="row" style="margin-top:8px; justify-content:space-between;">
                <div class="note">🌞 Community Garden - Growth = 24h total → 6h per stage. Water cooldown 2m.</div>
                <div class="row">
                    <button id="refresh">Refresh</button>
                    <span class="note">Live sync enabled! ✨</span>
                </div>
            </div>
        </section>

        <!-- Right: Seed Picker & Actions -->
        <section class="card">
            <h2>3) Seed picker</h2>
            <div id="randomThree" class="row" style="gap:8px;margin-bottom:8px;"></div>
            <div class="row" style="gap:8px;margin-bottom:8px;">
                <button id="refreshRandom">Refresh picks</button>
                <div class="note">Pick from 3 random seeds above</div>
            </div>
            <h2>Seed Gallery</h2>
            <div class="picker" id="picker"></div>
            <div class="row" style="margin-top:8px;">
                <button id="pickRandom">Pick random</button>
                <button id="unpick">Unpick</button>
            </div>
            <div class="row" style="margin-top:8px;gap:8px;align-items:center;">
                <button id="debugSeedsBtn">Debug Seeds</button>
                <div id="debugInfo" class="note muted">Debug info hidden</div>
            </div>
            <div class="note" id="pickedInfo">No seed picked.</div>
            <hr style="border:none;border-top:1px solid var(--line);margin:10px 0;">
            <h2>Actions</h2>
            <div class="row">
                <button id="waterSelected" disabled>💧 Water selected plant</button>
                <span class="note">Select a plant on the field.</span>
            </div>
        </section>
    </main>

    <div id="toast" class="toast" style="display:none;"></div>
    <div id="plantStats" style="display:none;" aria-hidden="true"></div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        /* ----------------- Config ----------------- */
        const SUPABASE_URL = "https://omcwjmvdjswkfjkahchm.supabase.co";
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9tY3dqbXZkanN3a2Zqa2FoY2htIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE0NDU1MDcsImV4cCI6MjA2NzAyMTUwN30.v-zypq4wN5EW0z8dxbUHWeNzDhuTylyL4chpBfTISxE";
        const ACTION_COOLDOWNS = { make: 2 * 60 * 60 * 1000, pick: 1 * 60 * 60 * 1000, plant: 2 * 60 * 1000 }; // cooldowns in ms after first use
        const WATER_COOLDOWN_MS = 2 * 60 * 1000; // 2 minutes
        const STAGE_MS = 6 * 60 * 60 * 1000; // 6 hours per stage
        const TOTAL_MS = 4 * STAGE_MS; // 24 hours total
        // Normalize timestamp-ish values (numbers, numeric strings, ISO strings) to ms since epoch
        function toTimestamp(v) {
            if (!v && v !== 0) return 0;
            if (typeof v === 'number') return v;
            if (typeof v === 'string') {
                if (!Number.isNaN(Number(v))) return Number(v);
                const parsed = Date.parse(v);
                return Number.isNaN(parsed) ? 0 : parsed;
            }
            if (v instanceof Date) return v.getTime();
            return 0;
        }
        const AUTO_REFRESH_MS = 2_000; // Refresh every 2 seconds
    // Reconcile backoff and concurrency guards to avoid spamming network when Supabase/storage is flaky
    let reconcilingSeeds = false;
    let reconFailureCount = 0;
    let lastReconFailureAt = 0;
    let lastReconcileAt = 0;
    const RECON_FAILURE_THRESHOLD = 3; // after this many consecutive failures, pause reconcile
    const RECON_COOLDOWN_MS = 30_000; // wait this long after hitting threshold
    const RECON_MIN_INTERVAL_MS = 5_000; // never run reconcile more often than this
    // Throttle for random picker rendering to avoid frequent re-renders
    let lastRandomRenderAt = 0;
    const RANDOM_MIN_INTERVAL_MS = 3_000;

        /* ------------- Real-time database ------------- */
        const db = {
            seeds: [],
            plants: [],
            caps: {},

            async load() {
                try {
                    // Load seeds
                    const { data: seeds } = await supabase
                        .from('seeds')
                        .select('*')
                        .order('created_at', { ascending: false });
                    this.seeds = seeds || [];

                    // Load plants
                    const { data: plants } = await supabase
                        .from('plants')
                        .select('*');
                    this.plants = plants || [];

                    // Load caps from localStorage (keep local for demo)
                    this.caps = JSON.parse(localStorage.getItem("caps") || "{}");
                } catch (error) {
                    console.error('Error loading data:', error);
                    // Fallback to localStorage
                    this.seeds = JSON.parse(localStorage.getItem("seeds") || "[]");
                    this.plants = JSON.parse(localStorage.getItem("plants") || "[]");
                    this.caps = JSON.parse(localStorage.getItem("caps") || "{}");
                }

                // Startup consistency check: ensure every plant has a planted_at timestamp.
                // Backfill from legacy keys (plantedAt or created_at) or set to now, and persist to localStorage
                try {
                    let fixed = 0;
                    this.plants = (this.plants || []).map(p => {
                        if (!p.planted_at) {
                            if (p.plantedAt) {
                                p.planted_at = p.plantedAt;
                            } else if (p.created_at) {
                                p.planted_at = p.created_at;
                            } else {
                                p.planted_at = new Date().toISOString();
                            }
                            fixed++;
                            console.warn(`Plant ${p.id || '<unknown>'} missing planted_at; backfilled with ${p.planted_at}`);
                        }
                        return p;
                    });
                    if (fixed > 0) {
                        // Persist fixes to localStorage fallback
                        this.save();
                        console.log(`db.load: backfilled planted_at for ${fixed} plants and saved to localStorage.`);
                    }
                } catch (e) {
                    console.warn('db.load consistency check failed', e);
                }
            },

            async addSeed(seed) {
                try {
                    const { data, error } = await supabase
                        .from('seeds')
                        .insert([seed])
                        .select();
                    if (error) throw error;
                    // avoid duplicates
                    if (!this.seeds.some(s => s && s.id === (data && data[0] && data[0].id))) {
                        this.seeds.unshift(data[0]);
                    }
                } catch (error) {
                    console.error('Error adding seed:', error);
                    try {
                        const removedSet = getRemovedSeedSet();
                        if (!removedSet.has(seed.id)) {
                            if (!this.seeds.some(s => s && s.id === seed.id)) this.seeds.unshift(seed);
                        } else {
                            console.log('Not adding seed to local fallback because it is client-removed:', seed.id);
                        }
                        // Persist via save() which already respects removedSet
                        this.save();
                    } catch (e) {
                        // best-effort fallback: use save() which respects removed set
                        try { this.seeds.unshift(seed); this.save(); } catch (ee) { /* ignore */ }
                    }
                }
            },

            async addPlant(plant) {
                try {
                    const { data, error } = await supabase
                        .from('plants')
                        .insert([plant])
                        .select();
                    if (error) throw error;
                    this.plants.push(data[0]);
                } catch (error) {
                    console.error('Error adding plant:', error);
                    this.plants.push(plant);
                    // Persist local fallback immediately
                    this.save();
                }
            },

            async updatePlant(plantId, updates) {
                try {
                    const { data, error } = await supabase
                        .from('plants')
                        .update(updates)
                        .eq('id', plantId)
                        .select();
                    if (error) throw error;
                    const plantIndex = this.plants.findIndex(p => p.id === plantId);
                    if (plantIndex >= 0) {
                        this.plants[plantIndex] = { ...this.plants[plantIndex], ...updates };
                        // Keep local fallback in sync
                        this.save();
                    }
                } catch (error) {
                    console.error('Error updating plant:', error);
                }
            },

            async updateSeedStatus(seedId, status) {
                try {
                    const { error } = await supabase
                        .from('seeds')
                        .update({ status })
                        .eq('id', seedId);
                    if (error) throw error;
                    const seed = this.seeds.find(s => s.id === seedId);
                    if (seed) seed.status = status;
                } catch (error) {
                    console.error('Error updating seed:', error);
                }
            },

            todayKey() {
                const d = new Date();
                return d.toISOString().slice(0, 10);
            },

            can(action) {
                const lastAction = this.caps[`last_${action}`] || 0;
                const cooldown = ACTION_COOLDOWNS[action] || 0;
                const canDo = Date.now() - lastAction >= cooldown;
                console.log(`can(${action}): lastAction=${lastAction}, cooldown=${cooldown}, canDo=${canDo}`);
                return canDo;
            },

            bump(action) {
                this.caps[`last_${action}`] = Date.now();
                localStorage.setItem("caps", JSON.stringify(this.caps));
            },

            // Persist to localStorage fallback for demo usage
            save() {
                try {
                    // Persist seeds but exclude any client-blacklisted/removed seeds so they don't keep repopulating
                    try {
                        const removedSet = getRemovedSeedSet();
                        const seedsToPersist = (this.seeds || []).filter(s => s && !removedSet.has(s.id));
                        localStorage.setItem("seeds", JSON.stringify(seedsToPersist));
                    } catch (e) {
                        // fallback to naive persist
                        localStorage.setItem("seeds", JSON.stringify(this.seeds));
                    }
                    localStorage.setItem("plants", JSON.stringify(this.plants));
                    localStorage.setItem("caps", JSON.stringify(this.caps));
                } catch (e) {
                    console.warn('db.save failed', e);
                }
            }
        };

        // Remove local seeds that no longer exist on the remote DB.
        // Runs at startup when Supabase is available to keep local memory consistent.
        async function reconcileSeedsWithRemote() {
            // Avoid overlapping reconciles and throttle when remote/storage is flaky.
            if (!initSupabase()) return;
            if (reconcilingSeeds) return;
            const now = Date.now();
            if (now - lastReconcileAt < RECON_MIN_INTERVAL_MS) return;
            if (reconFailureCount >= RECON_FAILURE_THRESHOLD && (now - lastReconFailureAt) < RECON_COOLDOWN_MS) {
                // Recently failed too many times; skip reconcile until cooldown
                return;
            }
            reconcilingSeeds = true;
            lastReconcileAt = now;
            let success = false;
            try {
                const { data, error } = await supabase.from('seeds').select('id');
                if (error) throw error;
                const remoteIds = new Set((data || []).map(s => s.id));
                const before = db.seeds.length;
                // Keep only remote seeds, but also respect client-side removed blacklist so we don't re-add removed ones
                const removedSet = getRemovedSeedSet();
                db.seeds = (db.seeds || []).filter(s => s && remoteIds.has(s.id) && !removedSet.has(s.id));
                const removed = before - db.seeds.length;
                if (removed > 0) {
                    console.log(`Reconciled seeds: removed ${removed} local seed(s) not found remotely.`);
                    db.save();
                    try { renderPicker(); renderRandomThree(); } catch (e) { /* ignore UI race */ }
                }

                // Additionally, verify thumbnail URLs for remaining seeds and remove/blacklist unreachable ones
                const remaining = db.seeds || [];
                if (remaining.length) {
                    const CONCURRENCY = 5;
                    let idx = 0;
                    async function checkSeed(s) {
                        try {
                            // Build candidate URLs to try. Prefer publicUrl from storage helper, but also try fallback paths
                            const tryUrls = [];
                            const candidate = (s.thumbs && s.thumbs[0]) || (s.full_images && s.full_images[0]) || null;
                            if (candidate && typeof candidate === 'string' && candidate.startsWith('http')) {
                                tryUrls.push(candidate);
                            }
                            // helper to push storage-derived url variants
                            const pushStorageVariants = (key) => {
                                if (!key) return;
                                try {
                                    const pub = supabase.storage.from('garden').getPublicUrl(key);
                                    const pubUrl = (pub && pub.data && pub.data.publicUrl) || '';
                                    if (pubUrl) tryUrls.push(pubUrl);
                                } catch (e) { /* ignore */ }
                                if (SUPABASE_URL) {
                                    const host = SUPABASE_URL.replace(/^https?:\/\//, '').replace(/\/$/, '');
                                    // canonical lowercase path
                                    tryUrls.push(`https://${host}/storage/v1/object/public/garden/${encodeURIComponent(key)}`);
                                    // also try a variant with capitalized folder in case of inconsistent casing from older uploads
                                    tryUrls.push(`https://${host}/storage/v1/object/public/Garden/${encodeURIComponent(key)}`);
                                }
                            };
                            if (candidate && typeof candidate === 'string' && !candidate.startsWith('http')) {
                                pushStorageVariants(candidate);
                            } else if (s.file_keys && s.file_keys[0]) {
                                pushStorageVariants(s.file_keys[0]);
                            } else if (s.seed_prefix) {
                                const key = `${s.seed_prefix}_frame_0.png`;
                                pushStorageVariants(key);
                            }

                            if (!tryUrls.length) return { id: s.id, ok: false };

                            // Try each candidate URL until one succeeds
                            for (const url of tryUrls) {
                                try {
                                    const h = await fetch(url, { method: 'HEAD' });
                                    if (h && h.ok) return { id: s.id, ok: true };
                                } catch (e) { /* ignore */ }
                                try {
                                    const g = await fetch(url, { method: 'GET' });
                                    if (g && g.ok) return { id: s.id, ok: true };
                                } catch (e) { /* ignore */ }
                            }
                            return { id: s.id, ok: false };
                        } catch (e) { return { id: s.id, ok: false }; }
                    }

                    async function next() {
                        if (idx >= remaining.length) return;
                        const chunk = remaining.slice(idx, idx + CONCURRENCY);
                        idx += CONCURRENCY;
                        const results = await Promise.all(chunk.map(checkSeed));
                        results.forEach(r => {
                            if (!r.ok) {
                                const fails = incSeedFailCount(r.id);
                                if (fails >= SEED_FAIL_THRESHOLD) {
                                    // blacklist and remove locally
                                    addRemovedSeed(r.id);
                                    db.seeds = (db.seeds || []).filter(x => x && x.id !== r.id);
                                }
                            } else {
                                try { resetSeedFailCount(r.id); } catch (e) { /* ignore */ }
                            }
                        });
                        return next();
                    }

                    try {
                        await next();
                        db.save();
                        try { renderPicker(); renderRandomThree(); } catch (e) { /* ignore */ }
                    } catch (e) { console.warn('thumbnail verification failed', e); }
                }

                // If we reached this point without throwing, mark success
                success = true;
            } catch (e) {
                console.warn('reconcileSeedsWithRemote failed', e);
            } finally {
                reconcilingSeeds = false;
                lastReconcileAt = Date.now();
                if (success) {
                    reconFailureCount = 0;
                } else {
                    reconFailureCount = Math.min(Number.MAX_SAFE_INTEGER, reconFailureCount + 1);
                    lastReconFailureAt = Date.now();
                }
            }
        }

        /* ------------- Supabase setup ------------- */
        let supabase = null;
        function initSupabase() {
            // Return early if client already initialized (prevents multiple GoTrueClient instances)
            if (supabase) return true;
            if (SUPABASE_URL === "YOUR_SUPABASE_URL" || SUPABASE_ANON_KEY === "YOUR_SUPABASE_ANON_KEY") {
                return false;
            }
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

            // Set up real-time subscriptions (only once)
            try {
                supabase
                    .channel('garden-changes')
                    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'plants' }, (payload) => {
                        db.plants.push(payload.new);
                        renderField();
                    })
                    .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'plants' }, (payload) => {
                        const plantIndex = db.plants.findIndex(p => p.id === payload.new.id);
                        if (plantIndex >= 0) {
                            db.plants[plantIndex] = payload.new;
                            renderField();
                        }
                    })
                    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'seeds' }, (payload) => {
                        try {
                            const removedSet = getRemovedSeedSet();
                            const newId = payload.new && payload.new.id;
                            if (!newId) return;
                            if (removedSet.has(newId)) {
                                console.log('Ignoring realtime INSERT for client-removed seed', newId);
                                return;
                            }
                            // avoid duplicates
                            if (db.seeds.some(s => s && s.id === newId)) return;
                            db.seeds.unshift(payload.new);
                            // persist new seeds to local fallback so offline/refresh keeps them
                            try { db.save(); } catch (e) { /* ignore */ }
                            renderPicker();
                            renderRandomThree();
                        } catch (e) { console.warn('Failed handling seed INSERT realtime', e); }
                    })
                    .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'seeds' }, (payload) => {
                        try {
                            const id = payload.old && payload.old.id;
                            if (id) {
                                db.seeds = (db.seeds || []).filter(s => s && s.id !== id);
                                try { db.save(); } catch (e) { /* ignore */ }
                                renderPicker(); renderRandomThree();
                                console.log('Seed deleted remotely, removed locally:', id);
                            }
                        } catch (e) { console.warn('Failed handling seed DELETE realtime', e); }
                    })
                    .subscribe();
            } catch (e) {
                console.warn('Realtime subscription failed to initialize:', e);
            }

            return true;
        }

        /* ------------- UI helpers ------------- */
        const $ = sel => document.querySelector(sel);
        const $$ = sel => Array.from(document.querySelectorAll(sel));
        function toast(msg, ms = 1800) {
            const t = $("#toast");
            if (!t) return console.warn('toast: #toast element not found');
            t.textContent = msg;
            t.style.display = "block";
            setTimeout(() => t.style.display = "none", ms);
        }
        function updateCapsUI() {
            const el = $("#caps");
            if (!el) return; // defensive: page may not include caps element in some contexts
            const key = db.twoMinuteKey();
            const caps = db.caps[key] || { make: 0, pick: 0, plant: 0 };
            el.textContent = `30min window — make: ${caps.make}/${DAILY_CAPS.make} • pick: ${caps.pick}/${DAILY_CAPS.pick} • plant: ${caps.plant}/${DAILY_CAPS.plant}`;
        }

        /* ------------- Drawing 4 frames ------------- */
        const framesEl = $("#frames");
        const frameLabel = $("#frameLabel");
        let currentFrame = 0;
        const N = 4;
    const CANVAS_SIZE = 32;
        const frames = (framesEl ? [...Array(N)].map(() => {
            const c = document.createElement("canvas");
            c.width = CANVAS_SIZE;
            c.height = CANVAS_SIZE;
            c.className = "frame";
            const ctx = c.getContext("2d");
            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = "#0d1726";
            ctx.fillRect(15, 15, 2, 2);
            framesEl.appendChild(c);
            return c;
        }) : []);

    // Undo stack per frame (stores snapshots). Each entry is { small: ImageData, large: ImageData|null }
    const undoStacks = frames.map(() => []);

        // Large canvas for bigger drawing area and preview
        const largeCanvas = document.getElementById('largeCanvas');
        const largeCtx = largeCanvas ? largeCanvas.getContext('2d') : null;
        if (largeCtx) largeCtx.imageSmoothingEnabled = false;

        // helper to copy from small canvas to large and vice versa
        function syncSmallToLarge(idx) {
            if (!frames[idx] || !largeCtx) return;
            // clear large
            largeCtx.clearRect(0,0,largeCanvas.width, largeCanvas.height);
            // draw upscaled small frame into large canvas
            largeCtx.drawImage(frames[idx], 0, 0, largeCanvas.width, largeCanvas.height);
        }

        function syncLargeToSmall(idx) {
            if (!frames[idx] || !largeCtx) return;
            const sCtx = frames[idx].getContext('2d');
            // get image data from large canvas downscaled to small
            const tmp = document.createElement('canvas');
            tmp.width = CANVAS_SIZE; tmp.height = CANVAS_SIZE;
            const tctx = tmp.getContext('2d');
            tctx.imageSmoothingEnabled = false;
            tctx.drawImage(largeCanvas, 0, 0, tmp.width, tmp.height);
            const data = tctx.getImageData(0,0,tmp.width,tmp.height);
            sCtx.putImageData(data, 0, 0);
        }

        // highlight currently selected small frame
        function highlightSelectedFrame() {
            frames.forEach((c, i) => c.classList.toggle('selected', i === currentFrame));
        }
        highlightSelectedFrame();

        function label() {
            if (!frameLabel) return;
            frameLabel.textContent = `Frame ${currentFrame + 1}/${N}`;
            highlightSelectedFrame();
            // sync large canvas to newly selected small frame
            syncSmallToLarge(currentFrame);
        }
        label();

        let tool = "pencil";
        let color = '#ffffff';
        // pencil/eraser size (in pixels on large canvas)
        let pencilSize = 4;
        const pencilSizeEl = document.getElementById('pencilSize');
        if (pencilSizeEl) {
            pencilSize = parseInt(pencilSizeEl.value || '4', 10);
            pencilSizeEl.addEventListener('input', (ev) => { pencilSize = parseInt(ev.target.value || '4', 10); });
        }
        const colorEl = $("#color");
        if (colorEl) color = colorEl.value;
        const toolPencilEl = $("#toolPencil");
        if (toolPencilEl) toolPencilEl.onclick = () => { tool = "pencil"; toast("Pencil"); };
        const toolEraserEl = $("#toolEraser");
        if (toolEraserEl) toolEraserEl.onclick = () => { tool = "eraser"; toast("Eraser"); };
    const toolCircleEl = $("#toolCircle");
    const toolSquareEl = $("#toolSquare");
    const toolTriangleEl = $("#toolTriangle");
    const toolStarEl = $("#toolStar");
    if (toolCircleEl) toolCircleEl.onclick = () => { tool = "circle"; toast("Circle"); };
    if (toolSquareEl) toolSquareEl.onclick = () => { tool = "square"; toast("Square"); };
    if (toolTriangleEl) toolTriangleEl.onclick = () => { tool = "triangle"; toast("Triangle"); };
    if (toolStarEl) toolStarEl.onclick = () => { tool = "star"; toast("Star"); };
        if (colorEl) colorEl.oninput = e => color = e.target.value;
        // keep color preview in sync
        const colorPreview = document.getElementById('colorPreview');
        if (colorPreview && colorEl) { colorPreview.style.background = colorEl.value; colorEl.addEventListener('input', (e)=>{ colorPreview.style.background = e.target.value; }); }
        // wire fill and step back tools
        const toolFillEl = document.getElementById('toolFill');
        const toolStepBackEl = document.getElementById('toolStepBack');
        if (toolFillEl) toolFillEl.onclick = () => { tool = 'fill'; toast('Fill tool'); };
        if (toolStepBackEl) toolStepBackEl.onclick = () => {
            // pop undo for current frame and restore both small and large snapshots
            const stack = undoStacks[currentFrame];
            if (!stack || !stack.length) { toast('Nothing to undo'); return; }
            const snap = stack.pop();
            const sCtx = frames[currentFrame].getContext('2d');
            try {
                if (snap && snap.small) sCtx.putImageData(snap.small, 0, 0);
            } catch (e) { console.warn('restore small snapshot failed', e); }
            // If we have a high-res large snapshot, restore it too so we don't re-upscale the small canvas
            try {
                if (largeCtx && snap && snap.large) {
                    largeCtx.putImageData(snap.large, 0, 0);
                } else {
                    // Fallback: sync small -> large if no large snapshot was saved
                    syncSmallToLarge(currentFrame);
                }
            } catch (e) { console.warn('restore large snapshot failed', e); }
        };
        const prevEl = $("#prev");
        if (prevEl) prevEl.onclick = () => { currentFrame = (currentFrame - 1 + N) % N; label(); };
        const nextEl = $("#next");
        if (nextEl) nextEl.onclick = () => { currentFrame = (currentFrame + 1) % N; label(); };
        const clearEl = $("#clear");
        if (clearEl) clearEl.onclick = () => {
            if (!frames[currentFrame]) return;
            try {
                // push undo snapshot for this clear action
                const sctx = frames[currentFrame].getContext('2d');
                const smallSnap = sctx.getImageData(0,0,CANVAS_SIZE,CANVAS_SIZE);
                let largeSnap = null;
                try { largeSnap = largeCtx ? largeCtx.getImageData(0,0,largeCanvas.width, largeCanvas.height) : null; } catch(e){ largeSnap = null; }
                undoStacks[currentFrame].push({ small: smallSnap, large: largeSnap });
            } catch(e){}
            const ctx = frames[currentFrame].getContext("2d");
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            try { if (largeCtx) largeCtx.clearRect(0,0,largeCanvas.width, largeCanvas.height); } catch(e) {}
        };

        function drawOnCanvas(c, e, drawing) {
            const rect = c.getBoundingClientRect();
            const scaleX = c.width / rect.width;
            const scaleY = c.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            const ctx = c.getContext("2d");
            ctx.imageSmoothingEnabled = false;
            if (tool === "pencil") {
                ctx.fillStyle = color;
                // map large canvas pencil size to small canvas scale
                const scale = (CANVAS_SIZE / (largeCanvas ? largeCanvas.width : 320));
                const s = Math.max(1, Math.min(CANVAS_SIZE, Math.round(pencilSize * scale)));
                // center scaled brush so clicks align visually
                const ox = Math.max(0, Math.floor(s/2));
                ctx.fillRect(x - ox, y - ox, s, s);
            } else {
                // eraser on small canvas: clear a scaled area
                const scale = (CANVAS_SIZE / (largeCanvas ? largeCanvas.width : 320));
                const s = Math.max(1, Math.min(CANVAS_SIZE, Math.round(pencilSize * scale)));
                const ox = Math.max(0, Math.floor(s/2));
                ctx.clearRect(x - ox, y - ox, s, s);
            }
        }

        // Small frame canvases are now selection-only: clicking a small frame selects it
        frames.forEach((c, idx) => {
            // make sure small frames don't capture pointer events for drawing
            c.style.touchAction = 'manipulation';
            c.addEventListener('click', (e) => {
                // Select this frame and sync the large canvas to show it for editing
                currentFrame = idx;
                label();
                // Highlight selection handled by label()/highlightSelectedFrame
            });
            // Prevent accidental drawing via pointer events on small frames
            c.addEventListener('pointerdown', (e) => { e.preventDefault(); });
            c.addEventListener('pointermove', (e) => { /* noop */ });
            c.addEventListener('pointerup', (e) => { /* noop */ });
        });

        // flood fill for small canvas (works on 32x32). Uses ImageData and stack-based fill.
        function floodFillSmall(canvas, sx, sy, targetRGBA) {
            const w = canvas.width, h = canvas.height;
            const ctx = canvas.getContext('2d');
            const img = ctx.getImageData(0,0,w,h);
            const data = img.data;
            function idx(x,y){ return (y*w + x) * 4; }
            const start = idx(sx, sy);
            const sr = data[start], sg = data[start+1], sb = data[start+2], sa = data[start+3];
            if (sr === targetRGBA[0] && sg === targetRGBA[1] && sb === targetRGBA[2] && sa === targetRGBA[3]) return;
            const visited = new Uint8Array(w*h);
            const stack = [[sx,sy]];
            while (stack.length) {
                const [x,y] = stack.pop();
                if (x < 0 || x >= w || y < 0 || y >= h) continue;
                const i = y*w + x;
                if (visited[i]) continue;
                visited[i] = 1;
                const off = idx(x,y);
                if (data[off] === sr && data[off+1] === sg && data[off+2] === sb && data[off+3] === sa) {
                    data[off] = targetRGBA[0]; data[off+1] = targetRGBA[1]; data[off+2] = targetRGBA[2]; data[off+3] = targetRGBA[3];
                    stack.push([x+1,y]); stack.push([x-1,y]); stack.push([x,y+1]); stack.push([x,y-1]);
                }
            }
            ctx.putImageData(img,0,0);
        }

        // Large canvas drawing logic (interpolated to avoid gaps)
        if (largeCanvas) {
            let ldrawing = false;
            // track last pointer position (in canvas pixels)
            let lastLargeX = null, lastLargeY = null;
            largeCanvas.addEventListener('pointerdown', (e)=>{
                ldrawing = true;
                largeCanvas.setPointerCapture(e.pointerId);
                // push undo snapshot for this frame: store both small (32x32) and large (high-res) image data
                try {
                    const sctx = frames[currentFrame].getContext('2d');
                    const smallSnap = sctx.getImageData(0,0,CANVAS_SIZE,CANVAS_SIZE);
                    let largeSnap = null;
                    try { largeSnap = largeCtx ? largeCtx.getImageData(0,0,largeCanvas.width, largeCanvas.height) : null; } catch(e){ largeSnap = null; }
                    undoStacks[currentFrame].push({ small: smallSnap, large: largeSnap });
                } catch(e){}
                // reset last pos so the first draw is single-point
                lastLargeX = null; lastLargeY = null;
                largeDraw(e);
            });
            largeCanvas.addEventListener('pointermove', (e)=>{ if (ldrawing) largeDraw(e); });
            largeCanvas.addEventListener('pointerup', (e)=>{ ldrawing = false; lastLargeX = null; lastLargeY = null; syncLargeToSmall(currentFrame); });
            largeCanvas.addEventListener('pointerout', (e)=>{ /* keep drawing only while pointer captured */ });

            function largeDraw(e) {
                if (!largeCanvas) return;
                const rect = largeCanvas.getBoundingClientRect();
                const scaleX = largeCanvas.width / rect.width;
                const scaleY = largeCanvas.height / rect.height;
                const x = Math.floor((e.clientX - rect.left) * scaleX);
                const y = Math.floor((e.clientY - rect.top) * scaleY);

                if (tool === 'fill') {
                    try { floodFillLarge(x, y, hexToRgba(color)); } catch (err) { console.warn('fill failed', err); }
                    return;
                }

                // helper: draw a centered shape at (cx,cy) with diameter/size s
                function drawShapeCentered(ctx, cx, cy, s, shape, col) {
                    ctx.save();
                    ctx.imageSmoothingEnabled = false;
                    ctx.fillStyle = col;
                    ctx.strokeStyle = col;
                    ctx.lineWidth = Math.max(1, Math.round(s * 0.08));
                    const half = Math.round(s/2);
                    if (shape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(cx, cy, half, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (shape === 'square') {
                        ctx.fillRect(cx - half, cy - half, s, s);
                    } else if (shape === 'triangle') {
                        // Draw triangle with apex at (cx, cy) so it can align to the pencil tip.
                        ctx.beginPath();
                        const baseY = cy + half;
                        ctx.moveTo(cx, cy); // apex at provided coordinate
                        ctx.lineTo(cx - half, baseY);
                        ctx.lineTo(cx + half, baseY);
                        ctx.closePath();
                        ctx.fill();
                    } else if (shape === 'star') {
                        // simple 5-pointed star
                        const spikes = 5;
                        const outer = half;
                        const inner = Math.max(1, Math.round(half * 0.45));
                        let rot = Math.PI / 2 * 3;
                        let xPos = cx;
                        let yPos = cy;
                        ctx.beginPath();
                        for (let i = 0; i < spikes; i++) {
                            ctx.lineTo(xPos + Math.cos(rot) * outer, yPos + Math.sin(rot) * outer);
                            rot += Math.PI / spikes;
                            ctx.lineTo(xPos + Math.cos(rot) * inner, yPos + Math.sin(rot) * inner);
                            rot += Math.PI / spikes;
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.restore();
                }

                const s = Math.max(1, Math.round(pencilSize));

                // Cursor SVG coordinates: viewBox 0..24; hotspot used in CSS is 12,12.
                // Tip coordinates from the SVG path are approximately (20.71, 7.04).
                const cursorTipDeltaClient = { x: 20.71 - 12, y: 7.04 - 12 }; // in CSS pixels relative to hotspot

                const drawAt = (dx, dy) => {
                    // convert cursor tip delta from client/CSS px into canvas pixels
                    const rect = largeCanvas.getBoundingClientRect();
                    const scaleX_local = largeCanvas.width / rect.width;
                    const scaleY_local = largeCanvas.height / rect.height;
                    const tipCx = Math.round(dx + (cursorTipDeltaClient.x * scaleX_local));
                    const tipCy = Math.round(dy + (cursorTipDeltaClient.y * scaleY_local));
                    const halfS = Math.round(s/2);

                    // compute butt (mirrored) position as well
                    const buttCx = Math.round(dx - (cursorTipDeltaClient.x * scaleX_local));
                    const buttCy = Math.round(dy - (cursorTipDeltaClient.y * scaleY_local));

                    if (tool === 'pencil') {
                        // pencil now draws at the butt end (mirrored position)
                        largeCtx.fillStyle = color;
                        largeCtx.fillRect(buttCx - halfS, buttCy - halfS, s, s);
                    } else if (tool === 'eraser') {
                        // eraser clears at the visible tip
                        largeCtx.clearRect(tipCx - halfS, tipCy - halfS, s, s);
                    } else if (tool === 'circle' || tool === 'square' || tool === 'triangle' || tool === 'star') {
                        // Per-shape placement: square should draw at the butt (same end as pencil);
                        // circle and triangle need to be swapped: circle -> butt, triangle -> tip.
                        // star defaults to tip.
                        let drawX = tipCx, drawY = tipCy;
                        if (tool === 'square') {
                            drawX = buttCx; drawY = buttCy;
                        } else if (tool === 'circle') {
                            // circle at butt
                            drawX = buttCx; drawY = buttCy;
                        } else if (tool === 'triangle') {
                            // triangle at tip, shifted left and down for visual alignment
                            drawX = tipCx; drawY = tipCy;
                            // convert client/CSS pixel offsets into canvas pixels
                            const triClientOffsetX = -16; // negative = left (moved 8px more)
                            const triClientOffsetY = 8;   // positive = down
                            drawX = Math.round(drawX + (triClientOffsetX * scaleX_local));
                            drawY = Math.round(drawY + (triClientOffsetY * scaleY_local));
                        } else if (tool === 'star') {
                            drawX = tipCx; drawY = tipCy;
                        }
                        drawShapeCentered(largeCtx, drawX, drawY, s, tool, color);
                    }
                };

                if (lastLargeX === null || lastLargeY === null) {
                    drawAt(x, y);
                } else {
                    const dx = x - lastLargeX;
                    const dy = y - lastLargeY;
                    const steps = Math.max(Math.abs(dx), Math.abs(dy));
            if (steps === 0) drawAt(x, y);
                    else {
                        for (let i = 0; i <= steps; i++) {
                            const ix = Math.round(lastLargeX + dx * (i / steps));
                            const iy = Math.round(lastLargeY + dy * (i / steps));
                drawAt(ix, iy);
                        }
                    }
                }

                lastLargeX = x; lastLargeY = y;
            }
        }

        // Simple flood fill on large canvas (byte-level ImageData)
        function floodFillLarge(sx, sy, targetRGBA) {
            const w = largeCanvas.width, h = largeCanvas.height;
            const img = largeCtx.getImageData(0,0,w,h);
            const data = img.data;
            function idx(x,y){ return (y*w + x) * 4; }
            const start = idx(sx, sy);
            const sr = data[start], sg = data[start+1], sb = data[start+2], sa = data[start+3];
            // if color already matches, no-op
            if (sr === targetRGBA[0] && sg === targetRGBA[1] && sb === targetRGBA[2] && sa === targetRGBA[3]) return;
            const visited = new Uint8Array(w*h);
            const stack = [[sx,sy]];
            while (stack.length) {
                const [x,y] = stack.pop();
                if (x < 0 || x >= w || y < 0 || y >= h) continue;
                const i = y*w + x;
                if (visited[i]) continue;
                visited[i] = 1;
                const off = idx(x,y);
                if (data[off] === sr && data[off+1] === sg && data[off+2] === sb && data[off+3] === sa) {
                    data[off] = targetRGBA[0]; data[off+1] = targetRGBA[1]; data[off+2] = targetRGBA[2]; data[off+3] = targetRGBA[3];
                    stack.push([x+1,y]); stack.push([x-1,y]); stack.push([x,y+1]); stack.push([x,y-1]);
                }
            }
            largeCtx.putImageData(img,0,0);
        }

        function hexToRgba(hex) {
            let h = hex.replace('#',''); if (h.length === 3) h = h.split('').map(c=>c+c).join('');
            const n = parseInt(h,16); return [(n>>16)&255, (n>>8)&255, n&255, 255];
        }

        /* ------------- Supabase storage upload ------------- */
        // Upload a single canvas frame using a deterministic seedId so filenames are predictable.
        async function uploadCanvasFrame(canvas, seedId, frameIndex) {
            const blob = await new Promise(res => canvas.toBlob(res, "image/png"));
            const fileName = `${seedId}_frame_${frameIndex}.png`;

            const { data, error } = await supabase.storage
                .from('garden')
                .upload(fileName, blob, {
                    contentType: 'image/png',
                    upsert: false
                });

            if (error) {
                throw new Error("Supabase upload failed: " + error.message);
            }

            const { data: { publicUrl } } = supabase.storage
                .from('garden')
                .getPublicUrl(fileName);

            return { fileName, publicUrl };
        }

        $("#submitSeed").onclick = async () => {
            if (!db.can("make")) { toast("Make action on cooldown"); return; }
            if (!initSupabase()) { toast("Set SUPABASE_URL and SUPABASE_ANON_KEY first"); return; }
            try {
                $("#submitSeed").disabled = true;
                // Use a deterministic seed id so uploaded file names are predictable.
                const seedId = crypto.randomUUID();
                const links = [];
                const fileKeys = [];
                for (let i = 0; i < N; i++) {
                    const { fileName, publicUrl } = await uploadCanvasFrame(frames[i], seedId, i);
                    links.push(publicUrl);
                    fileKeys.push(fileName);
                }
                const seed = {
                    id: seedId,
                    thumbs: links,
                    full_images: links,
                    file_keys: fileKeys,
                    seed_prefix: seedId,
                    status: "waiting",
                    created_at: new Date().toISOString()
                };
                await db.addSeed(seed);
                db.bump("make");
                updateTimers();
                renderPicker();
                toast("Seed submitted to the community garden!");
            } catch (err) {
                console.error(err);
                toast(err.message.slice(0, 220));
            } finally {
                $("#submitSeed").disabled = false;
            }
        };

        /* ------------- Seed picker ------------- */
        let pickedSeedId = null;
        let pickedThumbnail = null;

        // Persisted client-side list of seeds to hide (broken references).
        const REMOVED_SEEDS_KEY = 'removed_seeds';
        const FAIL_COUNTS_KEY = 'seed_fail_counts';
        function getSeedFailCounts() {
            try { return JSON.parse(localStorage.getItem(FAIL_COUNTS_KEY) || '{}'); } catch (e) { return {}; }
        }
        function incSeedFailCount(id) {
            try {
                const m = getSeedFailCounts();
                m[id] = (m[id] || 0) + 1;
                localStorage.setItem(FAIL_COUNTS_KEY, JSON.stringify(m));
                return m[id];
            } catch (e) { return 1; }
        }
        function resetSeedFailCount(id) {
            try {
                const m = getSeedFailCounts();
                if (m && m[id]) { delete m[id]; localStorage.setItem(FAIL_COUNTS_KEY, JSON.stringify(m)); }
            } catch (e) { /* ignore */ }
        }
        const SEED_FAIL_THRESHOLD = 3; // require this many failures before blacklisting
        function getRemovedSeedSet() {
            try {
                const arr = JSON.parse(localStorage.getItem(REMOVED_SEEDS_KEY) || '[]');
                return new Set(Array.isArray(arr) ? arr : []);
            } catch (e) { return new Set(); }
        }
        function addRemovedSeed(id) {
            try {
                const set = getRemovedSeedSet();
                set.add(id);
                localStorage.setItem(REMOVED_SEEDS_KEY, JSON.stringify(Array.from(set)));
            } catch (e) { console.warn('addRemovedSeed failed', e); }
        }


        function renderPicker() {
            const el = $("#picker");
            if (!el) return;
            // If we have a live DB, request a reconcile but avoid spamming when already running or recently run
            if (initSupabase()) {
                try {
                    if (!reconcilingSeeds && (Date.now() - lastReconcileAt) >= RECON_MIN_INTERVAL_MS) {
                        reconcileSeedsWithRemote().catch(e => console.warn('reconcileSeedsWithRemote failed in renderPicker', e));
                    }
                } catch (e) { /* ignore */ }
            }
            el.innerHTML = "";
            // Only show seeds that are available: not marked deleted and have at least one usable image/key
            const removedSet = getRemovedSeedSet();
            const isSeedAvailable = s => {
                if (!s) return false;
                if (removedSet.has(s.id)) return false;
                if (s.status && String(s.status).toLowerCase() === 'deleted') return false;
                if (Array.isArray(s.thumbs) && s.thumbs[0]) return true;
                if (Array.isArray(s.full_images) && s.full_images[0]) return true;
                if (Array.isArray(s.file_keys) && s.file_keys[0]) return true;
                if (s.seed_prefix) return true;
                return false;
            };

            const available = (db.seeds || []).filter(isSeedAvailable);
            // Helper to remove a seed locally and persist
            const removeSeedLocal = (seedId) => {
                const before = db.seeds.length;
                db.seeds = (db.seeds || []).filter(x => x && x.id !== seedId);
                if (db.seeds.length !== before) {
                    // remember this removal to prevent re-adding from remote/realtime
                    try { addRemovedSeed(seedId); } catch (e) { /* ignore */ }
                    try { db.save(); } catch (e) { console.warn('save failed', e); }
                    try { renderPicker(); renderRandomThree(); } catch (e) { /* ignore */ }
                }
            };

            available.forEach(s => {
                const div = document.createElement("div");
                div.className = "seed";
                const img = document.createElement("img");
                img.src = (s.thumbs && s.thumbs[0]) || (s.full_images && s.full_images[0]) || '';
                // If the image fails to load, remove the seed from local memory so it's not shown again
                img.onerror = () => {
                    try {
                        const fails = incSeedFailCount(s.id);
                        console.warn('Seed thumbnail failed to load', s.id, 'fail count', fails);
                        if (fails >= SEED_FAIL_THRESHOLD) {
                            console.warn('Seed thumbnail failed repeatedly, removing seed locally:', s.id);
                            addRemovedSeed(s.id);
                            removeSeedLocal(s.id);
                        }
                    } catch (e) { console.warn('img.onerror handling failed', e); }
                };
                img.onload = () => { try { resetSeedFailCount(s.id); } catch (e) {} };
                // Just display the seed image, no pick button
                div.appendChild(img);
                el.appendChild(div);
            });
            if (!available.length) {
                el.innerHTML = `<div class="note muted">No seeds yet. Make one!</div>`;
            }
        }

        // Show three random seeds (first-frame thumbnails)
        async function renderRandomThree() {
            const el = $("#randomThree");
            if (!el) return;
            // debounce frequent calls
            if (Date.now() - lastRandomRenderAt < RANDOM_MIN_INTERVAL_MS) return;
            lastRandomRenderAt = Date.now();
            // Ensure local seeds are reconciled with remote when rendering random picks, but throttle
            if (initSupabase()) {
                try {
                    if (!reconcilingSeeds && (Date.now() - lastReconcileAt) >= RECON_MIN_INTERVAL_MS) {
                        reconcileSeedsWithRemote().catch(e => console.warn('reconcileSeedsWithRemote failed in renderRandomThree', e));
                    }
                } catch (e) { /* ignore */ }
            }
            el.innerHTML = '';
            let pool = [];
            if (initSupabase()) {
                try {
                    const { data, error } = await supabase.from('seeds').select('id, thumbs, full_images, status');
                    if (!error && data) pool = data;
                } catch (e) {
                    console.warn('Failed to fetch seeds for random picks, falling back:', e);
                }
            }
            if (!pool.length) {
                // fallback to local in-memory list
                pool = db.seeds;
            }
            // Filter out deleted/invalid seeds so the picker doesn't reference removed seeds
            const removedSet = getRemovedSeedSet();
            const isSeedAvailable = s => {
                if (!s) return false;
                if (removedSet.has(s.id)) return false;
                if (s.status && String(s.status).toLowerCase() === 'deleted') return false;
                if (Array.isArray(s.thumbs) && s.thumbs[0]) return true;
                if (Array.isArray(s.full_images) && s.full_images[0]) return true;
                if (Array.isArray(s.file_keys) && s.file_keys[0]) return true;
                if (s.seed_prefix) return true;
                return false;
            };
            pool = (pool || []).filter(isSeedAvailable);
            if (!pool.length) {
                el.innerHTML = '<div class="note muted">No seeds yet</div>';
                return;
            }
            // Always show 3 picks, allowing duplicates if needed
            const picks = [];
            for (let i = 0; i < 3; i++) {
                if (pool.length > 0) {
                    const randomIndex = Math.floor(Math.random() * pool.length);
                    picks.push(pool[randomIndex]);
                }
            }
            picks.forEach(s => {
                const wrap = document.createElement('div');
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.alignItems = 'center';
                wrap.style.gap = '6px';
                wrap.dataset.seedId = s.id;
                const img = document.createElement('img');
                // Resolve the thumbnail URL: thumbs may be public URLs or storage keys
                let srcUrl = '';
                try {
                    const candidate = (s.thumbs && s.thumbs[0]) || (s.full_images && s.full_images[0]) || null;
                    if (candidate && typeof candidate === 'string' && candidate.startsWith('http')) {
                        srcUrl = candidate;
                    } else if (candidate && typeof candidate === 'string') {
                        // candidate looks like a file key, try to get public url
                        if (initSupabase()) {
                            try {
                                const pub = supabase.storage.from('garden').getPublicUrl(candidate);
                                srcUrl = (pub && pub.data && pub.data.publicUrl) || '';
                                // If getPublicUrl didn't return a URL, construct the public URL directly
                                if (!srcUrl && SUPABASE_URL) {
                                    const host = SUPABASE_URL.replace(/^https?:\/\//, '').replace(/\/$/, '');
                                    srcUrl = `https://${host}/storage/v1/object/public/garden/${encodeURIComponent(candidate)}`;
                                    console.log('constructed public url fallback for candidate', candidate, srcUrl);
                                }
                            } catch (e) { console.warn('getPublicUrl failed for candidate', candidate, e); }
                        }
                    } else if (s.file_keys && s.file_keys[0]) {
                        if (initSupabase()) {
                            try {
                                const pub = supabase.storage.from('garden').getPublicUrl(s.file_keys[0]);
                                srcUrl = (pub && pub.data && pub.data.publicUrl) || '';
                                if (!srcUrl && SUPABASE_URL) {
                                    const host = SUPABASE_URL.replace(/^https?:\/\//, '').replace(/\/$/, '');
                                    srcUrl = `https://${host}/storage/v1/object/public/garden/${encodeURIComponent(s.file_keys[0])}`;
                                    console.log('constructed public url fallback for file_keys', s.file_keys[0], srcUrl);
                                }
                            } catch (e) { console.warn('getPublicUrl failed for file_keys', s.file_keys[0], e); }
                        }
                    } else if (s.seed_prefix) {
                        const key = `${s.seed_prefix}_frame_0.png`;
                        if (initSupabase()) {
                            try {
                                const pub = supabase.storage.from('garden').getPublicUrl(key);
                                srcUrl = (pub && pub.data && pub.data.publicUrl) || '';
                                if (!srcUrl && SUPABASE_URL) {
                                    const host = SUPABASE_URL.replace(/^https?:\/\//, '').replace(/\/$/, '');
                                    srcUrl = `https://${host}/storage/v1/object/public/garden/${encodeURIComponent(key)}`;
                                    console.log('constructed public url fallback for seed_prefix', key, srcUrl);
                                }
                            } catch (e) { console.warn('getPublicUrl failed for seed_prefix', key, e); }
                        }
                    }
                } catch (e) { console.warn('thumbnail resolution error', e); }
                img.src = srcUrl || '';
                // If the remote thumbnail is broken/unavailable, remove the seed locally so it won't appear again
                img.onerror = () => {
                    try {
                        const fails = incSeedFailCount(s.id);
                        console.warn('Random pick thumbnail failed to load', s.id, 'fail count', fails);
                        if (fails >= SEED_FAIL_THRESHOLD) {
                            console.warn('Random pick thumbnail failed repeatedly, removing seed locally:', s.id);
                            addRemovedSeed(s.id);
                            try { db.seeds = (db.seeds || []).filter(x => x && x.id !== s.id); db.save(); } catch (e) { /* ignore */ }
                            try { renderRandomThree(); renderPicker(); } catch (e) { /* ignore */ }
                        }
                    } catch (e) { console.warn('img.onerror failed', e); }
                };
                img.onload = () => { try { resetSeedFailCount(s.id); } catch (e) {} };
                // suppressed verbose log to avoid console spam
                img.style.width = '64px';
                img.style.height = '64px';
                img.style.objectFit = 'contain';
                img.style.borderRadius = '6px';
                const btn = document.createElement('button');
                btn.textContent = 'Pick';
                btn.onclick = () => {
                    if (!db.can('pick')) { toast('Pick action on cooldown'); return; }
                    pickedSeedId = s.id;
                    pickedThumbnail = img.src || null;
                    db.bump('pick');
                    db.save();
                    updateTimers();
                    if (pickedThumbnail) {
                        $("#pickedInfo").innerHTML = `<img src="${pickedThumbnail}" style="width:40px;height:40px;vertical-align:middle;border-radius:6px;margin-right:8px"> Picked ${s.id.slice(0, 6)}…`;
                    } else {
                        $("#pickedInfo").textContent = `Picked seed ${s.id.slice(0, 6)}…`;
                    }
                    toast('Seed picked. Click the field to plant.');
                };
                // Button state will be managed by updateTimers()
                wrap.appendChild(img);
                wrap.appendChild(btn);
                el.appendChild(wrap);
            });
        }

        const refreshRandomEl = $("#refreshRandom");
        if (refreshRandomEl) refreshRandomEl.onclick = () => renderRandomThree();

        async function debugSeeds() {
            const infoEl = $("#debugInfo");
            if (!infoEl) console.warn('debugInfo missing');
            infoEl.textContent = 'Checking...';
            console.log('debugSeeds called');
            let remote = null;
            try {
                if (initSupabase()) {
                    const { data, error } = await supabase.from('seeds').select('id,status,thumbs').order('created_at', { ascending: false }).limit(100);
                    if (error) throw error;
                    remote = data || [];
                }
            } catch (e) {
                console.error('debugSeeds remote error', e);
                infoEl.textContent = 'Error fetching remote seeds: ' + (e.message || String(e));
            }
            const local = db.seeds || [];
            try {
                let statusInfo = '';
                if (remote && remote.length) {
                    const statusCounts = {};
                    remote.forEach(s => {
                        statusCounts[s.status || 'unknown'] = (statusCounts[s.status || 'unknown'] || 0) + 1;
                    });
                    statusInfo = ` • status: ${Object.entries(statusCounts).map(([k, v]) => `${k}:${v}`).join(', ')}`;
                }
                infoEl.textContent = `local: ${local.length} seeds; remote: ${remote ? remote.length : 'n/a'} seeds${statusInfo}`;
                if (remote && remote.length) {
                    const sample = remote.slice(0, 3).map(r => (r.id || '').slice(0, 6)).join(', ');
                    infoEl.textContent += ` • sample ids: ${sample}`;
                }
            } catch (e) {
                console.error('debugSeeds ui error', e);
            }
            console.log('debugSeeds remote', remote);
            console.log('debugSeeds local', local.slice(0, 20));
        }

        const debugSeedsBtn = $("#debugSeedsBtn");
        if (debugSeedsBtn) debugSeedsBtn.onclick = () => debugSeeds();

        const pickRandomEl = $("#pickRandom");
        if (pickRandomEl) pickRandomEl.onclick = () => {
            pickedSeedId = null;
            pickedThumbnail = null;
            const pickedInfoEl2 = $("#pickedInfo");
            if (pickedInfoEl2) pickedInfoEl2.textContent = "No seed picked.";
        };

        /* ------------- Field (planting + display) ------------- */
        const field = $("#field");
        if (!field) throw new Error('Field element (#field) not found in DOM');

        // Create the large world surface inside the field. Plants will be positioned in world-space.
        const world = document.createElement('div');
        world.className = 'world';
        field.appendChild(world);

        // World transform state
        let scale = 1;
        let tx = 0; // translation x
        let ty = 0; // translation y

        // Helper: apply CSS transform to world
        function applyWorldTransform() {
            world.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
        }
        applyWorldTransform();

        // Convert viewport (client) coords -> world coords
        function clientToWorld(clientX, clientY) {
            const rect = field.getBoundingClientRect();
            const vx = clientX - rect.left; // viewport-local
            const vy = clientY - rect.top;
            const wx = (vx - tx) / scale;
            const wy = (vy - ty) / scale;
            return { x: Math.round(wx), y: Math.round(wy) };
        }

        // Planting now uses world coordinates so plants remain at the correct world positions while panning/zooming
        async function plantAtClient(clientX, clientY) {
            if (!pickedSeedId) return toast("Pick a seed first");
            if (!db.can("plant")) return toast("Plant action on cooldown");
            const { x, y } = clientToWorld(clientX, clientY);
            // Ensure the picked seed exists. If supabase is available, verify remotely. If missing, clean up local copy.
            let s = db.seeds.find(s => s.id === pickedSeedId);
            if (initSupabase() && pickedSeedId) {
                try {
                    const { data: remoteSeed, error } = await supabase.from('seeds').select('id').eq('id', pickedSeedId).maybeSingle();
                    if (error) throw error;
                    if (!remoteSeed) {
                        // seed deleted remotely — remove locally and clear pick
                        db.seeds = (db.seeds || []).filter(x => x && x.id !== pickedSeedId);
                        try { db.save(); } catch (e) { /* ignore */ }
                        renderPicker(); renderRandomThree();
                        pickedSeedId = null; pickedThumbnail = null;
                        return toast('Picked seed missing (removed)');
                    }
                } catch (e) {
                    console.warn('seed existence check failed', e);
                    // fall back to local seed object
                }
                s = db.seeds.find(s => s.id === pickedSeedId);
            }
            if (!s) return toast("Picked seed missing");

            try {
                // Don't mark seed as "picked" - keep it available for reuse
                const plant = {
                    id: crypto.randomUUID(),
                    seed_id: s.id,
                    x,
                    y,
                    planted_at: new Date().toISOString(),
                    waters: []
                };
                await db.addPlant(plant);
                db.bump("plant");
                updateTimers();
                pickedSeedId = null;
                $("#pickedInfo").textContent = "No seed picked.";
                renderField();
                toast("Planted in the community garden! 🌱");
            } catch (error) {
                console.error('Error planting:', error);
                toast("Error planting seed");
            }
        }

        // ===== Pan and zoom handling =====
        // Middle mouse drag to pan. Wheel to zoom (while holding ctrl or not). Touch pinch to zoom.
        let isPanning = false;
        let maybePan = false;
        let panStart = { x: 0, y: 0 };
        let startTx = 0, startTy = 0;
        const DRAG_THRESHOLD = 6; // pixels before we consider the action a drag/pan
        let lastPointer = { x: 0, y: 0, t: 0 };
        let vel = { x: 0, y: 0 }; // pixels per ms
        let inertiaId = null;

        field.addEventListener('pointerdown', (e) => {
            // If the pointerdown happened on a plant (or inside one), do NOT start panning so selection wins.
            if (e.target && e.target.closest && e.target.closest('.plant')) {
                maybePan = false;
                isPanning = false;
                return; // allow the plant element to receive the event and handle selection
            }
            // Allow middle-button to immediately start panning. For left-button we wait until movement exceeds threshold.
            if (e.button === 1) {
                isPanning = true;
                maybePan = false;
            } else if (e.button === 0) {
                maybePan = true;
            } else {
                maybePan = false;
                isPanning = false;
                return;
            }
            panStart = { x: e.clientX, y: e.clientY };
            startTx = tx; startTy = ty;
            lastPointer = { x: e.clientX, y: e.clientY, t: Date.now() };
            vel = { x: 0, y: 0 };
            field.setPointerCapture(e.pointerId);
            field.style.cursor = 'grabbing';
            inertiaId && cancelAnimationFrame(inertiaId);
        });

        // To support space+drag we mark when space is pressed
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') field.spaceKey = true; });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') field.spaceKey = false; });

        field.addEventListener('pointermove', (e) => {
            if (!maybePan && !isPanning) return;
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            if (!isPanning && maybePan) {
                if (Math.hypot(dx, dy) > DRAG_THRESHOLD) {
                    isPanning = true;
                    maybePan = false;
                } else {
                    return; // not yet a pan
                }
            }
            if (isPanning) {
                const now = Date.now();
                const dt = Math.max(1, now - lastPointer.t);
                // update velocity (px per ms)
                vel.x = (e.clientX - lastPointer.x) / dt;
                vel.y = (e.clientY - lastPointer.y) / dt;
                lastPointer = { x: e.clientX, y: e.clientY, t: now };
                tx = startTx + dx;
                ty = startTy + dy;
                clampWorld();
                applyWorldTransform();
            }
        });

        field.addEventListener('pointerup', (e) => {
            field.releasePointerCapture?.(e.pointerId);
            field.style.cursor = 'default';
            if (isPanning) {
                // start inertia animation based on last velocity
                isPanning = false;
                const FRICTION = 0.92; // per frame multiplier
                let last = Date.now();
                function step() {
                    const now = Date.now();
                    const dt = Math.max(1, now - last);
                    last = now;
                    // apply velocity (convert px/ms to px)
                    tx += vel.x * dt;
                    ty += vel.y * dt;
                    // decay velocity
                    vel.x *= Math.pow(FRICTION, dt / 16);
                    vel.y *= Math.pow(FRICTION, dt / 16);
                    // stop when tiny
                    if (Math.hypot(vel.x, vel.y) < 0.001) {
                        clampWorld();
                        applyWorldTransform();
                        inertiaId = null;
                        return;
                    }
                    clampWorld();
                    applyWorldTransform();
                    inertiaId = requestAnimationFrame(step);
                }
                inertiaId = requestAnimationFrame(step);
            } else {
                // Not a pan: treat as click for planting when left button
                if (e.button === 0) {
                    plantAtClient(e.clientX, e.clientY);
                }
            }
            maybePan = false;
        });

        // Clicking on empty ground should deselect/hide stats
        field.addEventListener('click', (e) => {
            if (e.target && e.target.closest && !e.target.closest('.plant')) {
                selectedPlantId = null;
                hideStats();
                renderField();
            }
        });

        // Wheel zoom centered at mouse position
        const ZOOM_SENS = 0.0006; // smaller = less sensitive
        const MIN_SCALE = 0.2;
        const MAX_SCALE = 4;
        function clampWorld() {
            const vw = field.clientWidth;
            const vh = field.clientHeight;
            const ww = world.offsetWidth * scale;
            const wh = world.offsetHeight * scale;
            if (ww <= vw) {
                // center horizontally
                tx = Math.round((vw - ww) / 2);
            } else {
                const minTx = vw - ww; // most negative
                const maxTx = 0;
                tx = Math.min(maxTx, Math.max(minTx, tx));
            }
            if (wh <= vh) {
                ty = Math.round((vh - wh) / 2);
            } else {
                const minTy = vh - wh;
                const maxTy = 0;
                ty = Math.min(maxTy, Math.max(minTy, ty));
            }
        }

        field.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = field.getBoundingClientRect();
            const before = clientToWorld(e.clientX, e.clientY);
            const zoomFactor = Math.exp(-e.deltaY * ZOOM_SENS);
            const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * zoomFactor));
            // Compute new tx/ty so the world point under cursor remains under the cursor
            tx = (e.clientX - rect.left) - before.x * newScale;
            ty = (e.clientY - rect.top) - before.y * newScale;
            scale = newScale;
            clampWorld();
            applyWorldTransform();
        }, { passive: false });

        // Simple touch pinch support
        let ongoingTouches = [];
        field.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                ongoingTouches = [e.touches[0], e.touches[1]];
            }
        }, { passive: false });
        field.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && ongoingTouches.length === 2) {
                e.preventDefault();
                const t0 = e.touches[0];
                const t1 = e.touches[1];
                const prevDist = Math.hypot(ongoingTouches[0].clientX - ongoingTouches[1].clientX, ongoingTouches[0].clientY - ongoingTouches[1].clientY);
                const newDist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
                const rect = field.getBoundingClientRect();
                const midX = (t0.clientX + t1.clientX) / 2;
                const midY = (t0.clientY + t1.clientY) / 2;
                const before = clientToWorld(midX, midY);
                const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * (newDist / prevDist)));
                tx = (midX - rect.left) - before.x * newScale;
                ty = (midY - rect.top) - before.y * newScale;
                scale = newScale;
                clampWorld();
                applyWorldTransform();
                ongoingTouches = [t0, t1];
            }
        }, { passive: false });


        let selectedPlantId = null;
        function growthStage(p) {
            // Use an additive water bonus (bounded) instead of scaling the entire elapsed time.
            // This prevents watering from retroactively inflating past elapsed time and skipping stages.
            const plantedAt = toTimestamp(p.planted_at ? p.planted_at : p.plantedAt);
            const elapsed = Date.now() - plantedAt;
            const waters = p.waters || [];
            const lastWater = waters.length ? toTimestamp(waters[waters.length - 1]) : 0;
            const WATER_BOOST_FRAC = 0.3; // 30% of one stage
            const WATER_BOOST_MS = Math.round(STAGE_MS * WATER_BOOST_FRAC);
            const recentlyWatered = lastWater && (Date.now() - lastWater) <= STAGE_MS;
            const bonus = recentlyWatered ? WATER_BOOST_MS : -WATER_BOOST_MS;
            const effectiveElapsed = Math.max(0, elapsed + bonus);
            const t = Math.min(TOTAL_MS, effectiveElapsed);
            return Math.min(3, Math.floor(t / STAGE_MS));
        }

        function nextWaterAt(p) {
            const waters = p.waters || [];
            if (!waters.length) return 0;
            const last = toTimestamp(waters[waters.length - 1]);
            if (!last) return 0;
            return last + WATER_COOLDOWN_MS;
        }

        function renderField() {
            // Keep the viewport element but render plants inside the world element
            // Clear world children (but keep the world element itself)
            // clear _el refs
            db.plants.forEach(p => { delete p._el; });
            world.innerHTML = "";
            db.plants.forEach(p => {
                const seed = db.seeds.find(s => s.id === (p.seed_id || p.seedId));
                if (!seed) return;

                const stage = growthStage(p);
                const plant = document.createElement("div");
                plant.className = "plant";
                // Position in world coords
                plant.style.left = p.x + "px";
                plant.style.top = p.y + "px";
                plant.title = `Community Plant ${p.id.slice(0, 6)} • stage ${stage + 1}/4 • waters ${(p.waters || []).length}`;

                // pin (visual red dot) removed per request

                const img = document.createElement("img");
                img.className = "stage";
                img.src = (seed.full_images || seed.full)[stage];
                // Scale plant based on growth stage: seed=0.8x, sprout=1x, bud=1.2x, bloom=1.4x
                const scaleFactors = [0.8, 1.0, 1.2, 1.4];
                img.style.transform = `scale(${scaleFactors[stage]})`;
                plant.appendChild(img);

                // If this is the seed phase (stage 0), make the image invisible
                // but keep the plant element present and interactive so it can be
                // selected/highlighted. We add a class that hides only the image.
                if (stage === 0) {
                    plant.classList.add('seed-hidden');
                    // adjust title so users know it's a seeded spot
                    plant.title = `Seeded spot • ${p.id ? p.id.slice(0, 6) + '…' : ''} • click to inspect`;
                }
                // add a small visible marker so users can find the seeded location
                if (stage === 0) {
                    const dot = document.createElement('div');
                    dot.className = 'seed-dot';
                    plant.appendChild(dot);
                }

                plant.onclick = (ev) => {
                    // map click target: clicks on plants should select them. Stop propagation so field click doesn't plant.
                    ev.stopPropagation();
                    selectedPlantId = p.id;
                    updateWaterButton();
                    renderField();
                    showStats(p);
                };

                if (p.id === selectedPlantId) {
                    plant.classList.add('selected');
                }

                // Attach the plant element node to the plant object for stats anchoring
                p._el = plant;

                world.appendChild(plant);
            });
        }

        // --- Plant stats bubble ---
        const statsEl = $('#plantStats');
        function showStats(p) {
            if (!p || !p._el) return;
            statsEl.style.display = 'block';
            statsEl.setAttribute('aria-hidden', 'false');
            // compute values
            const seed = db.seeds.find(s => s.id === (p.seed_id || p.seedId));
            const stage = growthStage(p);
            const waters = (p.waters || []).length;
            const nextWater = nextWaterAt(p);
            const nextWaterText = nextWater > Date.now() ? formatMs(nextWater - Date.now()) : 'ready';
            // compute time until next growth stage for the phase countdown (use normalized timestamps)
            const plantedAtMs = toTimestamp(p.planted_at ? p.planted_at : p.plantedAt);
            const elapsed = Date.now() - plantedAtMs;
            const lastWater = (p.waters && p.waters.length) ? toTimestamp(p.waters[p.waters.length - 1]) : 0;
            const WATER_BOOST_FRAC = 0.3;
            const WATER_BOOST_MS = Math.round(STAGE_MS * WATER_BOOST_FRAC);
            const recentlyWatered = lastWater && (Date.now() - lastWater) <= STAGE_MS;
            const bonus = recentlyWatered ? WATER_BOOST_MS : -WATER_BOOST_MS;
            const effectiveElapsed = Math.max(0, elapsed + bonus);
            const t = Math.min(TOTAL_MS, effectiveElapsed);
            const currStage = Math.min(3, Math.floor(t / STAGE_MS));
            const nextStageEffectiveAt = Math.min(TOTAL_MS, (currStage + 1) * STAGE_MS);
            // convert effective next-stage time back to real wall-clock time
            // Since bonus is additive (ms), the wall-clock next-stage is simply plantedAt + nextStageEffectiveAt - bonus
            const msToNextStage = Math.ceil((plantedAtMs + nextStageEffectiveAt - bonus) - Date.now());
            const nextStageText = (currStage >= 3) ? 'mature' : (msToNextStage > 0 ? formatMs(msToNextStage) : 'soon');
            const plantedAt = p.planted_at ? new Date(toTimestamp(p.planted_at)).toLocaleString() : '';
            statsEl.innerHTML = `
                <div class="card" style="padding:10px;">
                    <button class="close">✕</button>
                    <h3 style="margin:4px 0 6px;">Plant ${p.id.slice(0, 6)}…</h3>
                    <div style="font-size:13px;color:var(--muted);margin-bottom:8px">Planted: ${plantedAt}</div>
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                        <div style="font-weight:700">Stage</div>
                        <div style="background:#0b1420;padding:6px 8px;border-radius:8px">${stage + 1}/4</div>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                        <div style="font-weight:700">Waters</div>
                        <div style="background:#0b1420;padding:6px 8px;border-radius:8px">${waters}</div>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                        <div style="font-weight:700">Next water</div>
                        <div style="background:#0b1420;padding:6px 8px;border-radius:8px">${nextWaterText}</div>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                        <div style="font-weight:700">Phase countdown</div>
                        <div style="background:#0b1420;padding:6px 8px;border-radius:8px">${nextStageText}</div>
                    </div>
                </div>
            `;

            // position the statsEl to the right of the plant when possible
            const rect = field.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const plantVx = tx + p.x * scale + rect.left;
            const plantVy = ty + p.y * scale + rect.top;
            const padding = 12;
            statsEl.style.left = '0px'; statsEl.style.top = '0px'; statsEl.style.display = 'block';
            const box = statsEl.getBoundingClientRect();
            // prefer right of plant
            let left = plantVx + 18;
            let top = plantVy - box.height / 2;
            // If right would clip, try left side
            if (left + box.width + padding > vw) {
                left = plantVx - box.width - 18;
            }
            // clamp vertically
            top = Math.max(rect.top + padding, Math.min(rect.bottom - box.height - padding, top));
            // set initial transform to slightly left for slide-in; use rAF to trigger transition
            statsEl.style.left = `${left}px`;
            statsEl.style.top = `${top}px`;
            statsEl.style.transform = 'translateX(-8px) scale(.98)';
            statsEl.classList.remove('visible');
            requestAnimationFrame(() => requestAnimationFrame(() => statsEl.classList.add('visible')));

            // wire close button to deselect
            const closeBtn = statsEl.querySelector('.close');
            if (closeBtn) closeBtn.onclick = () => { selectedPlantId = null; hideStats(); renderField(); };
        }

        function hideStats() {
            statsEl.classList.remove('visible');
            statsEl.style.transform = 'translateY(0px) scale(.98)';
            // wait for transition then hide
            setTimeout(() => {
                statsEl.style.display = 'none';
                statsEl.setAttribute('aria-hidden', 'true');
            }, 220);
            selectedPlantId = null;
            updateWaterButton();
        }

        // --- Timers and countdowns ---
        const refreshIntervalMs = AUTO_REFRESH_MS;
        let lastRefreshTick = Date.now();

        function formatMs(ms) {
            if (ms <= 0) return '0s';
            const s = Math.floor(ms / 1000);
            if (s < 60) return `${s}s`;
            const m = Math.floor(s / 60);
            const sec = s % 60;
            return `${m}m ${sec}s`;
        }

        function updateTimers() {
            // per-plant timers: next stage
            db.plants.forEach(p => {
                const el = p._el && p._el.querySelector && p._el.querySelector('.water');
                if (!el) return;
                const plantedAt = toTimestamp(p.planted_at ? p.planted_at : p.plantedAt);
                const elapsed = Date.now() - plantedAt;
                const waters = p.waters || [];
                const lastWater = waters.length ? toTimestamp(waters[waters.length - 1]) : 0;
                const WATER_BOOST_FRAC = 0.3;
                const WATER_BOOST_MS = Math.round(STAGE_MS * WATER_BOOST_FRAC);
                const recentlyWatered = lastWater && (Date.now() - lastWater) <= STAGE_MS;
                const bonus = recentlyWatered ? WATER_BOOST_MS : -WATER_BOOST_MS;
                const effectiveElapsed = Math.max(0, elapsed + bonus);
                const t = Math.min(TOTAL_MS, effectiveElapsed);
                const stage = Math.min(3, Math.floor(t / STAGE_MS));
                // next stage effective ms since planted is (stage+1)*STAGE_MS
                // wall-clock next stage = plantedAt + ((stage+1)*STAGE_MS) - bonus
                const nextStageAt = plantedAt + ((stage + 1) * STAGE_MS) - bonus;
                const msLeft = nextStageAt - Date.now();
                if (stage >= 3) {
                    el.textContent = 'mature';
                } else {
                    el.textContent = formatMs(msLeft);
                }
            });

            // Individual action cooldown system

            // selected plant water cooldown
            const btn = $("#waterSelected");
            if (selectedPlantId && btn) {
                const p = db.plants.find(x => x.id === selectedPlantId);
                if (p) {
                    const next = nextWaterAt(p);
                    if (Date.now() < next) {
                        btn.textContent = `💧 Water (${formatMs(next - Date.now())})`;
                        btn.disabled = true;
                    } else {
                        btn.textContent = '💧 Water selected plant';
                        btn.disabled = false;
                    }
                }
            } else if (btn) {
                btn.textContent = '💧 Water selected plant';
            }

            // --- Individual action cooldown timers ---
            const makePill = $('#makeTimer');
            const pickPill = $('#pickTimer');
            const waterPill = $('#waterTimer');

            // Make timer
            if (makePill) {
                const lastMake = db.caps.last_make || 0;
                const makeReady = Date.now() - lastMake >= ACTION_COOLDOWNS.make;
                if (!makeReady && lastMake > 0) {
                    const cooldownLeft = ACTION_COOLDOWNS.make - (Date.now() - lastMake);
                    makePill.querySelector('.count').textContent = formatMs(cooldownLeft);
                    makePill.classList.add('gray');
                    makePill.title = `Cooldown: ${formatMs(cooldownLeft)}`;
                    const submitBtn = $('#submitSeed');
                    if (submitBtn) submitBtn.disabled = true;
                } else {
                    makePill.querySelector('.count').textContent = 'ready';
                    makePill.classList.remove('gray');
                    makePill.title = '';
                    const submitBtn = $('#submitSeed');
                    if (submitBtn) submitBtn.disabled = false;
                }
            }

            // Pick timer
            if (pickPill) {
                const lastPick = db.caps.last_pick || 0;
                const pickReady = Date.now() - lastPick >= ACTION_COOLDOWNS.pick;
                if (!pickReady && lastPick > 0) {
                    const cooldownLeft = ACTION_COOLDOWNS.pick - (Date.now() - lastPick);
                    pickPill.querySelector('.count').textContent = formatMs(cooldownLeft);
                    pickPill.classList.add('gray');
                    pickPill.title = `Cooldown: ${formatMs(cooldownLeft)}`;
                    document.querySelectorAll('#randomThree button').forEach(b => b.disabled = true);
                } else {
                    pickPill.querySelector('.count').textContent = 'ready';
                    pickPill.classList.remove('gray');
                    pickPill.title = '';
                    document.querySelectorAll('#randomThree button').forEach(b => b.disabled = false);
                }
            }

            // Plant timer (water pill shows plant cooldown)
            if (waterPill) {
                const lastPlant = db.caps.last_plant || 0;
                const plantReady = Date.now() - lastPlant >= ACTION_COOLDOWNS.plant;
                if (!plantReady && lastPlant > 0) {
                    const cooldownLeft = ACTION_COOLDOWNS.plant - (Date.now() - lastPlant);
                    waterPill.querySelector('.count').textContent = formatMs(cooldownLeft);
                    waterPill.classList.add('gray');
                    waterPill.title = `Plant cooldown: ${formatMs(cooldownLeft)}`;
                } else {
                    waterPill.querySelector('.count').textContent = 'ready';
                    waterPill.classList.remove('gray');
                    waterPill.title = '';
                }

                // Water button logic (separate from plant cooldown)
                const waterBtn = $('#waterSelected');
                if (waterBtn && selectedPlantId) {
                    const sel = db.plants.find(x => x.id === selectedPlantId);
                    if (sel) {
                        const nextWater = nextWaterAt(sel);
                        waterBtn.disabled = Date.now() < nextWater;
                    }
                }
            }
            // Refresh the stats bubble for selected plant so values/countdowns update live
            if (selectedPlantId) {
                const p = db.plants.find(x => x.id === selectedPlantId);
                if (p) showStats(p);
            }
        }

        // Hook into refresh timer
        setInterval(() => {
            lastRefreshTick = Date.now();
            renderField();
        }, refreshIntervalMs);

        // Ticker every second to update countdowns
        setInterval(updateTimers, 1000);

        function updateWaterButton() {
            const btn = $("#waterSelected");
            if (!btn) return; // no water button present in this UI
            if (!selectedPlantId) { btn.disabled = true; return; }
            const p = db.plants.find(x => x.id === selectedPlantId);
            if (!p) { btn.disabled = true; return; }
            btn.disabled = (Date.now() < nextWaterAt(p));
        }
        const waterSelectedEl = $("#waterSelected");
        if (waterSelectedEl) waterSelectedEl.onclick = async () => {
            if (!selectedPlantId) return;
            const p = db.plants.find(x => x.id === selectedPlantId);
            if (!p) return;
            // Re-check cooldown using normalized timestamps
            const next = nextWaterAt(p);
            if (Date.now() < next) return toast("Water cooldown");

            // Immediate in-memory update to prevent rapid repeated clicks
            const now = Date.now();
            p.waters = [...(p.waters || []), now];
            updateWaterButton();
            renderField();
            // Persist change (async). If this fails, log and notify, but in-memory state prevents double-watering UI-wise.
            try {
                await db.updatePlant(selectedPlantId, { waters: p.waters });
                toast("Watered the community plant! 💧");
            } catch (error) {
                console.error('Error watering plant:', error);
                toast("Error watering plant");
            }
        };

        const refreshEl = $("#refresh");
        if (refreshEl) refreshEl.onclick = () => renderField();

        /* ------------- Seed grid click from thumbnails ------------- */
        if (framesEl) framesEl.addEventListener("click", e => {
            const idx = frames.indexOf(e.target);
            if (idx >= 0) { currentFrame = idx; label(); }
        });

        /* ------------- Boot ------------- */
        async function initApp() {
            if (initSupabase()) {
                await db.load();
                // ensure any locally-stored seeds that were deleted remotely are removed
                await reconcileSeedsWithRemote();
            }
            renderPicker();
            await renderRandomThree();
            renderField();
            updateTimers();
            setInterval(() => { renderField(); updateTimers(); }, AUTO_REFRESH_MS);
        }

        initApp();
    </script>
</body>

</html>