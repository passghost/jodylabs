<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JodyLabs â€” Orbital Interface</title>
  <meta name="description" content="An animated oneâ€‘page experience â€” draggable icon orb, target lock, and curated project panels from JodyLabs." />
  <link rel="canonical" href="https://passghost.github.io/jodylabs/VibeCode2/VC3/Vibe3.html" />
  <!-- Open Graph / Social -->
  <meta property="og:title" content="JodyLabs â€” Orbital Interface (Vibe3)" />
  <meta property="og:description" content="Interactive showcase of experiments, tools, and visual projects â€” explore previews and open demos directly from the orb interface." />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="JodyLabs" />
  <meta property="og:url" content="https://passghost.github.io/jodylabs/VibeCode2/VC3/Vibe3.html" />
  <meta property="og:image" content="https://drive.google.com/file/d/1XQXJlgIykHWHeVecXl3N79oPgy4FjX8O/view?usp=drive_link" />
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="JodyLabs â€” Orbital Interface (Vibe3)" />
  <meta name="twitter:description" content="Interactive showcase of experiments, tools, and visual projects â€” explore previews and open demos directly from the orb interface." />
  <meta name="twitter:image" content="https://drive.google.com/file/d/1XQXJlgIykHWHeVecXl3N79oPgy4FjX8O/view?usp=drive_link" />

  <!-- Supabase config (copied from Vibe4) -->
  <meta name="supabase-url" content="https://jgvxwtqdmbqnfliaalel.supabase.co">
  <meta name="supabase-anon-key" content="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Impndnh3dHFkbWJxbmZsaWFhbGVsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMDc4ODcsImV4cCI6MjA4MjU4Mzg4N30.t9FENiIHIeXozF0rsrNu0sxpGmi0Xvjrzz2RejASJy4">

  <!-- Structured data (JSON-LD) -->
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"WebPage","name":"JodyLabs â€” Orbital Interface","url":"https://passghost.github.io/jodylabs/VibeCode2/VC3/Vibe3.html","description":"Interactive showcase of experiments, tools, and visual projects from JodyLabs.","image":"https://drive.google.com/file/d/1XQXJlgIykHWHeVecXl3N79oPgy4FjX8O/view?usp=drive_link","publisher":{"@type":"Organization","name":"JodyLabs","url":"https://passghost.github.io/jodylabs/"}}
  </script>
  <style>
    /* --- RESET --- */
    *,*::before,*::after{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:#0a0a0c;color:#f4f4f5;overflow-x:hidden}
    h1,h2,h3,p{margin:0}
    a{color:inherit;text-decoration:none}

    :root{
      /* Default visual: Parchment (beige-black) */
      --accent:#f5e0c3; /* beige */
      --accent-2:#111111; /* near-black */
      --accent-3:#d6b58a; /* deeper beige */
      --eraser-lift: 120px; /* distance the eraser lifts and the search bar pushes */
      --text:#fbfbff;
      --muted:#c9c9d4;
      --panel:#0b0b13ee;
      --card:#0a0a12;
      --glass:rgba(255,255,255,.06);
      --radius:22px;
      --shadow:0 12px 34px rgba(214,181,138,.28), 0 10px 30px rgba(17,17,17,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Aurora (explicit) */
    :root[data-theme="aurora"]{
      --accent:#8b5cf6;
      --accent-2:#22d3ee;
      --accent-3:#f472b6;
      --shadow:0 12px 34px rgba(139,92,246,.28), 0 10px 30px rgba(34,211,238,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Neon (previous bright trio) */
    :root[data-theme="neon"]{
      --accent:#ff2ea6; /* hot pink */
      --accent-2:#21e6ff; /* electric cyan */
      --accent-3:#ffd442; /* citrus gold */
      --shadow:0 12px 34px rgba(255,46,166,.28), 0 10px 30px rgba(33,230,255,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Sunset */
    :root[data-theme="sunset"]{
      --accent:#fb923c; /* orange */
      --accent-2:#f472b6; /* pink */
      --accent-3:#60a5fa; /* sky */
      --shadow:0 12px 34px rgba(251,146,60,.28), 0 10px 30px rgba(96,165,250,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Forest */
    :root[data-theme="forest"]{
      --accent:#34d399; /* emerald */
      --accent-2:#84cc16; /* lime */
      --accent-3:#22c55e; /* green */
      --shadow:0 12px 34px rgba(52,211,153,.28), 0 10px 30px rgba(132,204,22,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Ocean */
    :root[data-theme="ocean"]{
      --accent:#60a5fa; /* blue */
      --accent-2:#22d3ee; /* cyan */
      --accent-3:#a78bfa; /* violet */
      --shadow:0 12px 34px rgba(96,165,250,.28), 0 10px 30px rgba(34,211,238,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Candy */
    :root[data-theme="candy"]{
      --accent:#f472b6; /* pink */
      --accent-2:#facc15; /* yellow */
      --accent-3:#22d3ee; /* cyan */
      --shadow:0 12px 34px rgba(244,114,182,.28), 0 10px 30px rgba(250,204,21,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Royal */
    :root[data-theme="royal"]{
      --accent:#a78bfa; /* purple */
      --accent-2:#f59e0b; /* amber */
      --accent-3:#60a5fa; /* blue */
      --shadow:0 12px 34px rgba(167,139,250,.28), 0 10px 30px rgba(245,158,11,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Beige and Black */
    :root[data-theme="beige-black"]{
      --accent:#f5e0c3; /* beige */
      --accent-2:#111111; /* near-black for contrast accents */
      --accent-3:#d6b58a; /* deeper beige */
      --shadow:0 12px 34px rgba(214,181,138,.28), 0 10px 30px rgba(17,17,17,.18), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Black and Red */
    :root[data-theme="black-red"]{
      --accent:#ef4444; /* red */
      --accent-2:#111111; /* black */
      --accent-3:#f87171; /* light red */
      --shadow:0 12px 34px rgba(239,68,68,.32), 0 10px 30px rgba(17,17,17,.22), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: White, Red and Black */
    :root[data-theme="white-red-black"]{
      --accent:#ffffff; /* white */
      --accent-2:#ef4444; /* red */
      --accent-3:#0b0b12; /* near black (fits current bg) */
      --shadow:0 12px 34px rgba(255,255,255,.18), 0 10px 30px rgba(239,68,68,.26), inset 0 1px 0 rgba(255,255,255,.06);
    }
    /* Theme: Purple and Green */
    :root[data-theme="purple-green"]{
      --accent:#8b5cf6; /* purple */
      --accent-2:#22c55e; /* green */
      --accent-3:#a78bfa; /* light purple */
      --shadow:0 12px 34px rgba(139,92,246,.32), 0 10px 30px rgba(34,197,94,.22), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* Theme: Slate Grey and Red */
    :root[data-theme="slate-red"]{
      --accent:#334155; /* slate */
      --accent-2:#ef4444; /* red */
      --accent-3:#64748b; /* lighter slate */
      --shadow:0 12px 34px rgba(100,116,139,.26), 0 10px 30px rgba(239,68,68,.22), inset 0 1px 0 rgba(255,255,255,.05);
    }
    /* --- Micro-animations --- */
    @keyframes pulseGlow{ 0%{ transform:scale(1); box-shadow:0 0 0 0 rgba(255,46,166,.35);} 70%{ transform:scale(1.08); box-shadow:0 0 30px 8px rgba(33,230,255,.15);} 100%{ transform:scale(1); box-shadow:0 0 0 0 rgba(33,230,255,0);} }
    @keyframes shimmer{ 0%{ background-position:0% 50%; } 100%{ background-position:100% 50%; } }

    /* --- Background --- */
    #bg {position:fixed;inset:0;z-index:-1;background:
      radial-gradient(1200px 800px at 80% -10%, color-mix(in oklab, var(--accent) 35%, transparent), transparent 60%),
      radial-gradient(900px 600px at 10% 120%, color-mix(in oklab, var(--accent-2) 28%, transparent), transparent 55%),
      radial-gradient(1000px 700px at 40% 40%, color-mix(in oklab, var(--accent-3) 16%, transparent), transparent 60%),
      linear-gradient(180deg,#050507 0%,#0b0b12 100%);
    }

    /* --- Top bar --- */
  .topbar{position:fixed;top:12px;left:12px;right:12px;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-radius:16px;background:var(--glass);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);box-shadow:var(--shadow);z-index:999}
    .brand{display:flex;gap:12px;align-items:center}
  .logo{width:30px;height:30px;border-radius:50%;overflow:hidden;display:grid;place-items:center;background:conic-gradient(from 220deg, var(--accent), var(--accent-2), var(--accent-3), var(--accent)); box-shadow:0 0 40px color-mix(in oklab, var(--accent) 50%, transparent)}
    .logo img{width:100%;height:100%;object-fit:cover;filter:drop-shadow(0 0 12px rgba(255,26,26,.35))}
    .brand h3{font-weight:800;letter-spacing:.4px}
  .pill{font-size:12px;color:var(--muted);padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.06)}
  .cta{display:inline-flex;align-items:center;gap:8px;background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));background-size:200% 100%;padding:10px 14px;border-radius:999px;color:#0a0a0c;font-weight:800;border:none;box-shadow:0 10px 26px color-mix(in oklab, var(--accent) 24%, transparent);cursor:pointer}
  .cta:hover{animation:shimmer 1.2s linear infinite}
  /* topbar controls: allow multiple items on the right */
  .topbar .controls{display:flex;align-items:center;gap:12px}
  /* small hit counter pill next to Contact */
  .hit-pill{display:inline-flex;align-items:center;justify-content:center;gap:6px;padding:6px 10px;font-size:12px;font-weight:700;color:#0a0a0c;background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:999px;border:1px solid rgba(0,0,0,0.15);box-shadow:0 8px 18px color-mix(in oklab, var(--accent) 24%, transparent);min-height:32px;min-width:40px}
  .hit-pill .counter-value{color:inherit}

    /* --- Hero --- */
    .hero{min-height:100svh;display:grid;place-items:center;padding:120px 20px 80px}
    .hero-inner{max-width:1200px;width:100%;display:grid;grid-template-columns:1.05fr .95fr;gap:28px;align-items:center}
    .headline{font-size:clamp(32px,6vw,64px);line-height:1.06;font-weight:900;letter-spacing:.2px}
  .headline .accent{background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));-webkit-background-clip:text;background-clip:text;color:transparent}
    .sub{margin-top:14px;color:var(--muted);font-size:clamp(14px,2vw,18px)}
    .hero-card{background:var(--glass);border:1px solid rgba(255,255,255,.08);border-radius:var(--radius);padding:18px;box-shadow:var(--shadow)}
  .hero-card{position:relative}
    .badges{display:flex;flex-wrap:wrap;gap:10px;margin-top:16px}
    .badge{padding:8px 10px;border-radius:999px;background:rgba(255,0,0,.06);border:1px solid rgba(255,0,0,.18);font-size:13px;color:#fff}

    /* --- Orbital stage (CENTERED SPHERE) --- */
    .stage{position:relative;min-height:520px;perspective:1200px;display:grid;place-items:center}
    .orbit-wrap{position:relative;width:min(90vw,680px);height:min(90vw,680px);max-width:700px;max-height:700px;transform-style:preserve-3d;user-select:none}
    .ring{position:relative;width:100%;height:100%;display:grid;place-items:center;transform-style:preserve-3d}
  /* ring is decorative only; let pointer events pass to node elements placed above it */
  .ring{pointer-events:none}
    .ring::before{content:"";position:absolute;inset:0;border-radius:50%;border:1.5px dashed rgba(255,255,255,.08)}
    .ring-bg{position:absolute;inset:12%;border-radius:50%;background-size:cover;background-position:center;filter:blur(6px) saturate(120%);opacity:0;transition:opacity .25s ease;mix-blend-mode:screen}

  /* allow pointer events to pass through decorative ring backgrounds and borders */
  .ring::before, .ring-bg { pointer-events: none; }
    .ring-bg.show{opacity:.22}

    /* Target indicator */
  .target{position:absolute;top:50%;right:2%;transform:translate(-50%,-50%);width:46px;height:46px;border-radius:50%;display:grid;place-items:center;z-index:3}
    .target::before,.target::after{content:"";position:absolute;border-radius:50%}
    .target::before{inset:0;border:2px solid rgba(255,255,255,.18)}
    .target::after{inset:8px;border:2px solid var(--accent)}
    .target .dot{width:8px;height:8px;border-radius:50%;background:var(--accent);box-shadow:0 0 14px rgba(255,26,26,.6)}

    .node{position:absolute;left:50%;top:50%;display:flex;flex-direction:column;align-items:center;gap:10px;transform-style:preserve-3d}
  .node{pointer-events:auto}
  /* Make orb icons brighter and more vivid */
  .node button{width:84px;height:84px;border:none;border-radius:50%;padding:0;background:#111;background-size:cover;background-position:center;border:1px solid rgba(255,255,255,.08);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);box-shadow:0 14px 36px color-mix(in oklab, var(--accent) 36%, transparent), 0 10px 24px color-mix(in oklab, var(--accent-2) 16%, transparent), inset 0 1px 0 rgba(255,255,255,.04);cursor:pointer;display:grid;place-items:center;position:relative;overflow:hidden;transition:transform .18s ease, box-shadow .18s ease, filter .18s ease;pointer-events:auto;filter:brightness(1.12) contrast(1.06) saturate(1.12)}
  /* reduce the dark vignette so icon artwork reads better */
  .node button::after{content:"";position:absolute;inset:0;background:radial-gradient(80px 80px at 50% 140%,rgba(0,0,0,0),rgba(0,0,0,.06));pointer-events:none;z-index:0}
  /* hover/focus: lift and further brighten so icons pop under pointer/keyboard focus */
  .node button:hover,.node button:focus{transform:translateY(-6px) scale(1.06);filter:brightness(1.38) contrast(1.12) saturate(1.28);box-shadow:0 26px 60px color-mix(in oklab, var(--accent) 42%, transparent), 0 10px 24px color-mix(in oklab, var(--accent-2) 20%, transparent);outline:none}
  /* Icon title label: placed on the node (outside the button) so it won't be clipped by overflow */
  /* place label in normal flow (below the circular button) so it centers naturally */
  .node .label{position:relative;margin-top:10px;font-size:13px;font-weight:800;color:#fff;background:linear-gradient(180deg, rgba(0,0,0,.64), rgba(0,0,0,.4));padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.08);text-shadow:0 3px 8px rgba(0,0,0,.6);max-width:160px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;box-sizing:border-box;z-index:6;pointer-events:none;align-self:center;opacity:0;transform:translateY(4px);transition:opacity .18s ease, transform .18s ease}
  .node.hit .label, .node:hover .label{opacity:1;transform:translateY(0)}
  .node.dim{filter:grayscale(.35) brightness(.9);opacity:.55}
    /* hit state: stronger glow and lift so the currently-targeted icon reads as the focal item */
  .node.hit button{box-shadow:0 0 0 3px color-mix(in oklab, var(--accent-2) 65%, transparent), 0 28px 56px color-mix(in oklab, var(--accent) 34%, transparent);transform:translateZ(8px) scale(1.02);filter:brightness(1.3) saturate(1.2)}

    .hint{position:absolute;bottom:8px;left:0;right:0;text-align:center;color:var(--muted);font-size:12px;opacity:.8}

    /* --- Search box (left column) - prominent red/black theme --- */
  .left-col{display:flex;flex-direction:column;align-items:center}
  /* make search-wrap relative so the floating card can position itself above; increased top margin for card room */
  .left-col .search-wrap{margin-top:64px;display:flex;gap:10px;align-items:center;justify-content:center;z-index:48;position:relative;transition:transform .5s cubic-bezier(.2,.9,.2,1)}
  .search-spacer{height:0;transition:height .5s cubic-bezier(.2,.9,.2,1)}
  .search-wrap input{width:min(520px,90%);padding:12px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg, rgba(28,6,6,.75), rgba(0,0,0,.45));color:var(--text);font-size:16px;box-shadow:0 8px 30px rgba(255,26,26,.18), inset 0 1px 0 rgba(255,255,255,.03);outline:none;transition:box-shadow .15s ease,transform .08s ease}
  .search-wrap input:focus{box-shadow:0 14px 40px rgba(255,26,26,.32);transform:translateY(-2px)}
  .search-wrap button{padding:12px 16px;border-radius:12px;border:none;background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));background-size:200% 100%;color:#0a0a0c;font-weight:800;cursor:pointer;box-shadow:0 10px 26px color-mix(in oklab, var(--accent) 28%, transparent)}
  .search-wrap button:hover{animation:shimmer 1.3s linear infinite}
  .search-wrap .theme-pill{font-size:13px;padding:8px 10px;border-radius:999px;background:linear-gradient(90deg, rgba(0,0,0,.18), rgba(255,0,0,.04));border:1px solid rgba(255,255,255,.06);color:var(--text);margin-left:6px}
  /* Ensure select and its dropdown are readable on Windows (avoid white-on-white) */
  .search-wrap select.theme-pill{background-color:#0b0b12 !important;background-image:none !important;color:var(--text) !important;border-color:rgba(255,255,255,.12)}
  .search-wrap select.theme-pill:focus{outline:none;box-shadow:0 0 0 2px color-mix(in oklab, var(--accent-2) 45%, transparent)}
  .search-wrap select.theme-pill option{background-color:#0b0b12;color:var(--text)}

  /* small Orbiq link placed under the search input */
  .orbiq-link{margin-top:12px;display:flex;justify-content:center}
  .orbiq-link a{display:inline-block;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));background-size:200% 100%;color:#0a0a0c;font-weight:800;text-decoration:none;box-shadow:0 8px 22px color-mix(in oklab, var(--accent-3) 18%, transparent)}
  .orbiq-link a:hover{animation:shimmer 1.3s linear infinite}

  /* quick category filters under search */
  .filters{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .chip{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.1);background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));color:#fff;font-weight:700;font-size:12px;cursor:pointer;user-select:none;transition:transform .15s ease, box-shadow .15s ease, background .2s ease}
  .chip:hover{transform:translateY(-1px); box-shadow:0 8px 16px rgba(0,0,0,.25)}
  .chip.active{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#0a0a0c;border-color:rgba(0,0,0,.2);box-shadow:0 10px 22px color-mix(in oklab, var(--accent) 22%, transparent)}

  /* floating search result card that appears above the search input */
  /* Make the popup fixed so it can be wider than the small search-wrap.
    JS will compute and set its left/top so it visually sits above the input. */
  .search-card-outer{position:fixed;left:50%;top:0;transform:translateX(-50%);width:min(380px,90vw);max-width:380px;pointer-events:auto;z-index:9999;/* animate vertical position only; make opacity change instant */transition:transform .36s cubic-bezier(.2,.9,.2,1), opacity 0s linear;opacity:0}
  /* when showing, we only adjust opacity/translate for subtle horizontal nudge; vertical is controlled by script via top */
  .search-card-outer.show{opacity:1}
  .search-card{position:relative;background:var(--card);border:1px solid transparent;border-radius:14px;padding:10px;box-shadow:0 18px 40px rgba(0,0,0,.6);display:flex;gap:10px;align-items:center;overflow:hidden}
  .search-card::before{content:"";position:absolute;inset:0;padding:1px;border-radius:14px;background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));-webkit-mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);-webkit-mask-composite:xor;mask-composite:exclude;pointer-events:none}
  .search-card img{width:84px;height:64px;object-fit:cover;border-radius:8px;flex:0 0 84px}
  .search-card .meta{flex:1;min-width:0}
  .search-card h4{margin:0;font-size:15px;font-weight:800}
  .search-card p{margin:6px 0 0;color:var(--muted);font-size:13px;line-height:1.2}
  .search-card a{display:inline-block;margin-top:8px;color:var(--accent-2);font-weight:700}

  /* eraser-like reveal: a mask that animates to reveal card content */
  /* The mask was darkening the card after reveal; keep the element for JS animations but make it transparent */
  .search-card .mask{position:absolute;inset:auto 0 0 0;height:100%;left:0;top:0;background:transparent;transform-origin:top;clip-path:inset(0 0 0 0);pointer-events:none;opacity:0}

  /* Eraser / presenter that moves the headline and subtext up and down */
  .eraser{position:relative;display:block;overflow:visible;transition:transform .5s cubic-bezier(.2,.9,.2,1);z-index:45}
  .eraser::after{content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:-6px;width:120px;height:12px;border-radius:8px;background:linear-gradient(90deg, rgba(0,0,0,.45), rgba(255,26,26,.06));box-shadow:0 10px 30px rgba(0,0,0,.6);opacity:0.9}
  /* when active, nudge upward to act as a presenter/eraser revealing content above */
  .eraser.active{transform:translateY(calc(var(--eraser-lift) * -1)) scale(0.995)}

  /* when the eraser lifts, push the search-wrap down the same distance */
  .search-wrap.pushed{transform:translateY(var(--eraser-lift))}


    /* --- Panels --- */
  /* allow panels to expand wider so individual cards can be very wide */
  .panel{position:fixed;inset:auto 14px 14px 14px;top:80px;max-width:1400px;width:calc(100% - 28px);margin:0 auto;background:var(--panel);border:1px solid transparent;border-radius:24px;box-shadow:var(--shadow);backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);transform-origin:var(--x,50%) var(--y,50%); transform:scale(.9) translateY(8px);opacity:0;pointer-events:none;transition:opacity .35s ease, transform .35s ease;z-index:50}
  .panel::before{content:"";position:absolute;inset:0;padding:1px;border-radius:24px;background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));-webkit-mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);-webkit-mask-composite:xor;mask-composite:exclude;pointer-events:none}
    .panel.open{opacity:1;transform:scale(1) translateY(0);pointer-events:auto}
    .panel header{display:flex;align-items:center;justify-content:space-between;padding:16px 18px;border-bottom:1px solid rgba(255,255,255,.06)}
    .panel header h3{font-weight:800}
    .panel .content{padding:18px;display:grid;gap:12px}

    /* small variant for concise popups like contact */
    .panel.small{
      max-width:420px;
      width:auto;
      min-width:220px;
      padding:12px;
      border-radius:14px;
      /* override default fixed inset so the small panel can center */
      left:50% !important;
      right:auto !important;
      top:50% !important;
      bottom:auto !important;
      transform-origin:center center;
      transform: translateX(-50%) translateY(-50%) scale(.95);
      max-height:60vh;
      overflow:hidden;
    }
    .panel.small.open{ transform: translateX(-50%) translateY(-50%) scale(1); }
    .panel.small .content{padding:12px; display:flex; align-items:center; justify-content:center; overflow:auto}
    .panel.small header{padding:10px 12px}
  /* default: one card per row (full width) so each card can be very wide */
  .panel .grid{display:grid;grid-template-columns:1fr;gap:20px}
  /* Make cards take the full row and layout image + meta inline so they get wider and shorter */
  .card{position:relative;background:var(--card);border:1px solid transparent;border-radius:12px;padding:8px;box-shadow:var(--shadow);display:flex;gap:12px;align-items:stretch;transition:transform .18s ease, box-shadow .18s ease}
  .card::before{content:"";position:absolute;inset:0;padding:1px;border-radius:12px;background:linear-gradient(90deg,var(--accent),var(--accent-2));-webkit-mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);mask:linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);-webkit-mask-composite:xor;mask-composite:exclude;pointer-events:none}
  .card:hover{transform:translateY(-2px); box-shadow:0 18px 46px rgba(0,0,0,.65), 0 12px 28px color-mix(in oklab, var(--accent) 16%, transparent)}
  .card img{width:28%;max-width:360px;height:auto;object-fit:cover;border-radius:10px;margin:0;flex:0 0 28%}
  .card .meta-inline{display:flex;flex-direction:column;flex:1;min-width:0}
  .card h4{margin:0;font-size:16px;line-height:1.1}
  .card p{margin:6px 0 0;color:var(--muted);font-size:13px;line-height:1.2}
  /* clamp descriptions so cards stay short */
  .card p{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;line-clamp:2}
    .close{background:transparent;border:1px solid rgba(255,255,255,.2);color:var(--text);border-radius:12px;padding:8px 10px;cursor:pointer}

    /* --- Footer --- */
    .footer{padding:40px 20px 70px;text-align:center;color:var(--muted)}

  /* --- Featured Strip --- */
  .feature-strip{max-width:1200px;margin:12px auto 0 auto;padding:10px 20px 34px}
  .feature-strip header{display:flex;align-items:center;justify-content:space-between;margin:0 0 12px 0}
  .feature-strip h3{font-size:18px;font-weight:900}
  .feature-strip .shuffle{padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.1);background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#0a0a0c;font-weight:800;cursor:pointer}
  .feature-rail{display:grid;grid-template-columns:repeat(3,1fr);gap:14px}
  .feature-card{display:flex;gap:12px;background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden;align-items:stretch}
  .feature-card img{width:42%;max-width:260px;height:auto;object-fit:cover}
  .feature-card .meta{padding:10px 10px 10px 0;display:flex;flex-direction:column}
  .feature-card h4{margin:0 0 6px 0;font-size:15px}
  .feature-card p{margin:0;color:var(--muted);font-size:13px;line-height:1.2;display:-webkit-box;-webkit-line-clamp:3;line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}
  .feature-card a{margin-top:auto;font-weight:800;color:var(--accent-2)}
  @media (max-width: 820px){ .feature-rail{grid-template-columns:1fr} .feature-card img{width:34%} }

    /* --- Responsive --- */
    @media (min-width: 1200px){
      /* on wide screens allow very wide columns (one or two depending on space) */
      .panel .grid{grid-template-columns:repeat(auto-fit,minmax(720px,1fr));gap:20px}
    }
    @media (max-width: 920px){
      .hero-inner{grid-template-columns:1fr;gap:20px}
      .stage{min-height:460px}
      .target{right:1.5%}
    }
    @media (max-width: 560px){
      .headline{font-size:clamp(28px,8vw,44px)}
      .topbar{top:8px;left:8px;right:8px;padding:8px 10px}
      .hero{padding:96px 14px 60px}
      .panel{left:8px;right:8px;top:72px;border-radius:18px}
  .node button{width:70px;height:70px}
  .node .label{font-size:12px;max-width:110px;padding:5px 8px;z-index:6}
  /* On small screens let the image scale down proportionally */
  .card img{width:36%;max-width:220px;height:auto;flex:0 0 36%}
      .badge{font-size:12px}
  .target{right:4%}
  .left-col{align-items:flex-start}
  .search-wrap input{width:100%;padding:10px 12px}
  /* reduce spacing on small screens so layout fits */
  .left-col .search-wrap{margin-top:28px}
  .filters{gap:6px}
  .chip{font-size:11px}
  #searchSpacer{height:0 !important}
    }
    @media (prefers-reduced-motion: reduce){
      .ring::before{animation:none}
    }

    /* filtered/dimmed orb nodes */
    .node.filtered{opacity:.18 !important;filter:grayscale(.6) brightness(.85);pointer-events:none}
    .node.filtered button{transform:scale(.6) !important}

    /* onboarding tip under search */
    .tip{margin-top:8px;color:var(--muted);font-size:12px;display:flex;gap:8px;align-items:center}
    .tip .dismiss{background:transparent;border:1px solid rgba(255,255,255,.2);color:var(--text);border-radius:10px;padding:2px 8px;font-size:11px;cursor:pointer}
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <nav class="topbar" aria-label="Primary">
    <div class="brand">
      <div class="logo" aria-hidden="true">
  <img src="https://passghost.github.io/OrbiqWebsite/Images/SphereIcon.png" alt="JodyLabs logo" />
      </div>
      <h3>JodyLabs</h3>
      <span class="pill">Interactive R&D</span>
    </div>
    <div class="controls">
      <button class="cta" id="contactOpen" aria-haspopup="dialog" aria-controls="panel-contact">Contact</button>
      <div class="hit-pill" id="hit-pill" title="Page hits">
        <span style="font-size:11px;color:rgba(0,0,0,0.6);font-weight:600;margin-right:4px;">Hits</span>
        <span class="counter-value" id="hit-count-pill">0</span>
      </div>
    </div>
  </nav>

  <main class="hero">
    <section class="hero-inner">
      <div class="left-col">
        <!-- eraser/presenter: this chunk will move up/down to reveal or cover the floating cards -->
        <div id="eraser" class="eraser" aria-hidden="false">
          <h1 class="headline">A laboratory of <span class="accent">code based experiments</span>.</h1>
          <p class="sub">An interactive showcase of tools, visuals, and prototypes built with my own artwork and code. Explore the cards to see whatâ€™s active right now.</p>
        
        
        <div style="margin-top: 20px; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; z-index: 100; position: relative;">
          <a href="../../VibeCode.html" style="background: linear-gradient(145deg, #1e1e1e, #2a2a2a); color: white; text-decoration: none; padding: 6px 14px; border-radius: 18px; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease; font-weight: 600; font-size: 0.85rem;">Vibe 1</a>
          <a href="../VibeCode2.html" style="background: linear-gradient(145deg, #1e1e1e, #2a2a2a); color: white; text-decoration: none; padding: 6px 14px; border-radius: 18px; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease; font-weight: 600; font-size: 0.85rem;">Vibe 2</a>
          <a href="Vibe3.html" style="background: linear-gradient(90deg, var(--accent), var(--accent-2)); color: #0a0a0c; text-decoration: none; padding: 6px 14px; border-radius: 18px; border: 1px solid rgba(0, 0, 0, 0.2); transition: all 0.3s ease; font-weight: 800; font-size: 0.85rem;">Vibe 3</a>
          <a href="Vibe4.html" style="background: linear-gradient(145deg, #1e1e1e, #2a2a2a); color: white; text-decoration: none; padding: 6px 14px; border-radius: 18px; border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease; font-weight: 600; font-size: 0.85rem;">Vibe 4</a>
        </div></div>
        
        <div class="search-wrap" id="searchWrap">
          <input id="orbSearch" type="search" placeholder="Search projects..." aria-label="Search projects" />
          <button id="orbSearchBtn" type="button">Go</button>
          <select id="themeSelect" class="theme-pill" aria-label="Theme selector">
            <option value="aurora" title="Soft violet, cyan, and pink triad">Aurora</option>
            <option value="neon" title="Hot pink, electric cyan, and citrus gold">Neon</option>
            <option value="sunset" title="Orange, pink, and sky blue">Sunset</option>
            <option value="forest" title="Emerald, lime, and green">Forest</option>
            <option value="ocean" title="Blue, cyan, and violet">Ocean</option>
            <option value="candy" title="Pink, yellow, and cyan">Candy</option>
            <option value="royal" title="Purple, amber, and blue">Royal</option>
            <option value="beige-black" title="Beige neutrals on deep black">Parchment</option>
            <option value="black-red" title="Deep black with crimson highlights">Vampire</option>
            <option value="white-red-black" title="White, red, and near-black triad">Redline</option>
            <option value="purple-green" title="Vibrant purple with emerald accents">Arcane</option>
            <option value="slate-red" title="Cool slate grey with red accents">Slate</option>
          </select>
          <select id="modeSelect" class="theme-pill" aria-label="Interaction mode">
            <option value="auto" title="Auto-tour rotates and previews">Auto</option>
            <option value="manual" title="Drag to spin; tour paused">Manual</option>
          </select>
        </div>
        <div class="search-spacer" id="searchSpacer" aria-hidden="true"></div>
        <!-- quick filters -->
        <div class="filters" id="filters" role="tablist" aria-label="Quick categories">
          <button class="chip active" data-cat="all" role="tab" aria-selected="true">All</button>
          <button class="chip" data-cat="projects" role="tab" aria-selected="false">Projects</button>
          <button class="chip" data-cat="experiments" role="tab" aria-selected="false">Experiments</button>
          <button class="chip" data-cat="tools" role="tab" aria-selected="false">Tools</button>
        </div>
        <!-- onboarding tip -->
        <div class="tip" id="tip" role="note">
          Drag to rotate â€¢ Click to preview â€¢ Enter to search
          <button class="dismiss" id="tipDismiss" type="button" aria-label="Dismiss">Got it</button>
        </div>
        <div class="orbiq-link">
          <a href="https://passghost.github.io/OrbiqWebsite/" target="_blank" rel="noopener">Try Orbiq on your desktop today!</a>
        </div>
      </div>

      <div class="hero-card stage" aria-label="Icon orb interface">
        <div class="orbit-wrap" id="orbit" aria-live="polite">
          <div class="ring" id="ring">
            <div class="ring-bg" id="ringBg"></div>
          </div>
          <div class="target" id="hitTarget" aria-hidden="true"><div class="dot"></div></div>
          
        </div>
        
        </div>
  </div>
    </section>
  </main>

  <!-- Featured strip -->
  <section class="feature-strip" aria-label="Featured projects">
    <header>
      <h3>Featured</h3>
      <button class="shuffle" id="featureShuffle" type="button">Shuffle</button>
    </header>
    <div class="feature-rail" id="featureRail" role="list"></div>
  </section>

  <!-- Panels -->
  <section class="panel" id="panel-projects" role="dialog" aria-modal="true" aria-labelledby="panel-projects-title">
    <header>
      <h3 id="panel-projects-title">Projects</h3>
      <button class="close" data-close>Close</button>
    </header>
    <div class="content">
      <div class="grid">
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/screenshots/CardCake.png" alt="Project screenshot">
          <div class="meta-inline"><h4>Shortcut Sphere</h4><p>A draggable shortcut orb for Windows with hotkey summon and theming.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/Snip/EyeballM3.png" alt="Orbiq Eyeball">
          <div class="meta-inline"><h4>Orbiq Icons</h4><p>Procedural icon set and 3D spin rig with backâ€‘fade.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/rededge.png" alt="Red texture">
          <div class="meta-inline"><h4>Peeks</h4><p>Pygame UI with voice control, RGB sliders, and idle animations.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/SphereIcon.png" alt="Sphere Icon">
          <div class="meta-inline"><h4>Stream Automator</h4><p>Unreal scene pilot with chatâ€‘driven control surfaces.</p></div>
        </article>
      </div>
    </div>
  </section>

  <section class="panel" id="panel-experiments" role="dialog" aria-modal="true" aria-labelledby="panel-experiments-title">
    <header>
      <h3 id="panel-experiments-title">Experiments</h3>
      <button class="close" data-close>Close</button>
    </header>
    <div class="content">
      <div class="grid">
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/rededge.png" alt="Red edge">
          <div class="meta-inline"><h4>Grid Glitch</h4><p>CSS-only aurora lighting with conic gradients.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/Snip/EyeballM3.png" alt="Eyeball">
          <div class="meta-inline"><h4>Edgeâ€‘Aware Pixel Heli</h4><p>Tiny canvas toy that knows its bounds.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/screenshots/CardCake.png" alt="CardCake">
          <div class="meta-inline"><h4>LLM Prompter</h4><p>Inâ€‘browser prompt macros & tokens playground.</p></div>
        </article>
      </div>
    </div>
  </section>

  <section class="panel" id="panel-tools" role="dialog" aria-modal="true" aria-labelledby="panel-tools-title">
    <header>
      <h3 id="panel-tools-title">Tools</h3>
      <button class="close" data-close>Close</button>
    </header>
    <div class="content">
      <div class="grid">
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/rededge.png" alt="Red">
          <div class="meta-inline"><h4>Download</h4><p>Link your latest launcher build here.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/OrbiqWebsite/Images/SphereIcon.png" alt="Sphere">
          <div class="meta-inline"><h4>Docs</h4><p>Quick start, hotkeys, theming, FAQ.</p></div>
        </article>
        <article class="card">
          <img src="https://passghost.github.io/jodylabs/Images/Snip/EyeballM3.png" alt="Eyeball">
          <div class="meta-inline"><h4>Press Kit</h4><p>Logos, screenshots, and a oneâ€‘pager.</p></div>
        </article>
      </div>
    </div>
  </section>

  <section class="panel small" id="panel-contact" role="dialog" aria-modal="true" aria-labelledby="panel-contact-title">
    <header>
      <h3 id="panel-contact-title">Contact</h3>
      <button class="close" data-close aria-label="Close panel">âœ•</button>
    </header>
    <div class="content">
      <div style="display:flex;align-items:center;gap:10px;"> 
        <div style="font-weight:800;font-size:14px;color:var(--text)">pass6host@gmail.com</div>
      </div>
    </div>
  </section>

  <footer class="footer">Â© <span id="year"></span> JodyLabs â€¢ Built with vanilla HTML/CSS/JS.
  </footer>

  <!-- Floating search result card (top-level, positioned by JS) -->
  <div class="search-card-outer" id="searchCardOuter" aria-hidden="true">
    <div class="search-card" id="searchCard">
  <img id="searchCardImg" src="https://passghost.github.io/OrbiqWebsite/Images/SphereIcon.png" alt="result image" />
      <div class="meta">
        <h4 id="searchCardTitle">No result</h4>
        <p id="searchCardDesc">Try searching for a project name or keyword.</p>
        <a id="searchCardLink" href="#" target="_blank" rel="noopener">Open</a>
      </div>
      <div class="mask" aria-hidden="true"></div>
    </div>
  </div>

  <script>
  // ===== THEME SYSTEM =====
  const THEME_KEY = 'v3_theme';
  const MODE_KEY = 'v3_mode';
  const SUPPORTED_THEMES = ['aurora','neon','sunset','forest','ocean','candy','royal','beige-black','black-red','white-red-black','purple-green','slate-red'];
  const DEBUG = false;
  const isValidTheme = (n)=> SUPPORTED_THEMES.includes(String(n||'').toLowerCase());
  function hexToRgb(hex){
    try{
      if(!hex) return null;
      hex = String(hex).trim();
      if(hex.startsWith('rgb')){
        const m = hex.match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
        if(m) return { r: +m[1], g: +m[2], b: +m[3] };
        return null;
      }
      if(hex[0]==='#') hex = hex.slice(1);
      if(hex.length===3) hex = hex.split('').map(c=>c+c).join('');
      const num = parseInt(hex, 16);
      return { r: (num>>16)&255, g: (num>>8)&255, b: num&255 };
    }catch(_){ return null; }
  }
  const rgba = (rgb, a)=> `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
  let themeColors = { c0: 'rgba(255,46,166,.55)', c1: 'rgba(33,230,255,.25)', c2: 'rgba(33,230,255,0)' };
  function updateThemeColors(){
    const styles = getComputedStyle(document.documentElement);
    const a = hexToRgb(styles.getPropertyValue('--accent')) || { r:255,g:46,b:166 };
    const b = hexToRgb(styles.getPropertyValue('--accent-2')) || { r:33,g:230,b:255 };
    themeColors.c0 = rgba(a, 0.55);
    themeColors.c1 = rgba(b, 0.25);
    themeColors.c2 = rgba(b, 0.0);
    // Rebuild particle sprite with new theme colors
    try{ buildParticleSprite(); }catch(_){ }
  }
  function applyTheme(name){
    const n = isValidTheme(name) ? String(name).toLowerCase() : 'beige-black';
    document.documentElement.setAttribute('data-theme', n);
    try{ localStorage.setItem(THEME_KEY, n); }catch(_){ }
    const sel = document.getElementById('themeSelect');
    if(sel) sel.value = n;
    updateThemeColors();
  }
  function initTheme(){
    let saved = null;
    try{ saved = localStorage.getItem(THEME_KEY); }catch(_){ }
    const active = isValidTheme(saved) ? String(saved).toLowerCase() : 'beige-black';
    applyTheme(active);
  }
  initTheme();
  const themeSelect = document.getElementById('themeSelect');
  if(themeSelect){ themeSelect.addEventListener('change', (e)=> applyTheme(e.target.value)); }
  // ===== MODE SYSTEM (Auto vs Manual) =====
  let currentMode = 'auto';
  function applyMode(name){
    currentMode = (String(name||'').toLowerCase() === 'manual') ? 'manual' : 'auto';
    try{ localStorage.setItem(MODE_KEY, currentMode); }catch(_){ }
    const sel = document.getElementById('modeSelect'); if(sel) sel.value = currentMode;
  }
  function initMode(){
    let saved = null; try{ saved = localStorage.getItem(MODE_KEY); }catch(_){ }
    applyMode(saved || 'auto');
  }
  const modeSelect = document.getElementById('modeSelect');
  if(modeSelect){ modeSelect.addEventListener('change', (e)=>{
    applyMode(e.target.value);
    if(currentMode === 'auto'){ resumeTour(); startAutoTour(); }
    else { pauseTour(); if(typeof stopAutoTour==='function') stopAutoTour(); }
  }); }
  // ===== 1) LIVING BACKGROUND (particle flowfield) =====
  const bg = document.getElementById('bg');
  const g = bg.getContext('2d');
  let W, H, dpr, particles, t = 0, mouse = {x:0,y:0, active:false};
  // Cached particle sprite to avoid per-particle gradients every frame
  let particleSprite = null;
  let particleSpriteSize = 24; // logical pixels (scaled by dpr)
  function buildParticleSprite(){
    try{
      const size = Math.max(16, Math.floor(particleSpriteSize));
      const off = document.createElement('canvas');
      const ctx = off.getContext('2d');
      off.width = off.height = Math.max(16, Math.floor(size * (Math.min(2, window.devicePixelRatio || 1))));
      const cx = off.width/2, cy = off.height/2, r = Math.min(cx, cy);
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      grad.addColorStop(0, themeColors.c0);
      grad.addColorStop(0.6, themeColors.c1);
      grad.addColorStop(1, themeColors.c2);
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      particleSprite = off;
    }catch(_){ particleSprite = null; }
  }

  function resize(){
    dpr = Math.min(2, window.devicePixelRatio || 1);
    W = bg.width = innerWidth * dpr;
    H = bg.height = innerHeight * dpr;
    bg.style.width = innerWidth + 'px';
    bg.style.height = innerHeight + 'px';
    initParticles();
  }

  function initParticles(){
    const prefersReduce = (typeof matchMedia!=='undefined') && matchMedia('(prefers-reduced-motion: reduce)').matches;
    const cores = (navigator.hardwareConcurrency || 4);
    const densityBase = prefersReduce ? 46000 : 32000; // higher => fewer
    const perfFactor = cores <= 4 ? 0.8 : (cores >= 8 ? 1.2 : 1.0);
    const count = Math.floor(((W*H) / (densityBase * dpr)) * perfFactor);
    particles = new Array(count).fill().map(()=>({
      x: Math.random()*W,
      y: Math.random()*H,
      v: 0,
      a: 0,
      s: 0.7 + Math.random()*1.1
    }));
  }

  function noise(x,y){
    return Math.sin(x*0.0009 + t*0.002) + Math.cos(y*0.0012 - t*0.002);
  }

  function tick(){
    t+=1;
    g.clearRect(0,0,W,H);

    g.globalCompositeOperation = 'lighter';
    for(const p of particles){
      const n = noise(p.x, p.y);
      const angle = n * Math.PI;
      const force = 0.6;

      p.a += (angle - p.a)*0.08;
      p.v += force * 0.6;

      if(mouse.active){
        const dx = (mouse.x*dpr - p.x), dy = (mouse.y*dpr - p.y);
        const d = Math.hypot(dx,dy) + 0.0001;
        const pull = Math.min(1.5, 40/d);
        p.x += dx * pull * 0.008;
        p.y += dy * pull * 0.008;
      }

      p.x += Math.cos(p.a) * p.v * 0.08;
      p.y += Math.sin(p.a) * p.v * 0.08;
      p.v *= 0.92;

      if(p.x<0) p.x+=W; if(p.x>W) p.x-=W; if(p.y<0) p.y+=H; if(p.y>H) p.y-=H;

      if(particleSprite){
        const sz = Math.max(8, Math.floor(p.s * 18 * dpr));
        const half = sz>>1;
        g.drawImage(particleSprite, (p.x - half)|0, (p.y - half)|0, sz, sz);
      } else {
        // fallback simple circle
        g.fillStyle = themeColors.c0;
        g.beginPath(); g.arc(p.x, p.y, p.s, 0, Math.PI*2); g.fill();
      }
    }
    requestAnimationFrame(tick);
  }

  addEventListener('resize', resize);
  bg.addEventListener('pointermove', e=>{mouse.x=e.clientX;mouse.y=e.clientY});
  bg.addEventListener('pointerdown', ()=>mouse.active=true);
  bg.addEventListener('pointerup', ()=>mouse.active=false);
  buildParticleSprite();
  resize(); tick();

  // Diagnostic hooks (gated)
  if(DEBUG){ document.addEventListener('pointerdown', (e)=>{ try{ console.debug('document.pointerdown', e.type, e.target && (e.target.tagName || e.target.className)); }catch(err){} }); }


  // ===== 2) ICON SPHERE (dynamic from VibeCode2 projects.json) =====
  const ICON_URL = 'https://passghost.github.io/OrbiqWebsite/Images/SphereIcon.png'; // fallback icon

  const ring = document.getElementById('ring');
  const ringBg = document.getElementById('ringBg');
  const orbit = document.getElementById('orbit');

  // default fallback nodes if projects.json can't be loaded
  const DEFAULT_BASE = [
    {label:'Projects', panel:'#panel-projects'},
    {label:'Experiments', panel:'#panel-experiments'},
    {label:'Tools', panel:'#panel-tools'},
    {label:'Contact', panel:'#panel-contact'},
  ];

  let nodes = [];
  let points = [];
  let TOTAL_ICONS = 32;
  let rotX = -0.3, rotY = 0; // free rotation
  let dragging = false, last = {x:0,y:0}, inertia = {x:0,y:0};
  let currentCategory = 'all';
  // tap detection: store pointerdown candidates and synthesize a click on pointerup
  const tapMap = new Map();

  // fetch projects.json and build nodes; fall back to DEFAULT_BASE repeated
  async function loadProjectNodes(){
    try{
      const res = await fetch('../components/projects.json');
      if(res.ok){
        const projects = await res.json();
        if(Array.isArray(projects) && projects.length){
          // resolve any relative resource URLs against the projects.json URL
          const base = res.url || (location.href);
          return projects.map(p=>{
            const resolve = (s)=>{
              try{
                if(!s) return '';
                // If the value is an absolute URL already, return it unchanged
                if(/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(s)) return s;
                // If the value is a root-relative path (starts with '/'), keep it relative to origin
                if(s.startsWith('/')) return location.origin + s;
                // Clean leading ../ or ./ segments
                const cleaned = s.replace(/^(?:\.\/|\.\.\/)+/, '');
                // If this looks like a screenshots path, map to the site screenshots root
                if(/screenshots\//i.test(cleaned) || /screenshots\//i.test(s)){
                  const file = cleaned.split('/').pop();
                  return location.origin + '/jodylabs/screenshots/' + file;
                }
                // Map any other relative hrefs to the site root to avoid embedding VibeCode2 in the path
                return location.origin + '/jodylabs/' + cleaned.replace(/^\//, '');
              }catch(e){ return s || ''; }
            };
            return {
              label: p.title || 'Untitled',
              href: resolve(p.href || '#'),
              icon: resolve(p.icon || ''),
              screenshot: resolve((p.screenshots && p.screenshots[0]) || ''),
              desc: p.desc || ''
            };
          });
        }
      }
    }catch(e){ console.warn('projects.json load failed', e); }
    // fallback: build repeated default nodes
    return Array.from({length:TOTAL_ICONS}, (_,i)=>({ label: DEFAULT_BASE[i % DEFAULT_BASE.length].label, href:'#', icon:'', desc:'' }));
  }

  function buildSpherePoints(){
    points = [];
    const n = TOTAL_ICONS;
    for(let i=0;i<n;i++){
      const k = i + 0.5;
      const phi = Math.acos(1 - 2*k/n);
      const theta = Math.PI * (1 + Math.sqrt(5)) * k;
      const x = Math.cos(theta) * Math.sin(phi);
      const y = Math.cos(phi);
      const z = Math.sin(theta) * Math.sin(phi);
      points.push({x,y,z});
    }
  }

  function buildRing(){
    ring.innerHTML = '<div class="ring-bg" id="ringBg"></div>';
    // create a sibling container to hold the interactive node elements so the decorative
    // `.ring` element doesn't capture hit-testing. Nodes will be appended into this container.
    let nodesWrap = orbit.querySelector('.nodes');
    if(!nodesWrap){
      nodesWrap = document.createElement('div');
      nodesWrap.className = 'nodes';
      nodesWrap.style.position = 'absolute';
      nodesWrap.style.inset = '0';
      nodesWrap.style.pointerEvents = 'auto';
      orbit.appendChild(nodesWrap);
    } else {
      nodesWrap.innerHTML = '';
    }
    for(let i=0;i<TOTAL_ICONS;i++){
      const el = document.createElement('div');
      el.className = 'node';
      el.setAttribute('data-index', i);

  const btn = document.createElement('button');
  btn.setAttribute('type','button');
  btn.setAttribute('aria-label', (nodes[i] && (nodes[i].label||nodes[i].title)) || 'item');
  // ensure the button accepts pointer events and is keyboard-focusable
  btn.style.pointerEvents = btn.style.pointerEvents || 'auto';
  btn.tabIndex = 0;
  const nd = nodes[i] || {};
  // prefer preloaded screenshot if available
  const bgUrl = (nd._preloaded && nd._preloaded.ok && nd._preloaded.src) || nd.screenshot || nd.icon || ICON_URL;
  btn.style.backgroundImage = `url(${bgUrl})`;
      btn.style.backgroundSize = 'cover';
      btn.style.backgroundPosition = 'center';
  const label = document.createElement('span');
    label.className = 'label';
    label.textContent = nd.label || '';
      // clicking opens the projects panel and shows a mini-card for this project
      // ignore single-click if it immediately follows a dblclick
      btn.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        const now = Date.now();
        if(btn.__lastDbl && (now - btn.__lastDbl) < 500) return; // ignore click triggered by dblclick
        // Single-click should behave like a search: focus the orb on this node
        // and show the floating search card as if the user searched for it.
        const idx = i;
        if(typeof idx === 'number' && idx >= 0 && idx < nodes.length){
          console.debug('node click', idx, nodes[idx] && nodes[idx].label);
          // mirror search input so behavior matches running a search
          try{ searchInput.value = nodes[idx].label || ''; }catch(e){}
          focusNodeByIndex(idx);
          updateSearchCard(nodes[idx] || {});
          // position card relative to the search input (same as runSearch)
          positionSearchCard();
          cardMode = 'pinned';
          showSearchCard();
        }
      });
  // tap detection handlers: record pointerdown, and on pointerup determine if this was a tap
  btn.addEventListener('pointerdown', (e)=>{
    e.stopPropagation();
    try{ btn.setPointerCapture && btn.setPointerCapture(e.pointerId); }catch(_){}
    tapMap.set(e.pointerId, { x: e.clientX, y: e.clientY, t: Date.now(), idx: i, btn });
  });
  btn.addEventListener('pointerup', (e)=>{
    e.stopPropagation();
    try{ btn.releasePointerCapture && btn.releasePointerCapture(e.pointerId); }catch(_){}
    const rec = tapMap.get(e.pointerId);
    if(rec){
      tapMap.delete(e.pointerId);
      const dx = e.clientX - rec.x, dy = e.clientY - rec.y;
      const dist = Math.hypot(dx, dy);
      const dt = Date.now() - rec.t;
      // thresholds: small movement and short time -> treat as tap
      if(dist < 8 && dt < 300){
        // mark as handled so native click handler (if fired) won't double-run
        try{ rec.btn.__synthHandled = true; }catch(_){}
        // run the same logic as a click handler
        const idx = rec.idx;
        if(typeof idx === 'number' && idx >= 0 && idx < nodes.length){
          console.debug('node tap', idx, nodes[idx] && nodes[idx].label);
          try{ searchInput.value = nodes[idx].label || ''; }catch(e){}
          focusNodeByIndex(idx);
          updateSearchCard(nodes[idx] || {});
          positionSearchCard();
          cardMode = 'pinned';
          showSearchCard();
        }
      }
    }
  });
  // don't intercept pointerdown here - let the orbit's handlers receive the event so drag works
      // double-clicking shows the floating search/project card near the clicked icon
  btn.addEventListener('dblclick', (ev)=>{
        ev.stopPropagation();
        // mark timestamp so click handler can ignore the click(s) produced by the dblclick
        btn.__lastDbl = Date.now();
  // ensure card content updates for this node
  updateSearchCard(nodes[i] || {});
        // position the fixed popup near the clicked button
        try{
          const r = btn.getBoundingClientRect();
          const centerX = r.left + r.width/2;
          searchCardOuter.style.left = centerX + 'px';
          const h = searchCardOuter.offsetHeight || 180;
          const gap = 12;
          let top = r.top - h - gap;
          if(top < 12) top = r.bottom + gap;
          searchCardOuter.style.top = top + 'px';
        }catch(e){ /* ignore if element not yet present */ }
        cardMode = 'pinned';
        showSearchCard();
      });
      // hover preview: show card for this node
      btn.addEventListener('pointerenter', ()=>{
        updateSearchCard(nodes[i] || {});
        // position near search since the popup is fixed and consistent
        positionSearchCard();
        cardMode = 'hover';
        showSearchCard();
        pauseTour();
      });
      btn.addEventListener('pointerleave', ()=>{
        // Only hide hover previews when the hovered node is NOT the currently-targeted node.
        // This prevents small mouse movements from dismissing a preview for the active/targeted project.
        const nodeEl = btn.closest && btn.closest('.node');
        const isHit = nodeEl ? nodeEl.classList.contains('hit') : false;
        if(cardMode === 'hover' && !isHit){
          hideSearchCard(300);
        }
        nudgeResume(4000);
      });

  el.appendChild(btn);
  // append label after button so flex column centers it underneath
  el.appendChild(label);
  nodesWrap.appendChild(el);
    }
    positionNodes();
  }

    // preload images for nodes and attach a small _preloaded object to each node
    async function preloadNodeImages(list){
      await Promise.all(list.map(async (nd, idx)=>{
        const src = nd.screenshot || nd.icon || '';
        if(!src) return nd._preloaded = { ok: false };
        try{
          await new Promise((resolve, reject)=>{
            const img = new Image(); img.onload = ()=>resolve(img); img.onerror = reject; img.src = src;
          });
          nd._preloaded = { ok: true, src };
        }catch(e){ nd._preloaded = { ok: false }; }
      }));
    }

  // show project details in the Projects panel (single card)
  function showProjectInPanel(nd, anchor){
    nd = nd || {};
    const p = document.querySelector('#panel-projects');
    if(!p) return;
    const grid = p.querySelector('.grid');
    if(!grid) return;
    grid.innerHTML = '';
    const article = document.createElement('article');
    article.className = 'card';
    const img = document.createElement('img');
    img.src = nd.screenshot || nd.icon || ICON_URL;
    img.alt = nd.label || 'project';
    const h4 = document.createElement('h4'); h4.textContent = nd.label || '';
    const pdesc = document.createElement('p'); pdesc.textContent = nd.desc || '';
    const a = document.createElement('a'); a.href = nd.href || '#'; a.textContent = 'Open project'; a.target = '_blank'; a.rel='noopener';
    article.appendChild(img); article.appendChild(h4); article.appendChild(pdesc); article.appendChild(a);
    grid.appendChild(article);
    openPanel('#panel-projects', anchor || document.querySelector('.node'));
  }

  

  function onDown(e){ dragging=true; last.x=e.clientX; last.y=e.clientY; inertia.x=0; inertia.y=0; orbit.setPointerCapture(e.pointerId); }
  function onMove(e){ if(!dragging) return; const dx=e.clientX-last.x, dy=e.clientY-last.y; last.x=e.clientX; last.y=e.clientY; rotY += dx*0.008; rotX += dy*0.008; inertia.x = dx*0.008; inertia.y = dy*0.008; positionNodes(); }
  function onUp(e){ dragging=false; orbit.releasePointerCapture(e.pointerId); }

  orbit.addEventListener('pointerdown', onDown);
  orbit.addEventListener('pointermove', onMove);
  orbit.addEventListener('pointerup', onUp);

  // orbit diagnostic logs (gated)
  if(DEBUG){
    orbit.addEventListener('pointerdown', (e)=>{ try{ console.debug('orbit.pointerdown', e.target && (e.target.tagName || e.target.className)); }catch(err){} });
    orbit.addEventListener('pointerup', (e)=>{ try{ console.debug('orbit.pointerup', e.target && (e.target.tagName || e.target.className)); }catch(err){} });
  }

  // Global pointer tracking to synthesize taps on pointerup using elementFromPoint.
  // This bypasses pointer capture/drag stealing by the orbit container.
  let __lastPointer = { x:0, y:0, t:0 };
  document.addEventListener('pointerdown', (e)=>{ __lastPointer = { x: e.clientX, y: e.clientY, t: Date.now() }; });
  document.addEventListener('pointerup', (e)=>{
    try{
      const dt = Date.now() - (__lastPointer.t || 0);
      const dx = e.clientX - (__lastPointer.x || 0);
      const dy = e.clientY - (__lastPointer.y || 0);
      const dist = Math.hypot(dx, dy);
      // only consider as a tap if small movement and reasonably quick
      if(dist <= 10 && dt < 400){
        const el = document.elementFromPoint(e.clientX, e.clientY);
        // also inspect the full stacking list for richer diagnostics
        if(DEBUG){
          try{
            const stack = document.elementsFromPoint(e.clientX, e.clientY) || [];
            console.debug('elementsFromPoint stack:', stack.slice(0,8).map(x=>({ tag: x.tagName, cls: x.className })));
          }catch(_){ }
        }
        if(!el){ if(DEBUG){ console.debug('elementFromPoint returned null'); } return; }
        // log the element and its classes to help debug hit-testing
        if(DEBUG){ try{ console.debug('elementFromPoint ->', el.tagName, el.className, el); }catch(_){ } }
  const nodeEl = el.closest && el.closest('.node');
  if(nodeEl){
          const idx = parseInt(nodeEl.getAttribute('data-index'), 10);
          if(!isNaN(idx) && nodes[idx]){
            const btn = nodeEl.querySelector('button');
            // avoid double-handling if the button's dblclick logic just ran
            const now = Date.now();
            if(btn && btn.__lastDbl && (now - btn.__lastDbl) < 600) return;
            // mark as synthetic handled so native click won't duplicate
            if(btn) btn.__synthHandled = true;
            if(DEBUG){ console.debug('global tap detected on node', idx, nodes[idx] && nodes[idx].label); }
            try{ searchInput.value = nodes[idx].label || ''; }catch(e){}
            focusNodeByIndex(idx);
            updateSearchCard(nodes[idx] || {});
            positionSearchCard();
            showSearchCard();
          }
          else { if(DEBUG){ try{ console.debug('no .node ancestor found for elementFromPoint result', el.tagName, el.className); }catch(_){ } } }
        }
      }
    }catch(err){ console.warn('pointerup synth error', err); }
  }, { capture: true });

  addEventListener('keydown', (e)=>{
    if(e.key==='ArrowRight') { rotY += 0.2; }
    else if(e.key==='ArrowLeft') { rotY -= 0.2; }
    else if(e.key==='ArrowUp') { rotX -= 0.2; }
    else if(e.key==='ArrowDown') { rotX += 0.2; }
    else if(e.key==='Escape'){ closeAllPanels(); }
    positionNodes();
  });

  function animate(){
  if(!searching){ rotX += (inertia.y *= 0.94) * 0.3; rotY += (inertia.x *= 0.94) * 0.3; }
    positionNodes();
    requestAnimationFrame(animate);
  }

  // initialize orb from projects.json and start animation
  (async function initOrb(){
    const projNodes = await loadProjectNodes();
    nodes = projNodes;
    TOTAL_ICONS = Math.max(8, nodes.length);
    buildSpherePoints();
    buildRing();
    positionNodes();
    animate();
    addEventListener('resize', ()=>{positionNodes()});
    startAutoTour();
  initMode();
    // populate Featured once data is in
    try{ categorizeNodes(); populateFeatured(); }catch(_){ }
    // filter chips
    const filters = document.getElementById('filters');
    if(filters){
      filters.addEventListener('click', (e)=>{
        const btn = e.target.closest('.chip'); if(!btn) return;
        const cat = btn.getAttribute('data-cat');
        setCategory(cat);
      });
    }
    // onboarding tip
    try{
      const k='v3_tip_dismissed';
      const tip = document.getElementById('tip');
      const dis = document.getElementById('tipDismiss');
      if(localStorage.getItem(k)==='1'){ tip && (tip.style.display='none'); }
      if(dis){ dis.addEventListener('click', ()=>{ localStorage.setItem(k,'1'); tip && (tip.style.display='none'); }); }
    }catch(_){ }
  })();

  // ===== SEARCH & FOCUS =====
  const searchInput = document.getElementById('orbSearch');
  const searchBtn = document.getElementById('orbSearchBtn');
  // Track how the search card was opened: 'hover' | 'pinned' | 'tour' | null
  let cardMode = null;

  function findBestNodeMatch(query){
    if(!query) return -1;
    const normalize = str=> (str||'').toLowerCase().replace(/[^a-z0-9\s]/g,' ').replace(/\s+/g,' ').trim();
    const q = normalize(query);
    if(!q) return -1;
    const qTokens = q.split(' ');
    let best = -1, bestScore = -1;
    for(let i=0;i<nodes.length;i++){
      const n = nodes[i] || {};
      const title = normalize(n.label || n.title || '');
      const desc = normalize(n.desc || '');
      const href = normalize(n.href || '');
      const hay = (title + ' ' + desc + ' ' + href).trim();
      if(!hay) continue;
      // exact title match highest
      if(title === q) return i;
      let score = 0;
      // token matches
      for(const tok of qTokens){
        if(title.split(' ').some(w=>w.startsWith(tok))) score += 30; // prefix in title
        else if(title.includes(tok)) score += 18; // anywhere in title
        else if(desc.includes(tok)) score += 6;
        else if(href.includes(tok)) score += 4;
      }
      // small boost for title length proximity
      const lenDiff = Math.abs((title.split(' ').length || 1) - qTokens.length);
      score += Math.max(0, 6 - lenDiff);
      if(score > bestScore){ bestScore = score; best = i; }
    }
    return bestScore >= 6 ? best : -1;
  }

  // analytically compute rotX and rotY so that the rotated point faces right (toward the target)
  function pointToAngles(pt){
    // Solve rotX so that y' = 0: y' = pt.y*cosX - pt.z*sinX => tanX = pt.y/pt.z
    // rotX = atan2(pt.y, pt.z)
    // After rotX, z1 = pt.y*sinX + pt.z*cosX
    // Solve rotY so that z'' = -pt.x*sinY + z1*cosY = 0 => tanY = z1/pt.x => rotY = atan2(z1, pt.x)
    try{
      const rotX_guess = Math.atan2(pt.y, pt.z || 1e-6);
      const sinX = Math.sin(rotX_guess), cosX = Math.cos(rotX_guess);
      const z1 = pt.y * sinX + pt.z * cosX;
      const rotY_guess = Math.atan2(z1, pt.x || 1e-6);
      return { rotX: rotX_guess, rotY: rotY_guess };
    }catch(e){
      return { rotX: rotX, rotY: rotY };
    }
  }

  // project a sphere point to screen coords for a candidate rotation
  function projectToScreen(pt, rx, ry){
    const cosX = Math.cos(rx), sinX = Math.sin(rx);
    const cosY = Math.cos(ry), sinY = Math.sin(ry);
    const y1 = pt.y * cosX - pt.z * sinX;
    const z1 = pt.y * sinX + pt.z * cosX;
    const x2 = pt.x * cosY + z1 * sinY;
    const y2 = y1;
    // compute screen center of orbit
    const bounds = orbit.getBoundingClientRect();
    const R = Math.min(bounds.width, bounds.height) * 0.42;
    const cx = bounds.left + bounds.width/2;
    const cy = bounds.top + bounds.height/2;
    return { x: cx + x2 * R, y: cy + y2 * R };
  }

  // hill-climb refine angles to minimize distance between projected point and target screen coords
  function refineAngles(pt, targetScreen, initial, iters=10){
    let cur = { rotX: initial.rotX, rotY: initial.rotY };
    let step = 0.8;
    let best = { rotX: cur.rotX, rotY: cur.rotY };
    function err(a){ const p = projectToScreen(pt, a.rotX, a.rotY); const dx = p.x - targetScreen.x; const dy = p.y - targetScreen.y; return dx*dx + dy*dy; }
    let bestErr = err(best);
    for(let k=0;k<iters;k++){
      let improved = false;
      for(const dx of [-step,0,step]){
        for(const dy of [-step,0,step]){
          const cand = { rotX: best.rotX + dx, rotY: best.rotY + dy };
          const e = err(cand);
          if(e < bestErr){ bestErr = e; best = cand; improved = true; }
        }
      }
      if(!improved) step *= 0.55; // reduce step
    }
    return best;
  }

  let searchAnim = null;
  let searching = false;
  function animateToAngles(target, duration=700){
    if(searchAnim) cancelAnimationFrame(searchAnim.id);
    // pause inertia and autobrotation influence
    searching = true;
    inertia.x = 0; inertia.y = 0;
    const startX = rotX, startY = rotY;
    const start = performance.now();
    function step(now){
      const t = Math.min(1, (now - start) / duration);
      // easeInOutQuad
      const e = t<.5?2*t*t:-1+(4-2*t)*t;
      rotX = startX + (target.rotX - startX) * e;
      rotY = startY + (target.rotY - startY) * e;
      positionNodes();
      if(t < 1) searchAnim.id = requestAnimationFrame(step);
      else { searching = false; searchAnim = null; }
    }
    searchAnim = {id: requestAnimationFrame(step)};
  }

  function focusNodeByIndex(i){
  if(i < 0 || i >= points.length) return;
  const pt = points[i];
  // desired target: current hitTarget center (use its current DOM position as the goal)
  const targetEl = document.getElementById('hitTarget');
  const targRect = targetEl.getBoundingClientRect();
  // nudge target slightly downward so the icon settles a bit lower visually
  const SEARCH_Y_OFFSET = 20; // pixels (raised by 10px as requested)
  const targetScreen = { x: targRect.left + targRect.width/2, y: targRect.top + targRect.height/2 + SEARCH_Y_OFFSET };
  // initial analytic guess
  const init = pointToAngles(pt);
  // refine numerically against the actual target screen coords
  const refined = refineAngles(pt, targetScreen, init, 12);
  animateToAngles(refined, 900);
  }

  function runSearch(){
    const q = searchInput.value || '';
    const idx = findBestNodeMatch(q);
    if(idx >= 0){
      focusNodeByIndex(idx);
      // update and show the floating card above the search box
      updateSearchCard(nodes[idx]);
      cardMode = 'pinned';
      showSearchCard();
      // If the matched node has a usable href, open it in a new tab.
      try{
        const href = nodes[idx] && nodes[idx].href;
        if(href && href !== '#' && href.trim() !== ''){
          window.open(href, '_blank', 'noopener');
        }
      }catch(_){ }
    } else {
      // no match: show friendly hint then hide
      updateSearchCard(null);
      hideSearchCard(1200);
    }
  }

  searchBtn.addEventListener('click', runSearch);
  searchInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') runSearch(); });

  // ===== SEARCH CARD UI =====
  const searchCardOuter = document.getElementById('searchCardOuter');
  const searchCardImg = document.getElementById('searchCardImg');
  const searchCardTitle = document.getElementById('searchCardTitle');
  const searchCardDesc = document.getElementById('searchCardDesc');
  const searchCardLink = document.getElementById('searchCardLink');
  let hideCardTimer = null;

  function showSearchCard(){
    if(hideCardTimer){ clearTimeout(hideCardTimer); hideCardTimer = null; }
  // show first so measurements include visibility
  searchCardOuter.classList.add('show');
  searchCardOuter.setAttribute('aria-hidden','false');
  // animate eraser up to reveal the floating card
  const eraser = document.getElementById('eraser'); if(eraser) eraser.classList.add('active');
  const wrap = document.getElementById('searchWrap'); if(wrap) wrap.classList.add('pushed');
  const spacer = document.getElementById('searchSpacer'); if(spacer){ spacer.style.height = getComputedStyle(document.documentElement).getPropertyValue('--eraser-lift') || '120px'; }
  // initial position
  positionSearchCard();
  // re-position on the next frames so transformed rects are current
  requestAnimationFrame(()=>{ positionSearchCard(); requestAnimationFrame(positionSearchCard); });
  }
  function hideSearchCard(delay=0){
    if(hideCardTimer) clearTimeout(hideCardTimer);
    if(delay>0){ hideCardTimer = setTimeout(()=>{ searchCardOuter.classList.remove('show'); searchCardOuter.setAttribute('aria-hidden','true'); }, delay); }
    else { searchCardOuter.classList.remove('show'); searchCardOuter.setAttribute('aria-hidden','true'); }
  // restore eraser when card is hidden
  const eraser = document.getElementById('eraser'); if(eraser) eraser.classList.remove('active');
  const wrap = document.getElementById('searchWrap'); if(wrap) wrap.classList.remove('pushed');
  const spacer = document.getElementById('searchSpacer'); if(spacer){ spacer.style.height = '0px'; }
  cardMode = null;
  }

  function updateSearchCard(nd){
    if(!nd){
      searchCardImg.src = ICON_URL;
      searchCardTitle.textContent = 'No results';
      searchCardDesc.textContent = 'No matching project found. Try a different keyword.';
      searchCardLink.href = '#';
      searchCardLink.textContent = 'Browse projects';
  // ensure popup repositions even for the empty state
  positionSearchCard();
  return;
    }
    searchCardImg.src = nd.screenshot || nd.icon || ICON_URL;
    searchCardTitle.textContent = nd.label || 'Untitled';
    searchCardDesc.textContent = nd.desc || '';
    searchCardLink.href = nd.href || '#';
    searchCardLink.textContent = nd.href ? 'Open project' : 'More';
    // position the card centered above the search input (fixed popup needs explicit coords)
    positionSearchCard();
    // small reveal animation (mask is transparent)
    const mask = document.querySelector('#searchCard .mask');
    if(mask){ mask.animate([{ transform: 'scaleY(1)' }, { transform: 'scaleY(0)' }], { duration: 420, easing: 'cubic-bezier(.2,.9,.2,1)' }); }
  }

  // Position the fixed popup centered above the search input
  function positionSearchCard(){
    if(!searchCardOuter) return;
    const wrap = document.getElementById('searchWrap');
    if(!wrap) return;
    const rect = wrap.getBoundingClientRect();
    // Prefer to center horizontally inside the left column (where the headline and search live).
    const wrapCenter = rect.left + rect.width / 2;
    const leftCol = document.querySelector('.left-col');
    const leftRect = leftCol ? leftCol.getBoundingClientRect() : null;
    const eraser = document.getElementById('eraser') || document.querySelector('.eraser');
    const eraserRect = eraser ? eraser.getBoundingClientRect() : null;
    let centerX = wrapCenter;
    if(leftRect){
      // center inside the left-column to place the card visually between text and input
      centerX = Math.round(leftRect.left + leftRect.width / 2);
    } else if(eraserRect){
      // fallback: bias slightly toward the wording so the card sits nearer the text
      const eraserEdge = eraserRect.right;
      const bias = 0.4; // 0..1 where 0.0 => nearer search input, 1.0 => nearer wording
      centerX = Math.round(eraserEdge * (1 - bias) + wrapCenter * bias);
    }
    searchCardOuter.style.left = centerX + 'px';

    // measure height (element exists in DOM even when opacity:0)
    const h = searchCardOuter.offsetHeight || 180;
    const gap = 12;
    // compute a vertical position between the bottom of the eraser and the top of the search input
    let top = rect.top - h - gap;
    if(eraserRect){
      // prefer the midpoint between eraser bottom and input top
      top = Math.round((eraserRect.bottom + rect.top) / 2 - h / 2);
    }
    // clamp below the topbar so it doesn't overlap the fixed topbar
    const topbar = document.querySelector('.topbar');
    const topbarRect = topbar ? topbar.getBoundingClientRect() : null;
    const minTop = topbarRect ? Math.round(topbarRect.bottom + 8) : 12;
    const maxTop = Math.max(minTop, window.innerHeight - h - 12);
    if(top < minTop) top = minTop;
    if(top > maxTop) top = maxTop;
    if(top + h > window.innerHeight - 12) top = Math.max(minTop, rect.bottom + gap);
    searchCardOuter.style.top = top + 'px';
  }

  // reposition on resize/scroll so the popup stays aligned
  window.addEventListener('resize', positionSearchCard);
  document.addEventListener('scroll', positionSearchCard, true);

  // hide card when clicking outside search area
  document.addEventListener('click', (e)=>{
    // clicks inside any open panel should also hide to prevent overlap
    const anyPanel = e.target.closest && e.target.closest('.panel.open');
    if(anyPanel){ hideSearchCard(0); return; }
    // don't hide if clicking inside the search card itself
    if(e.target.closest && e.target.closest('#searchCardOuter')) return;
    // ignore clicks within the searchWrap area
    if(document.getElementById('searchWrap').contains(e.target)) return;
    // if pinned, don't auto-hide on outside clicks; user can hover away or close panel
    if(cardMode === 'pinned') return;
    hideSearchCard(250);
  });

  // ===== FEATURED STRIP =====
  function sampleThree(arr){
    const pool = (arr||[]).filter(n=> (n.screenshot||n.icon) && (n.href||'').trim());
    if(pool.length <= 3) return pool.slice();
    const picked = new Set();
    while(picked.size < 3){ picked.add(Math.floor(Math.random()*pool.length)); }
    return Array.from(picked).map(i=>pool[i]);
  }
  function featureCardHTML(n){
    const img = (n._preloaded && n._preloaded.ok && n._preloaded.src) || n.screenshot || n.icon || ICON_URL;
    const title = n.label || 'Untitled';
    const desc = n.desc || '';
    const href = n.href || '#';
    return `
      <article class="feature-card" role="listitem">
        <img src="${img}" alt="${title}" />
        <div class="meta">
          <h4>${title}</h4>
          <p>${desc}</p>
          <a href="${href}" target="_blank" rel="noopener">Open</a>
        </div>
      </article>`;
  }
  function populateFeatured(){
    const rail = document.getElementById('featureRail'); if(!rail) return;
    const picks = sampleThree(nodes);
    rail.innerHTML = picks.map(featureCardHTML).join('');
    // clicking a card also focuses that node if present
    Array.from(rail.querySelectorAll('.feature-card')).forEach((card, idx)=>{
      const n = picks[idx];
      card.style.cursor = 'pointer';
      card.addEventListener('click', ()=>{
        const i = nodes.findIndex(x=> (x.label||'') === (n.label||''));
        if(i>=0){ focusNodeByIndex(i); updateSearchCard(nodes[i]); cardMode = 'pinned'; showSearchCard(); }
      });
      card.tabIndex = 0;
      card.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); card.click(); } });
    });
  }
  const featureShuffle = document.getElementById('featureShuffle');
  if(featureShuffle){ featureShuffle.addEventListener('click', ()=>{ try{ populateFeatured(); }catch(_){ } }); }

  // ===== AUTO TOUR =====
  let tourTimer = null;
  let tourIdx = 0;
  let tourPaused = false;
  function nextTourStep(){
    if(tourPaused || searching) return;
    if(!nodes || !nodes.length) return;
    tourIdx = (tourIdx + 1) % nodes.length;
    focusNodeByIndex(tourIdx);
    // update floating card for the current node without stealing focus
  updateSearchCard(nodes[tourIdx]);
  cardMode = 'tour';
  showSearchCard();
  // Stabilize position after focus animation alters layout
  setTimeout(positionSearchCard, 0);
  setTimeout(positionSearchCard, 250);
  }
  function startAutoTour(){
    if(tourTimer) clearInterval(tourTimer);
    tourTimer = setInterval(nextTourStep, 6000);
  }
  function stopAutoTour(){ if(tourTimer){ clearInterval(tourTimer); tourTimer = null; } }
  function pauseTour(){ tourPaused = true; }
  function resumeTour(){ tourPaused = false; }
  // pause while the user interacts; resume after a period of inactivity
  let resumeHandle = null;
  function nudgeResume(delay=5000){
    if(resumeHandle) clearTimeout(resumeHandle);
    resumeHandle = setTimeout(()=>{ resumeTour(); }, delay);
  }
  orbit.addEventListener('pointerdown', ()=>{ if(currentMode==='auto'){ pauseTour(); nudgeResume(7000); } });
  orbit.addEventListener('pointerenter', ()=>{ pauseTour(); });
  orbit.addEventListener('pointerleave', ()=>{ nudgeResume(4000); });
  searchInput.addEventListener('focus', ()=>{ pauseTour(); });
  searchInput.addEventListener('input', ()=>{ pauseTour(); nudgeResume(8000); });
  document.addEventListener('keydown', ()=>{ pauseTour(); nudgeResume(6000); });
  function rotateVec(v){
    // rotate around X then Y
    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    let y = v.y * cosX - v.z * sinX;
    let z = v.y * sinX + v.z * cosX;
    let x = v.x * cosY + z * sinY;
    z = -v.x * sinY + z * cosY;
    return {x,y,z};
  }

  function positionNodes(){
    const nodesWrap = orbit.querySelector('.nodes');
    const children = nodesWrap ? Array.from(nodesWrap.querySelectorAll('.node')) : Array.from(ring.querySelectorAll('.node'));
    const bounds = orbit.getBoundingClientRect();
    const R = Math.min(bounds.width, bounds.height) * 0.42;

    let hitIdx = -1, hitScore = 0;

    children.forEach((el, i)=>{
  const pt = points[i];
      if(!pt) return;
      const v = rotateVec(pt);
      const x = v.x * R, y = v.y * R, z = v.z * R;
      el.style.transform = `translate3d(calc(-50% + ${x}px), calc(-50% + ${y}px), ${z}px)`;
      el.style.zIndex = 1000 + Math.round(z);
      const scale = 0.65 + 0.35 * ((z + R) / (2*R));
      const btn = el.querySelector('button');
      if(btn) btn.style.transform = `scale(${scale.toFixed(3)})`;
      const frontness = Math.max(0, (v.z + 1) / 2);
      el.style.opacity = 0.3 + 0.7 * ((z + R) / (2*R));
      // dim nodes on the back half of the sphere
  if(v.z < 0) el.classList.add('dim'); else el.classList.remove('dim');
  // category filter: mark nodes that don't match as filtered
  const n = nodes[i] || {};
  const catOk = (currentCategory==='all') || (Array.isArray(n._cats) && n._cats.includes(currentCategory));
  if(catOk) el.classList.remove('filtered'); else el.classList.add('filtered');

      // target on the right: prefer x close to +R and front-facing (z>0)
      const rightness = Math.max(0, (v.x + 1) / 2); // 0..1, 1 is far right
      const s = Math.pow(rightness, 3) * frontness; // sharpen rightness
      if(s > hitScore){ hitScore = s; hitIdx = i; }
    });

    children.forEach(c=>c.classList.remove('hit'));
    const bgEl = document.getElementById('ringBg');
    if(hitIdx !== -1 && hitScore > 0.5){
      const active = nodes[hitIdx] || {};
      children[hitIdx].classList.add('hit');
      const bgUrl = (active._preloaded && active._preloaded.ok && active._preloaded.src) || active.screenshot || active.icon || ICON_URL;
      bgEl.style.backgroundImage = `url(${bgUrl})`;
      bgEl.classList.add('show');
    } else {
      bgEl.classList.remove('show');
    }
  }

  function onDown(e){ if(currentMode!=='manual') return; dragging=true; last.x=e.clientX; last.y=e.clientY; inertia.x=0; inertia.y=0; try{ orbit.setPointerCapture && orbit.setPointerCapture(e.pointerId); }catch(_){ } }
  function onMove(e){ if(!dragging) return; const dx=e.clientX-last.x, dy=e.clientY-last.y; last.x=e.clientX; last.y=e.clientY; rotY += dx*0.008; rotX += dy*0.008; inertia.x = dx*0.008; inertia.y = dy*0.008; positionNodes(); }
  function onUp(e){ dragging=false; orbit.releasePointerCapture(e.pointerId); }

  orbit.addEventListener('pointerdown', onDown);
  orbit.addEventListener('pointermove', onMove);
  orbit.addEventListener('pointerup', onUp);

  addEventListener('keydown', (e)=>{
    if(e.key==='ArrowRight') { rotY += 0.2; }
    else if(e.key==='ArrowLeft') { rotY -= 0.2; }
    else if(e.key==='ArrowUp') { rotX -= 0.2; }
    else if(e.key==='ArrowDown') { rotX += 0.2; }
    else if(e.key==='Escape'){ closeAllPanels(); }
    positionNodes();
  });

  function animate(){
    rotX += (inertia.y *= 0.94) * 0.3;
    rotY += (inertia.x *= 0.94) * 0.3;
    positionNodes();
    requestAnimationFrame(animate);
  }

  // initOrb bootstraps nodes, points, and starts animation. Duplicate boot calls removed.
  addEventListener('resize', ()=>{positionNodes()});

  // categorize nodes heuristically
  function categorizeNodes(){
    const has = (s, k)=> (s||'').toLowerCase().includes(k);
    nodes.forEach(n=>{
      const hay = `${n.label||''} ${n.desc||''} ${n.href||''}`.toLowerCase();
      const cats = new Set();
      if(/tool|download|docs|press|kit|utility|helper|api|library/.test(hay)) cats.add('tools');
      if(/experiment|demo|toy|glitch|prototype|lab|visual|shader/.test(hay)) cats.add('experiments');
      if(/project|app|game|site|portfolio|showcase|build|shortcut/.test(hay)) cats.add('projects');
      if(cats.size===0) cats.add('projects');
      n._cats = Array.from(cats);
    });
  }

  function setCategory(cat){
    currentCategory = cat || 'all';
    // update chip UI
    document.querySelectorAll('#filters .chip').forEach(ch=>{
      const is = ch.getAttribute('data-cat')===currentCategory;
      ch.classList.toggle('active', is);
      ch.setAttribute('aria-selected', String(is));
    });
    positionNodes();
  }

  // ===== 3) PANELS =====
  const panels = document.querySelectorAll('.panel');

  function openPanel(selector, anchor){
    const p = document.querySelector(selector);
    const rect = anchor.getBoundingClientRect();
    p.style.setProperty('--x', ((rect.left + rect.width/2) / innerWidth * 100).toFixed(2) + '%');
    p.style.setProperty('--y', ((rect.top + rect.height/2) / innerHeight * 100).toFixed(2) + '%');
    p.classList.add('open');
    // avoid overlapping surfaces
    hideSearchCard(0);
    pauseTour();
  }
  function closeAllPanels(){ panels.forEach(p=>p.classList.remove('open')); }
  document.querySelectorAll('[data-close]').forEach(btn=>btn.addEventListener('click', ()=>{ closeAllPanels(); nudgeResume(1500); }));
  document.getElementById('contactOpen').addEventListener('click', ()=>openPanel('#panel-contact', document.querySelector('.cta')));

  // ===== 4) Misc =====
  document.getElementById('year').textContent = new Date().getFullYear();
  </script>
  <script src="../js/hitcounter.js"></script>
  <script>
    (function(){
      if(window.recordHitRpc){
        try{ recordHitRpc('Vibe3', 'hit-count-pill', 5); }catch(e){ console.warn('recordHitRpc call failed', e); }
        return;
      }
      // Inline fallback: call id-based RPC directly
      (async function(){
        const metaUrl = document.querySelector('meta[name="supabase-url"]');
        const metaKey = document.querySelector('meta[name="supabase-anon-key"]');
        const apiUrl = metaUrl ? metaUrl.content.trim() : '';
        const anonKey = metaKey ? metaKey.content.trim() : '';
        const el = document.getElementById('hit-count-pill');
        if(!el) return;
        if(!apiUrl || !anonKey){ el.textContent = '---'; return; }
        try{
          const resp = await fetch(apiUrl.replace(/\/$/, '') + '/rest/v1/rpc/increment_page_hit_by_id', {
            method: 'POST',
            headers: { 'apikey': anonKey, 'Authorization': 'Bearer ' + anonKey, 'Content-Type': 'application/json' },
            body: JSON.stringify({ p_id: 5 })
          });
          if(!resp.ok){ el.textContent = '---'; return; }
          const data = await resp.json();
          const rec = Array.isArray(data) ? data[0] : data;
          const n = rec && (rec.hit_count ?? rec.count ?? rec.total ?? rec.value);
          el.textContent = (typeof n === 'number' || (typeof n === 'string' && n)) ? Number(String(n)).toLocaleString() : '---';
        }catch(e){ console.error('hit RPC error', e); el.textContent = '---'; }
      })();
    })();
  </script>
</body>
</html>

