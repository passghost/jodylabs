<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeonPang - AI Pong Game with Glowing Effects | JodyLabs</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Play NeonPang, a vibrant neon-styled Pong game with AI opponent and spectacular glowing effects! Classic arcade gameplay with modern visuals and challenging AI.">
    <meta name="keywords" content="NeonPang, neon pong, AI pong game, arcade game, classic games, retro games, glow effects, browser game, HTML5 game">
    <meta name="author" content="JodyLabs">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="NeonPang - AI Pong Game with Glowing Effects">
    <meta property="og:description" content="🏓 Experience classic Pong with a futuristic twist! Battle an intelligent AI opponent in this neon-glowing arcade masterpiece. Play free in your browser!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jodylabs.surge.sh/NeonPang/NeonPang.html">
    <meta property="og:site_name" content="JodyLabs">
    <meta property="og:image" content="https://jodylabs.surge.sh/Images/neonpang-preview.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="NeonPang Game - Glowing Pong with AI opponent">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@jodylabs">
    <meta name="twitter:title" content="NeonPang - AI Pong Game with Glowing Effects">
    <meta name="twitter:description" content="🏓 Classic Pong meets futuristic neon! Battle an AI opponent in this glowing arcade game. Free to play in your browser!">
    <meta name="twitter:image" content="https://jodylabs.surge.sh/Images/neonpang-preview.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://jodylabs.surge.sh/NeonPang/NeonPang.html">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "NeonPang",
      "description": "A vibrant neon-styled Pong game featuring an intelligent AI opponent and spectacular glowing visual effects",
      "url": "https://jodylabs.surge.sh/NeonPang/NeonPang.html",
      "author": {
        "@type": "Organization",
        "name": "JodyLabs"
      },
      "genre": ["Arcade", "Sports", "Action"],
      "playMode": "SinglePlayer",
      "applicationCategory": "Game",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>
    <style>
        @font-face {
            font-family: 'Line1';
            src: url('/fonts/Line1.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Bravo';
            src: url('/fonts/bravo.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Orbitron';
            src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        }
        body {
            background: linear-gradient(135deg, #1a0000 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Orbitron', 'Line1', sans-serif;
        }
        canvas {
            border: 2px solid #ff2222;
            position: relative;
            box-shadow: 0 0 24px #ff2222, 0 0 48px #1a0000;
            background: #0a0000;
        }
        canvas::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 2px solid #ff2222;
            pointer-events: none;
        }
        h1 {
            color: #ff2222;
            text-shadow: 0 0 20px #ff2222, 0 0 40px #ff0000, 0 0 60px #1a0000;
            margin-bottom: 20px;
            font-size: 48px;
            padding: 10px;
            letter-spacing: 0.12em;
            font-family: 'Orbitron', 'Bravo', sans-serif;
        }
        label {
            color: #ff2222;
            font-family: 'Orbitron', 'Bravo', sans-serif;
            font-size: 1.1em;
            margin-right: 8px;
        }
        select {
            background: #1a0000;
            color: #ff2222;
            border: 1px solid #ff2222;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 1em;
            font-family: 'Orbitron', 'Bravo', sans-serif;
        }
        .debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ff2222;
            font-family: 'Orbitron', 'Bravo', sans-serif;
            background: rgba(20,0,0,0.7);
            border: 1px solid #ff2222;
            border-radius: 6px;
            padding: 6px 12px;
        }
    </style>
</head>
<body>
    <h1>Neon Pang</h1>
    <div style="margin-bottom:18px;">
        <label for="difficulty">Difficulty:</label>
        <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
        </select>
    </div>
    <script src="powerups.js"></script>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="debug" id="debugInfo"></div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const debugInfo = document.getElementById('debugInfo');

        // --- Difficulty Settings ---
        const difficultySettings = {
            easy:   { aiSpeed: 2, ballSpeed: 4 },
            normal: { aiSpeed: 4, ballSpeed: 6 },
            hard:   { aiSpeed: 7, ballSpeed: 9 }
        };
        let currentDifficulty = 'normal';

        // Set difficulty from dropdown
        const difficultySelect = document.getElementById('difficulty');
        difficultySelect.addEventListener('change', (e) => {
            currentDifficulty = e.target.value;
            // Set AI and ball speed
            aiPaddle.baseSpeed = difficultySettings[currentDifficulty].aiSpeed;
            balls.forEach(ball => {
                const signX = Math.sign(ball.dx) || 1;
                const signY = Math.sign(ball.dy) || 1;
                ball.dx = signX * difficultySettings[currentDifficulty].ballSpeed;
                ball.dy = signY * difficultySettings[currentDifficulty].ballSpeed;
            });
        });

        // Game variables
        const paddleWidth = 20; // Fattened paddles
        const paddleHeight = 100;
        const ballSize = 20; // Increased ball size
        let playerScore = 0;
        let aiScore = 0;
        let playerHits = 0;
        let aiHits = 0;
        const balls = [];
        const powerups = [];
        let lastTime = 0;
        let fps = 0;
        let fireworks = [];

        // Player paddle
        const playerPaddle = {
            x: 10,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            dy: 0
        };

        // AI paddle
        const aiPaddle = {
            x: canvas.width - paddleWidth - 10,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            dy: 0,
            baseSpeed: difficultySettings[currentDifficulty].aiSpeed // Base speed for AI paddle
        };

        // Ball
        function createBall(x, y, dx, dy, color) {
            // Use current difficulty for speed
            const baseSpeed = difficultySettings[currentDifficulty].ballSpeed;
            const signX = Math.sign(dx) || 1;
            const signY = Math.sign(dy) || 1;
            return { x, y, size: ballSize, dx: signX * baseSpeed, dy: signY * baseSpeed, color, particles: [] };
        }

        balls.push(createBall(canvas.width / 2, canvas.height / 2, 6, 6, '#ff00ff'));

        // Powerup
        function createPowerup(x, y, radius, dx, dy, color) {
            return { x, y, radius, dx, dy, color };
        }

        powerups.push(createPowerup(200, 150, 15, 2, 2, '#ff0000')); // Red circular powerup

        // Firework
        function createFirework(x, y) {
            const particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x,
                    y,
                    dx: (Math.random() - 0.5) * 6,
                    dy: (Math.random() - 0.5) * 6,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`, // Multicolor
                    alpha: 1
                });
            }
            return particles;
        }

        // --- Powerup Management ---
        let activePowerups = [];
        let powerupRespawnTimeout = null;
        function spawnPowerup() {
            activePowerups.push(spawnRandomFloatingPowerup(canvas.width, canvas.height));
        }
        function removePowerup(index) {
            activePowerups.splice(index, 1);
            // Spawn a new powerup immediately
            spawnPowerup();
        }
        // Initial spawn
        spawnPowerup();

        // Draw powerups as 3D glass buttons with color (using reliable rgba)
        function hexToRgba(hex, alpha) {
            // Accepts #RRGGBB or #RGB
            let r = 0, g = 0, b = 0;
            if (hex.length === 7) {
                r = parseInt(hex.slice(1, 3), 16);
                g = parseInt(hex.slice(3, 5), 16);
                b = parseInt(hex.slice(5, 7), 16);
            } else if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            return `rgba(${r},${g},${b},${alpha})`;
        }
        function drawActivePowerups() {
            activePowerups.forEach(p => {
                ctx.save();
                // Outer colored shadow
                ctx.shadowBlur = 18;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = hexToRgba(p.color, 0.22); // colored glow
                ctx.fill();
                ctx.shadowBlur = 0;
                // Main glass body with color
                const grad = ctx.createRadialGradient(p.x, p.y, p.radius * 0.2, p.x, p.y, p.radius);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.25, hexToRgba(p.color, 0.85));
                grad.addColorStop(0.7, p.color);
                grad.addColorStop(1, '#222');
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * 0.95, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
                // Glass highlight
                ctx.globalAlpha = 0.45;
                ctx.beginPath();
                ctx.ellipse(p.x, p.y - p.radius * 0.4, p.radius * 0.6, p.radius * 0.22, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        // Update powerup positions
        function updateActivePowerups() {
            activePowerups.forEach(p => {
                p.x += p.dx;
                p.y += p.dy;
                if (p.x < p.radius || p.x > canvas.width - p.radius) p.dx *= -1;
                if (p.y < p.radius || p.y > canvas.height - p.radius) p.dy *= -1;
            });
        }

        // Ball-powerup collision
        function checkPowerupCollisions() {
            activePowerups.forEach((p, i) => {
                balls.forEach(ball => {
                    const dist = Math.hypot(ball.x + ball.size/2 - p.x, ball.y + ball.size/2 - p.y);
                    if (dist < p.radius + ball.size/2) {
                        NeonPangPowerups.applyPowerup(p.name, { balls, playerPaddle, aiPaddle, inverted, invertTimeout });
                        removePowerup(i);
                    }
                });
            });
        }

        // Draw paddles as glass (no animation)
        function drawPaddle(paddle) {
            // Neon glass effect: colored glow, gradient, and highlight
            ctx.save();
            // Choose color based on paddle (left = player, right = AI)
            let neonColor = paddle.x < canvas.width / 2 ? '#ff22ee' : '#22eaff';
            // Outer glow
            ctx.shadowBlur = 24;
            ctx.shadowColor = neonColor;
            // Gradient body
            let grad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x + paddle.width, paddle.y + paddle.height);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.2, neonColor);
            grad.addColorStop(0.8, '#111');
            grad.addColorStop(1, '#000');
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 10);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            // Glass highlight
            ctx.beginPath();
            ctx.moveTo(paddle.x + paddle.width * 0.2, paddle.y + paddle.height * 0.15);
            ctx.lineTo(paddle.x + paddle.width * 0.8, paddle.y + paddle.height * 0.15);
            ctx.lineTo(paddle.x + paddle.width * 0.6, paddle.y + paddle.height * 0.35);
            ctx.lineTo(paddle.x + paddle.width * 0.4, paddle.y + paddle.height * 0.35);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255,255,255,0.33)';
            ctx.fill();
            ctx.restore();
        }

        // Draw ball with gradient and particles
        function drawBall(ball) {
            const gradient = ctx.createRadialGradient(ball.x + ball.size / 2, ball.y + ball.size / 2, ball.size / 4, ball.x + ball.size / 2, ball.y + ball.size / 2, ball.size / 2);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(1, ball.color);
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = ball.color;
            ctx.fillRect(ball.x, ball.y, ball.size, ball.size);

            // Particle effect
            ball.particles.push({ x: ball.x + ball.size / 2, y: ball.y + ball.size / 2, alpha: 1 });
            ball.particles.forEach((particle, index) => {
                ctx.fillStyle = `rgba(255, 255, 255, ${particle.alpha})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                ctx.fill();
                particle.alpha -= 0.1; // Reduced lifetime more
                if (particle.alpha <= 0) {
                    ball.particles.splice(index, 1);
                }
            });
        }

        // Draw powerup with slow and random flicker
        function drawPowerup(powerup) {
            const gradient = ctx.createRadialGradient(powerup.x, powerup.y, powerup.radius / 2, powerup.x, powerup.y, powerup.radius);
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(1, '#ffff00');
            ctx.fillStyle = gradient;
            ctx.shadowBlur = Math.random() * 10; // Slow and random flicker
            ctx.shadowColor = powerup.color;
            ctx.beginPath();
            ctx.arc(powerup.x, powerup.y, powerup.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw score with stylization
        function drawScore() {
            ctx.font = '32px Bravo';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            ctx.fillText(`Player: ${playerScore}`, 20, 40);
            ctx.fillText(`AI: ${aiScore}`, canvas.width - 100, 40);
        }

        // Draw fireworks
        function drawFireworks() {
            fireworks.forEach((firework, index) => {
                firework.forEach((particle, particleIndex) => {
                    ctx.fillStyle = `rgba(${particle.color}, ${particle.alpha})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2); // Bigger fireworks
                    ctx.fill();
                    particle.x += particle.dx;
                    particle.y += particle.dy;
                    particle.alpha -= 0.02;
                    if (particle.alpha <= 0) {
                        firework.splice(particleIndex, 1);
                    }
                });
                if (firework.length === 0) {
                    fireworks.splice(index, 1);
                }
            });
        }

               // Print debug coordinates, hits, and FPS
        function printDebug() {
            debugInfo.innerHTML = '';
            balls.forEach((ball, index) => {
                debugInfo.innerHTML += `Ball ${index + 1}: (${ball.x.toFixed(1)}, ${ball.y.toFixed(1)})<br>`;
            });
            debugInfo.innerHTML += `Player Hits: ${playerHits}<br>`;
            debugInfo.innerHTML += `AI Hits: ${aiHits}<br>`;
            debugInfo.innerHTML += `FPS: ${fps.toFixed(1)}<br>`;
        }

        // --- Invert Controls State ---
        let inverted = false;
        let invertTimeout = null;

        // --- AI Skill Variability ---
        let aiSkillMode = 'normal'; // 'normal', 'good', 'bad'
        let aiSkillTimer = 0;
        function updateAISkill() {
            if (aiSkillTimer <= 0) {
                const rand = Math.random();
                if (rand < 0.1) aiSkillMode = 'bad'; // 10% chance
                else if (rand < 0.3) aiSkillMode = 'normal'; // 20% chance
                else aiSkillMode = 'good'; // 70% chance (fast most of the time)
                aiSkillTimer = Math.random() * 400 + 200; // Change every 200-600 frames
            } else {
                aiSkillTimer--;
            }
        }

        // Update game objects
        function update(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            fps = 1000 / deltaTime;
            lastTime = timestamp;

            // Move player paddle
            playerPaddle.y += playerPaddle.dy;

            // Move balls
            balls.forEach((ball, index) => {
                ball.x += ball.dx;
                ball.y += ball.dy;

                // Ball collision with top and bottom walls
                if (ball.y <= 0 || ball.y + ball.size >= canvas.height) {
                    ball.dy *= -1;
                }

                // Ball collision with paddles
                // Player paddle collision with angle logic
                if (ball.x <= playerPaddle.x + playerPaddle.width && ball.y + ball.size >= playerPaddle.y && ball.y <= playerPaddle.y + playerPaddle.height) {
                    // Calculate hit position (from -1 at top to 1 at bottom)
                    let rel = ((ball.y + ball.size/2) - (playerPaddle.y + playerPaddle.height/2)) / (playerPaddle.height/2);
                    // Clamp rel to [-1, 1]
                    rel = Math.max(-1, Math.min(1, rel));
                    // Reflect X and set Y based on hit position
                    let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                    let angle = rel * Math.PI/3; // up to 60 degrees
                    ball.dx = Math.abs(speed * Math.cos(angle));
                    ball.dy = speed * Math.sin(angle);
                    // Change ball color to match player paddle
                    ball.color = '#ff22ee';
                    playerHits++;
                }

                // AI paddle collision with angle logic
                if (ball.x + ball.size >= aiPaddle.x && ball.y + ball.size >= aiPaddle.y && ball.y <= aiPaddle.y + aiPaddle.height) {
                    let rel = ((ball.y + ball.size/2) - (aiPaddle.y + aiPaddle.height/2)) / (aiPaddle.height/2);
                    rel = Math.max(-1, Math.min(1, rel));
                    let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                    let angle = rel * Math.PI/3; // up to 60 degrees
                    ball.dx = -Math.abs(speed * Math.cos(angle));
                    ball.dy = speed * Math.sin(angle);
                    // Change ball color to match AI paddle
                    ball.color = '#22eaff';
                    aiHits++;
                }

                // Ball out of bounds
                if (ball.x <= 0) {
                    aiScore++;
                    balls.splice(index, 1);
                    if (balls.length === 0) {
                        balls.push(createBall(canvas.width / 2, canvas.height / 2, 6, 6, '#ff00ff'));
                    }
                }

                if (ball.x + ball.size >= canvas.width) {
                    playerScore++;
                    balls.splice(index, 1);
                    if (balls.length === 0) {
                        balls.push(createBall(canvas.width / 2, canvas.height / 2, -6, 6, '#ff00ff'));
                    }
                }

                // Ball collision with powerups
                powerups.forEach((powerup, powerupIndex) => {
                    if (ball.x < powerup.x + powerup.radius && ball.x + ball.size > powerup.x &&
                        ball.y < powerup.y + powerup.radius && ball.y + ball.size > powerup.y) {
                        balls.forEach(b => {
                            b.dx *= 1.5; // Speed up all balls
                            b.dy *= 1.5;
                        });
                        powerups.splice(powerupIndex, 1);
                        setTimeout(() => {
                            if (powerups.length < 3) { // Allow up to 3 powerups
                                powerups.push(createPowerup(Math.random() * canvas.width, Math.random() * canvas.height, 15, 2, 2, '#ff0000'));
                            }
                        }, 30000);
                    }
                });
            });

            // Move powerups
            powerups.forEach(powerup => {
                powerup.x += powerup.dx;
                powerup.y += powerup.dy;

                // Powerup collision with walls
                if (powerup.x <= 0 || powerup.x + powerup.radius >= canvas.width) {
                    powerup.dx *= -1;
                }
                if (powerup.y <= 0 || powerup.y + powerup.radius >= canvas.height) {
                    powerup.dy *= -1;
                }
            });

            // AI paddle movement with skill variability
            updateAISkill();
            if (balls.length > 0) {
                const ball = balls[0];
                if (!aiPaddle.baseSpeed) aiPaddle.baseSpeed = difficultySettings[currentDifficulty].aiSpeed;
                let aiSpeed = aiPaddle.baseSpeed;
                // Skill adjustment
                if (aiSkillMode === 'good') aiSpeed *= 1.5;
                if (aiSkillMode === 'bad') aiSpeed *= 0.5;
                // Add some error for 'bad' mode
                let error = 0;
                if (aiSkillMode === 'bad') error = (Math.random() - 0.5) * 40;
                if (ball.y + error < aiPaddle.y + aiPaddle.height / 2) {
                    aiPaddle.dy = -aiSpeed;
                } else {
                    aiPaddle.dy = aiSpeed;
                }
                aiPaddle.y += aiPaddle.dy;
            }

            // Prevent paddles from going out of bounds
            if (playerPaddle.y < 0) playerPaddle.y = 0;
            if (playerPaddle.y + playerPaddle.height > canvas.height) playerPaddle.y = canvas.height - playerPaddle.height;
            if (aiPaddle.y < 0) aiPaddle.y = 0;
            if (aiPaddle.y + aiPaddle.height > canvas.height) aiPaddle.y = canvas.height - aiPaddle.height;

            // End game if score reaches 10
            if (playerScore >= 10 || aiScore >= 10) {
                fireworks.push(createFirework(playerScore >= 10 ? 100 : canvas.width - 100, canvas.height / 2));
                playerScore = 0;
                aiScore = 0;
                balls.length = 0;
                balls.push(createBall(canvas.width / 2, canvas.height / 2, 6, 6, '#ff00ff'));
            }

            updateActivePowerups();
            checkPowerupCollisions();
            updateAISkill();
        }

        // --- 60 FPS Capped Game Loop ---
        let lastFrameTime = performance.now();
        const targetFPS = 60;
        const frameDuration = 1000 / targetFPS;

        function gameLoop(now) {
            if (now - lastFrameTime >= frameDuration) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawFireworks(); // Draw fireworks behind the board
                drawPaddle(playerPaddle);
                drawPaddle(aiPaddle);
                balls.forEach(drawBall);
                powerups.forEach(drawPowerup);
                drawActivePowerups();
                drawScore();
                printDebug();
                update(now);
                lastFrameTime = now;
            }
            requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'w':
                    playerPaddle.dy = -8; // Increased speed of player paddle
                    break;
                case 's':
                    playerPaddle.dy = 8; // Increased speed of player paddle
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'w':
                case 's':
                    playerPaddle.dy = 0;
                    break;
            }
        });

        gameLoop(performance.now());
    </script>
</body>
</html>
