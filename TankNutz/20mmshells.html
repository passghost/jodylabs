<!--
[PIXEL SPEC]
Subject: 20mm tank shell
View: side
Canvas: 64×64 (each)
Palette: 8 colors — brassLight #e7c97a, brass #caa64e, brassDark #8d6b20, steelLight #c8d2df, steel #9fb0c2, steelDark #5c6a79, outline #1b1f24, accentYellow #ffd54a, tracerRed #ff4a4a
Style notes: chunky shading, rim light, strong silhouette, pixel-outline
Motion: 6 frames @ 120ms — subtle rim-light sweep; variant-specific accents (band flicker, tracer pulse)
Hitbox/anchor: logical pivot at sprite center; no hitbox drawn
Export: single-file HTML only (includes optional sprite-sheet download button)
Constraints: no external libs; cohesive single element; no floating parts
Format: .html
Variety: 4 iterations in a 2×2 grid
-->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>20mm Tank Shells — 4 Iterations (64×64 each)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; min-height: 100dvh; display: grid; place-items: center;
      background: radial-gradient(1200px 600px at 50% 0%, #0b0f14 0%, #07090c 40%, #050608 100%);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #cdd6f4;
    }
    .wrap { width: min(900px, 92vw); }
    h1 { font-size: 16px; letter-spacing: .2px; font-weight: 600; margin: 18px 0 8px; opacity: .9; }
    .grid {
      display: grid; grid-template-columns: repeat(2, 1fr); gap: 14px; 
    }
    figure { margin: 0; background: #0d1218; border: 1px solid #0f1620; border-radius: 10px; padding: 10px; box-shadow: 0 6px 30px rgba(0,0,0,.35) inset; }
    canvas { 
      width: 128px; height: 128px; 
      image-rendering: pixelated; image-rendering: crisp-edges;
      display: block; margin: 4px auto 8px;
      background: linear-gradient(180deg, #0b1218 0%, #0a0f15 100%);
      border-radius: 8px;
    }
    figcaption { text-align: center; font-size: 12px; color: #9aa7b7; }
    .bar { display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:10px; }
    button {
      font: inherit; font-size: 12px; letter-spacing:.2px;
      padding: 8px 10px; border-radius: 10px; border: 1px solid #1a2230; background:#0f1722; color:#c9d4e6;
      box-shadow: 0 6px 30px rgba(0,0,0,.35);
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }
    .meta { opacity:.7; font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>20mm Tank Shell — Pixel Iterations (64×64, 6 frames @ 120ms)</h1>
    <div class="grid" id="grid"></div>
    <div class="bar">
      <div class="meta">Rim-light sweep + variant accents • No external libs</div>
      <button id="save">Download 2×2 Sprite Sheet (PNG)</button>
    </div>
  </div>

  <script>
  // ===== Palette =====
  const PALETTE = {
    brassLight: '#e7c97a', brass: '#caa64e', brassDark: '#8d6b20',
    steelLight: '#c8d2df', steel: '#9fb0c2', steelDark: '#5c6a79',
    outline: '#1b1f24', accentYellow: '#ffd54a', tracerRed: '#ff4a4a'
  };

  // ===== Variants =====
  const VARIANTS = [
    { key:'ap', name:'AP — steel tip, brass case', tipLen:14, bodyH:12, caseHue:'brass', tracer:false, band:null },
    { key:'he', name:'HE — blunt steel nose, yellow band', tipLen:8, bodyH:12, caseHue:'brass', tracer:false, band:{h:2, color:'accentYellow'} },
    { key:'tracer', name:'Tracer — steel tip, red base', tipLen:12, bodyH:12, caseHue:'brass', tracer:true, band:null },
    { key:'apds', name:'APDS — slim dart, gray case', tipLen:18, bodyH:8, caseHue:'steel', tracer:false, band:null }
  ];

  const GRID = document.getElementById('grid');

  // Build 2×2 cells
  const canvases = VARIANTS.map(v => {
    const fig = document.createElement('figure');
    const c = document.createElement('canvas'); c.width = 64; c.height = 64;
    const cap = document.createElement('figcaption'); cap.textContent = v.name;
    fig.appendChild(c); fig.appendChild(cap); GRID.appendChild(fig);
    const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled = false;
    return { v, c, ctx };
  });

  // ===== Drawing Helpers =====
  function px(ctx,x,y,w=1,h=1,color){ ctx.fillStyle=color; ctx.fillRect(x,y,w,h); }

  function clamp(n,min,max){ return n<min?min:(n>max?max:n); }

  function drawShell(ctx, variant, frame){
    const W = ctx.canvas.width, H = ctx.canvas.height;
    // Clear
    ctx.clearRect(0,0,W,H);

    // Geometry
    const totalLen = 48;
    const bodyH = variant.bodyH; // 12 or 8
    const tipLen = variant.tipLen; // pixels
    const bodyLen = totalLen - tipLen;
    const x0 = Math.floor((W - totalLen)/2); // center horizontally
    const y0 = Math.floor((H - bodyH)/2);    // center vertically

    // Colors
    const brassL = PALETTE.brassLight, brass = PALETTE.brass, brassD = PALETTE.brassDark;
    const steelL = PALETTE.steelLight, steel = PALETTE.steel, steelD = PALETTE.steelDark;
    const outline = PALETTE.outline;

    const caseColors = variant.caseHue === 'brass' ? [brassL, brass, brassD] : [steelL, steel, steelD];
    const tipColors  = [steelL, steel, steelD];

    // Animation params (6 frames @ 120ms)
    const f = frame % 6;
    const rimShift = f; // rim-light sweep across the case

    // === CASE BODY ===
    // Outline top & bottom first (for crisp silhouette)
    px(ctx, x0-1, y0-1, bodyLen+2, 1, outline);                // top outline
    px(ctx, x0-1, y0+bodyH, bodyLen+2, 1, outline);            // bottom outline
    px(ctx, x0-1, y0, 1, bodyH, outline);                      // base-left outline

    // Fill with chunky 3-band shading
    const topBandH = 2, botBandH = 3;                          // chunky
    const midH = bodyH - topBandH - botBandH;
    px(ctx, x0, y0,               bodyLen, topBandH, caseColors[0]); // top light
    px(ctx, x0, y0+topBandH,      bodyLen, midH,     caseColors[1]); // mid
    px(ctx, x0, y0+bodyH-botBandH,bodyLen, botBandH, caseColors[2]); // bottom shadow

    // Rim light sweep (1px line) inside top band
    const rimX = x0 + clamp(2+rimShift*7, 2, bodyLen-3);
    px(ctx, rimX, y0, 1, 1, '#ffffff');

    // Decorative band (HE)
    if (variant.band){
      const by = y0 + Math.floor(bodyH/2) - Math.floor(variant.band.h/2) + (f===3?1:0); // tiny flicker offset
      px(ctx, x0+Math.floor(bodyLen*0.20), by, Math.floor(bodyLen*0.60), variant.band.h, PALETTE[variant.band.color]);
    }

    // Tracer base (red pulse, non-floating — sits inside base cap)
    if (variant.tracer){
      const intensity = (f%3===0) ? '#ff6a6a' : PALETTE.tracerRed;
      px(ctx, x0-1, y0+Math.floor(bodyH/2)-2, 2, 4, intensity);          // glowing plug
      px(ctx, x0,   y0+Math.floor(bodyH/2)-3, 1, 6, '#802222');           // darker core
    }

    // === STEEL TIP ===
    // We draw a stepped triangle to a point, using vertical bars per column.
    const slope = (bodyH/2) / tipLen; // controls taper per x step

    for (let i=0; i<tipLen; i++){
      const x = x0 + bodyLen + i;
      const t = Math.floor(i * slope);
      const top = y0 + t;
      const bot = y0 + bodyH - 1 - t;
      // shade: light near top, darker near bottom
      const h = bot - top + 1;
      const mid = Math.floor(h*0.5);
      px(ctx, x, top, 1, Math.max(1, Math.min(h,1)), tipColors[0]);               // glint
      px(ctx, x, top+1, 1, Math.max(0, mid-1), tipColors[1]);                     // mid steel
      px(ctx, x, top+mid, 1, Math.max(0, h-mid), tipColors[2]);                   // shadow

      // Tip rim-light sparkle (moves)
      if ((i + f) % 6 === 0 && h>2){ px(ctx, x, top, 1, 1, '#ffffff'); }
    }

    // Blunt nose tweak (HE): square off the last cols
    if (variant.key==='he'){
      // Add a small flat cap at the nose
      const noseW = 3;
      const xn = x0 + bodyLen + tipLen - noseW;
      px(ctx, xn, y0+Math.floor(bodyH*0.25), noseW, Math.floor(bodyH*0.5), steel);
    }

    // === OUTLINES around tip (pixel-stepped) ===
    for (let i=0; i<tipLen; i++){
      const x = x0 + bodyLen + i;
      const t = Math.floor(i * slope);
      const top = y0 + t;
      const bot = y0 + bodyH - 1 - t;
      px(ctx, x, top-1, 1, 1, outline);
      px(ctx, x, bot+1, 1, 1, outline);
    }

    // Nose point outline pixel
    px(ctx, x0 + bodyLen + tipLen, y0 + Math.floor(bodyH/2), 1, 1, outline);

    // === Base cap edge highlight ===
    px(ctx, x0, y0+bodyH-1, 2, 1, caseColors[0]);
  }

  // ===== Animation Loop =====
  let last = 0, frame = 0; const FRAME_MS = 120; // 120ms per frame
  function loop(ts){
    if (!last) last = ts;
    const delta = ts - last;
    if (delta >= FRAME_MS){ frame = (frame+1) % 6; last = ts; }
    for (const {v, ctx} of canvases){ drawShell(ctx, v, frame); }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Export 2×2 sheet =====
  document.getElementById('save').addEventListener('click', () => {
    const sheet = document.createElement('canvas');
    const CW = 64, CH = 64, GAP = 4;
    sheet.width = CW*2 + GAP; sheet.height = CH*2 + GAP;
    const sctx = sheet.getContext('2d'); sctx.imageSmoothingEnabled = false;

    // Draw current frames in 2×2
    // Order matches VARIANTS
    sctx.drawImage(canvases[0].c, 0, 0);
    sctx.drawImage(canvases[1].c, CW+GAP, 0);
    sctx.drawImage(canvases[2].c, 0, CH+GAP);
    sctx.drawImage(canvases[3].c, CW+GAP, CH+GAP);

    const url = sheet.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = '20mm_shells_2x2_64px.png'; a.click();
  });
  </script>
</body>
</html>
