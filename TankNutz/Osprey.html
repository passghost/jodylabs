Skip to content
You said:
Subject: (e.g., “A twin prop V-22 Osprey with working props”)
View: (top-down / 3⁄4 / side)
Canvas: (e.g., 48×48 or 64×64)
Palette: (named palette or 6–10 hex colors)
Style notes: (chunky shading, rim light, strong silhouette, etc.)
Motion: (what animates + frames, e.g., 6 frames, 120ms)
Hitbox/anchor: (pivot center, feet baseline, etc.)
Export: (single-file HTML only)
Constraints: (no external libs, cohesive single element, no floating parts)
Format: .html
ChatGPT said:

Here’s a complete filled-out spec, followed by a single-file HTML that implements it.

Subject: Twin-prop V-22 Osprey (tiltrotor) with working props
View: Top-down
Canvas: 64×64 (CSS-scaled, pixelated)
Palette:

    Outline: #1b1e27

    Steel (mid): #596273

    Steel (light): #8f98ab

    Rim light: #c9d1e4

    Rotor hub/blades (dark): #2b303b

    Rotor blur: rgba(154,163,180,0.35)

    Cockpit glass: #3a74a6

    Warning accent: #d26b1e
    Style notes: chunky shading, strong silhouette, subtle rim light on top edges, mirrored symmetry, minimal noise.
    Motion: proprotors spin in a 12-frame stepped loop (~60 ms per step), 1–2 px hover bob (~1.2 s).
    Hitbox/anchor: pivot at fuselage center (canvas center).
    Export: single-file HTML only.
    Constraints: no external libs; cohesive single element (single <canvas>), no floating parts.

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pixel V-22 Osprey — Top-Down with Working Props</title>
<style>
  :root { color-scheme: dark; }
  html, body { height: 100%; }
  body {
    margin: 0;
    display: grid;
    place-items: center;
    background: #0f0f12;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
  }
  canvas {
    /* Keep pixels crisp */
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: 384px;   /* 64 * 6 */
    height: 384px;  /* square upscale for preview */
    box-shadow: 0 0 0 2px #0b0b0e, 0 8px 40px rgba(0,0,0,0.6);
    border-radius: 8px;
    background: transparent;
  }
  .note {
    position: fixed; inset: auto 0 12px 0;
    text-align: center; font-size: 12px; color: #9aa3b4; opacity: .8;
  }
</style>
</head>
<body>
<canvas id="c" width="64" height="64" aria-label="Pixel Osprey sprite"></canvas>
<div class="note">Anchor: center • 64×64 canvas • 12-step prop loop</div>
<script>
(() => {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d', { alpha: true });
  ctx.imageSmoothingEnabled = false;

  // ---- Palette ----
  const COL = {
    outline: '#1b1e27',
    steelMid: '#596273',
    steelLight: '#8f98ab',
    rim: '#c9d1e4',
    rotorDark: '#2b303b',
    rotorBlur: 'rgba(154,163,180,0.35)',
    glass: '#3a74a6',
    warn: '#d26b1e'
  };

  // ---- Pixel helpers ----
  function px(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x|0, y|0, 1, 1);
  }
  function rect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x|0, y|0, w|0, h|0);
  }
  // Bresenham line for chunky pixel blades
  function linePix(x0, y0, x1, y1, color) {
    x0|=0; y0|=0; x1|=0; y1|=0;
    let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    let err = dx + dy, e2;
    while (true) {
      px(x0, y0, color);
      if (x0 === x1 && y0 === y1) break;
      e2 = 2 * err;
      if (e2 >= dy) { err += dy; x0 += sx; }
      if (e2 <= dx) { err += dx; y0 += sy; }
    }
  }
  function discPix(cx, cy, r, color) { // filled circle with pixels
    for (let y = -r; y <= r; y++) {
      for (let x = -r; x <= r; x++) {
        if (x*x + y*y <= r*r) px(cx + x, cy + y, color);
      }
    }
  }

  // ---- Osprey drawing ----
  function drawOsprey(cx, cy, rotorStep, bob) {
    // Layout constants (fits 64×64 with blades inside)
    const halfWing = 22;      // half wingspan
    const wingY = cy - 2;     // wing vertical placement
    const nacelleR = 4;       // nacelle half-size (square 8×8)
    const rotorR = 10;        // blade radius
    const fusW = 8, fusH = 24;

    // Clear
    ctx.clearRect(0, 0, c.width, c.height);

    // Soft ground hint (pixel ellipse) for cohesion & depth (no floating parts)
    // Built from chunky rectangles to keep pixels crisp.
    const gy = cy + 12 + bob;
    for (let i = 0; i < 5; i++) {
      const alpha = 0.06 - i * 0.01;
      if (alpha <= 0) break;
      ctx.fillStyle = `rgba(0,0,0,${alpha})`;
      const w = 36 - i*6, h = 8 - i*1;
      rect(cx - (w>>1), gy - (h>>1), w, h, ctx.fillStyle);
    }

    // Wings
    rect(cx - halfWing, wingY + bob, halfWing*2, 4, COL.steelMid);
    // Rim light along wing top edge
    rect(cx - halfWing, wingY + bob, halfWing*2, 1, COL.rim);

    // Fuselage core
    rect(cx - (fusW>>1), cy - (fusH>>1) + bob, fusW, fusH, COL.steelMid);
    // Nose taper
    rect(cx - 3, cy - (fusH>>1) - 4 + bob, 6, 4, COL.steelLight);
    // Cockpit glass
    rect(cx - 2, cy - (fusH>>1) - 3 + bob, 4, 2, COL.glass);
    // Tail boom & tailplane
    rect(cx - 3, cy + (fusH>>1) + bob, 6, 6, COL.steelMid);
    rect(cx - 12, cy + (fusH>>1) + 4 + bob, 24, 2, COL.steelMid);

    // Subtle fuselage rim light
    rect(cx - (fusW>>1), cy - (fusH>>1) + bob, fusW, 1, COL.rim);

    // Outlines (select edges for stronger silhouette)
    // Wing outline
    rect(cx - halfWing, wingY - 1 + bob, halfWing*2, 1, COL.outline);
    rect(cx - halfWing, wingY + 4 + bob, halfWing*2, 1, COL.outline);
    // Fuselage outline
    rect(cx - (fusW>>1) - 1, cy - (fusH>>1) - 1 + bob, fusW + 2, 1, COL.outline);
    rect(cx - (fusW>>1) - 1, cy + (fusH>>1) + bob, fusW + 2, 1, COL.outline);
    rect(cx - (fusW>>1) - 1, cy - (fusH>>1) + bob, 1, fusH, COL.outline);
    rect(cx + (fusW>>1),   cy - (fusH>>1) + bob, 1, fusH, COL.outline);

    // Nacelles (left/right)
    const nxL = cx - halfWing, nxR = cx + halfWing;
    const ny  = wingY + 2 + bob;

    rect(nxL - nacelleR, ny - nacelleR, nacelleR*2, nacelleR*2, COL.steelMid);
    rect(nxR - nacelleR, ny - nacelleR, nacelleR*2, nacelleR*2, COL.steelMid);
    // Nacelle rim light
    rect(nxL - nacelleR, ny - nacelleR, nacelleR*2, 1, COL.rim);
    rect(nxR - nacelleR, ny - nacelleR, nacelleR*2, 1, COL.rim);
    // Warning accents
    rect(nxL - nacelleR, ny + nacelleR, 3, 1, COL.warn);
    rect(nxR + nacelleR - 3, ny + nacelleR, 3, 1, COL.warn);
    // Nacelle outline
    rect(nxL - nacelleR - 1, ny - nacelleR - 1, nacelleR*2 + 2, 1, COL.outline);
    rect(nxL - nacelleR - 1, ny + nacelleR,     nacelleR*2 + 2, 1, COL.outline);
    rect(nxL - nacelleR - 1, ny - nacelleR,     1, nacelleR*2,  COL.outline);
    rect(nxL + nacelleR,     ny - nacelleR,     1, nacelleR*2,  COL.outline);

    rect(nxR - nacelleR - 1, ny - nacelleR - 1, nacelleR*2 + 2, 1, COL.outline);
    rect(nxR - nacelleR - 1, ny + nacelleR,     nacelleR*2 + 2, 1, COL.outline);
    rect(nxR - nacelleR - 1, ny - nacelleR,     1, nacelleR*2,  COL.outline);
    rect(nxR + nacelleR,     ny - nacelleR,     1, nacelleR*2,  COL.outline);

    // Hubs (connect rotors visually to avoid "floating parts")
    discPix(nxL, ny, 1, COL.warn);
    discPix(nxR, ny, 1, COL.warn);

    // Rotors — 3-blade, stepped rotation for pixel feel
    const steps = 12;
    const ang = (rotorStep % steps) * (Math.PI * 2 / steps);
    drawRotor(nxL, ny, ang, rotorR);
    drawRotor(nxR, ny, ang, rotorR);
  }

  function drawRotor(cx, cy, ang, r) {
    // Three blades 120° apart
    for (let i = 0; i < 3; i++) {
      const a = ang + i * (Math.PI * 2 / 3);
      const ex = Math.round(cx + Math.cos(a) * r);
      const ey = Math.round(cy + Math.sin(a) * r);
      // Core blade stroke (dark)
      linePix(cx, cy, ex, ey, COL.rotorDark);
      // Slight thickness by offsetting one pixel orthogonal near root
      const ox = Math.round(-Math.sin(a));
      const oy = Math.round( Math.cos(a));
      linePix(cx + ox, cy + oy, ex + ox, ey + oy, COL.rotorDark);
      // Light blur ghosts on both sides for motion hint
      ctx.globalAlpha = 1.0;
      linePix(cx - ox, cy - oy, ex - ox, ey - oy, COL.rotorBlur);
    }
    // Subtle rotor disc hint (very faint)
    discPix(cx, cy, 2, COL.rotorBlur);
  }

  // ---- Animation loop ----
  let lastTime = 0;
  let rotorStep = 0;

  function tick(t) {
    if (!lastTime) lastTime = t;
    const dt = t - lastTime;

    // Step the rotor in fixed 60ms increments (≈12 fps for blades)
    if (dt >= 60) {
      rotorStep = (rotorStep + Math.floor(dt / 60)) % 12;
      lastTime = t;
    }

    // Hover bob (rounded to whole pixels)
    const bob = Math.round(Math.sin(t / 1200) * 1.5);

    drawOsprey(32, 32, rotorStep, bob);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Accessibility: pause/resume on visibility change
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) lastTime = 0;
  });

  // Hitbox/anchor note (for integrators):
  // Pivot/anchor is at (32, 32) — the fuselage center.
})();
</script>
</body>
</html>

You said:
Make the tail more detailed. Do a quick lookup of the Osprey tail, ad a bit more detail there and make the colors camofluge.
ChatGPT said:


ChatGPT can make mistakes. Check important info.
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
    discPix(nxR, ny, 1, COL.warn);

    // Rotors — 3-blade, stepped rotation for pixel feel
    const steps = 12;
    const ang = (rotorStep % steps) * (Math.PI * 2 / steps);
    drawRotor(nxL, ny, ang, rotorR);
    drawRotor(nxR, ny, ang, rotorR);
  }

  function drawRotor(cx, cy, ang, r) {
    // Three blades 120° apart
    for (let i = 0; i < 3; i++) {
      const a = ang + i * (Math.PI * 2 / 3);
      const ex = Math.round(cx + Math.cos(a) * r);
      const ey = Math.round(cy + Math.sin(a) * r);
      // Core blade stroke (dark)
      linePix(cx, cy, ex, ey, COL.rotorDark);
      // Slight thickness by offsetting one pixel orthogonal near root
      const ox = Math.round(-Math.sin(a));
      const oy = Math.round( Math.cos(a));
      linePix(cx + ox, cy + oy, ex + ox, ey + oy, COL.rotorDark);
      // Light blur ghosts on both sides for motion hint
      ctx.globalAlpha = 1.0;
      linePix(cx - ox, cy - oy, ex - ox, ey - oy, COL.rotorBlur);
    }
    // Subtle rotor disc hint (very faint)
    discPix(cx, cy, 2, COL.rotorBlur);
  }

  // ---- Animation loop ----
  let lastTime = 0;
  let rotorStep = 0;

  function tick(t) {
    if (!lastTime) lastTime = t;
    const dt = t - lastTime;

    // Step the rotor in fixed 60ms increments (≈12 fps for blades)
    if (dt >= 60) {
      rotorStep = (rotorStep + Math.floor(dt / 60)) % 12;
      lastTime = t;
    }

    // Hover bob (rounded to whole pixels)
    const bob = Math.round(Math.sin(t / 1200) * 1.5);

    drawOsprey(32, 32, rotorStep, bob);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Accessibility: pause/resume on visibility change
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) lastTime = 0;
  });

  // Hitbox/anchor note (for integrators):
  // Pivot/anchor is at (32, 32) — the fuselage center.
})();
</script>
</body>
</html>

ChatGPT is still generating a response...
