<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Jungle Trees — 2×2 Variants (64×64, 6 frames @120ms)</title>
<style>
  :root { --bg:#0b0f14; --ui:#18202a; --fg:#cfd7e3; }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--fg);font:14px/1.3 system-ui,Segoe UI,Roboto,Arial;
    display:grid;place-items:center;padding:16px;
  }
  .wrap{
    width:min(1100px,95vw);
  }
  h1{font-size:16px;margin:0 0 8px;font-weight:600;opacity:.9}
  .spec{opacity:.8;font-size:12px;margin-bottom:12px;white-space:pre-wrap;border:1px solid #223; background: #0f131a; padding:8px;border-radius:8px}
  .grid{
    display:grid;grid-template-columns:repeat(2,1fr);gap:16px;
    background:linear-gradient(135deg,#0f131a,#0c1117);padding:16px;border-radius:14px;border:1px solid #1c2430;
  }
  .tile{
    display:grid;place-items:center;gap:8px;background:var(--ui);border:1px solid #2a3543;border-radius:12px;
    padding:10px;
  }
  canvas{
    image-rendering:pixelated;
    width:256px;height:256px; /* 4× upscale */
    background: transparent;
    display:block;
  }
  .label{font-size:12px;opacity:.8}
  .toolbar{display:flex;gap:8px;align-items:center;margin:10px 0 0}
  button{
    background:#1b2533;border:1px solid #2b394e;color:var(--fg);padding:6px 10px;border-radius:8px;cursor:pointer;
  }
  button:hover{filter:brightness(1.15)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Jungle Trees — 4 Iterations in a 2×2 Grid</h1>
  <div class="spec">
Subject: “Jungle Trees”
View: 3⁄4
Canvas: 64×64
Palette: Deep greens + warm bark (8 colors below)
Style notes: chunky shading, slight rim light from upper-right, strong silhouette
Motion: canopy sway & frond flutter — 6 frames, 120ms
Hitbox/anchor: pivot ≈ trunk base center; feet baseline at y=56..60
Export: single-file HTML (this file)
Constraints: no external libs; cohesive single element; no floating parts
Format: .html
Variety: 4 iterations (2×2 grid)
  </div>
  <div class="grid" id="grid">
    <div class="tile"><canvas width="64" height="64"></canvas><div class="label">A · Broad canopy (Kapok)</div></div>
    <div class="tile"><canvas width="64" height="64"></canvas><div class="label">B · Fan palms cluster</div></div>
    <div class="tile"><canvas width="64" height="64"></canvas><div class="label">C · Banyan w/ vines</div></div>
    <div class="tile"><canvas width="64" height="64"></canvas><div class="label">D · Stout buttress</div></div>
  </div>
  <div class="toolbar">
    <button id="png">Download PNG (current frame)</button>
    <button id="guides">Toggle Guides</button>
  </div>
</div>

<script>
/* ---------- Palette (8 colors) ---------- */
const PAL = {
  leafDark:  "#1c3f26",
  leafMid:   "#2e6a3a",
  leafLite:  "#53a34f",
  rimLeaf:   "#8adf76",
  barkDark:  "#3b2518",
  barkMid:   "#643f28",
  barkLite:  "#9b6a44",
  rimBark:   "#d29a6a",
  ground:    "#1a2a1d"
};

/* ---------- Utilities ---------- */
function rng(seed){
  let s = seed >>> 0;
  return function() {
    s = (s * 1664525 + 1013904223) >>> 0;
    return s / 4294967296;
  }
}
function lerp(a,b,t){ return a+(b-a)*t }

/* Simple pixel put using fillRect on a 64×64 canvas */
function px(ctx,x,y,color){
  if(x<0||x>=64||y<0||y>=64) return;
  ctx.fillStyle=color; ctx.fillRect(x, y, 1, 1);
}

/* Filled disk/ellipse helper (integer radii) */
function blob(ctx, cx, cy, rx, ry, color){
  for(let y=-ry; y<=ry; y++){
    for(let x=-rx; x<=rx; x++){
      if((x*x)/(rx*rx) + (y*y)/(ry*ry) <= 1){
        px(ctx, cx+x, cy+y, color);
      }
    }
  }
}

/* Outline-ish shadow: draw a darker ring around approximate canopy edge */
function ringShadow(ctx, cx, cy, rx, ry, color){
  for(let a=0;a<360;a+=2){
    const rad = a*Math.PI/180, x = Math.round(cx + Math.cos(rad)*rx), y = Math.round(cy + Math.sin(rad)*ry);
    px(ctx,x,y,color);
  }
}

/* Draw trunk with rim light and chunky shading */
function drawTrunk(ctx, baseX, baseY, h, w, sway, hasButtress=false, vines=0){
  const topY = baseY - h;
  for(let y=0;y<=h;y++){
    const yy = baseY - y;
    const taper = Math.max(1, Math.round(w - y*(w-2)/h));
    const x0 = baseX - Math.floor(taper/2) + Math.round(sway * (1 - y/h)); // slight bend with sway
    for(let x=0;x<taper;x++){
      // Shading: left dark, core mid, right light, rim highlight on extreme right
      const atRightEdge = x === taper-1;
      const atLeftEdge  = x === 0;
      let c = PAL.barkMid;
      if(atLeftEdge) c = PAL.barkDark;
      if(atRightEdge) c = PAL.barkLite;
      if(atRightEdge && (y%2===0)) c = PAL.rimBark; // rim sparkle
      px(ctx, x0 + x, yy, c);
    }
    // occasional horizontal "bark" ticks
    if(y%7===3){
      px(ctx, baseX, yy, PAL.barkDark);
    }
  }

  // Buttress roots (optional)
  if(hasButtress){
    for(let i=-1;i<=1;i+=2){
      let bx = baseX + i * Math.ceil(w/2);
      for(let k=0;k<4;k++){
        px(ctx, bx + i*Math.floor(k/2), baseY - k, PAL.barkLite);
        px(ctx, bx + i*Math.floor(k/2), baseY - k + 1, PAL.barkMid);
      }
    }
  }

  // Vines (optional)
  for(let v=0; v<vines; v++){
    const vx = baseX + (v%2===0 ? -1:1) * Math.floor(w/2);
    for(let yy=topY; yy<=baseY-2; yy++){
      if(yy % 2 === (v%2)) px(ctx, vx, yy, PAL.leafMid);
      if(yy % 5 === 0) { // little leaf nub
        px(ctx, vx + (v%2?1:-1), yy, PAL.leafLite);
      }
    }
  }

  // Ground contact (grass tuft)
  for(let gx=-4; gx<=4; gx++){
    if(Math.abs(gx)%2===0) px(ctx, baseX+gx, baseY+1, PAL.ground);
    if(Math.abs(gx)%3===0) px(ctx, baseX+gx, baseY, PAL.leafDark);
  }
}

/* Canopy clusters; sway anim via dx offset */
function drawCanopy(ctx, cx, cy, rngf, swayPhase, variant){
  const clusters = [];
  if(variant === "broad"){
    clusters.push({rx:10,ry:6, dy:0,  dx:0});
    clusters.push({rx:9, ry:5, dy:-5, dx:-3});
    clusters.push({rx:8, ry:5, dy:-4, dx:4});
  } else if(variant === "palms"){
    clusters.push({rx:9, ry:3, dy:0, dx:0});
    clusters.push({rx:10,ry:3, dy:-2,dx:-2});
    clusters.push({rx:10,ry:3, dy:-2,dx:2});
  } else if(variant === "banyan"){
    clusters.push({rx:8, ry:6, dy:-1, dx:0});
    clusters.push({rx:7, ry:5, dy:-6, dx:-3});
    clusters.push({rx:7, ry:5, dy:-6, dx:3});
  } else { // stout
    clusters.push({rx:9, ry:7, dy:0, dx:0});
    clusters.push({rx:7, ry:5, dy:-5, dx:-4});
    clusters.push({rx:7, ry:5, dy:-5, dx:4});
  }

  const sway = Math.round(Math.sin(swayPhase)*1); // ±1px, keep it cohesive
  const liteBias = Math.cos(swayPhase)*0.5 + 0.5;

  // Shadow ring to give silhouette pop
  clusters.forEach(cl=>{
    ringShadow(ctx, cx + cl.dx + sway, cy + cl.dy, cl.rx, cl.ry, PAL.leafDark);
  });

  // Fill clusters with simple light-from-top-right shading
  clusters.forEach(cl=>{
    for(let y=-cl.ry; y<=cl.ry; y++){
      for(let x=-cl.rx; x<=cl.rx; x++){
        if((x*x)/(cl.rx*cl.rx) + (y*y)/(cl.ry*cl.ry) <= 1){
          const wx = x + 0.8, wy = y - 0.6; // light direction tweak
          const shade = (wx*0.6 - wy*0.9) / (Math.max(cl.rx,cl.ry));
          let c = PAL.leafMid;
          if(shade > 0.25) c = PAL.leafLite;
          if(shade > 0.55 + liteBias*0.15) c = PAL.rimLeaf;
          if(shade < -0.2) c = PAL.leafDark;
          px(ctx, cx + cl.dx + sway + x, cy + cl.dy + y, c);
        }
      }
    }
  });

  // Palm frond accents for the palm variant
  if(variant === "palms"){
    for(let i=0;i<6;i++){
      const ang = (-40 + i*16) * Math.PI/180;
      const len = 12 + (i%2)*3;
      const wob = Math.sin(swayPhase + i*0.7)*1;
      for(let t=0;t<len;t++){
        const xx = Math.round(cx + Math.cos(ang)*(t+wob));
        const yy = Math.round(cy + Math.sin(ang)*(t*0.7));
        px(ctx, xx, yy, (t>len*0.7)? PAL.rimLeaf : PAL.leafLite);
      }
    }
  }
}

/* One full tree */
function drawTree(ctx, seed, tNorm, variantName){
  const R = rng(seed);
  ctx.clearRect(0,0,64,64);

  // Base/pivot
  const baseY = 58 + Math.floor(R()*2);         // ≈ feet baseline 56..60
  const baseX = 32 + Math.round((R()-0.5)*4);   // slight horizontal variation

  // Wind/sway phase (0..2π per loop)
  const swayPhase = tNorm * Math.PI*2 + (R()*Math.PI*2);

  // Trunk params per variant
  let trunkH, trunkW, buttress=false, vines=0, canopyVar="broad";
  switch(variantName){
    case "A": trunkH= Math.floor(32+R()*10); trunkW= Math.floor(4+R()*2); canopyVar="broad"; break; // Kapok-ish
    case "B": trunkH= Math.floor(28+R()*8);  trunkW= Math.floor(3+R()*2); canopyVar="palms";  break; // Palms cluster
    case "C": trunkH= Math.floor(34+R()*8);  trunkW= Math.floor(4+R()*2); canopyVar="banyan"; vines=2; break; // Banyan
    case "D": trunkH= Math.floor(30+R()*6);  trunkW= Math.floor(6+R()*2); canopyVar="stout";  buttress=true; break; // Buttress
  }

  const sway = Math.sin(swayPhase)*1.5; // trunk gentle bend (sub-pixel OK; we quantize inside)
  drawTrunk(ctx, baseX, baseY, trunkH, trunkW, sway, buttress, vines);

  // Canopy anchored to trunk top
  const topY = baseY - trunkH;
  const canopyCX = baseX + Math.round(sway*0.6);
  const canopyCY = topY - 2;
  drawCanopy(ctx, canopyCX, canopyCY, R, swayPhase, canopyVar);

  // Optional guides
  if(SHOW_GUIDES){
    // pivot
    px(ctx, baseX, baseY, "#ff3355");
    px(ctx, baseX-1, baseY, "#ff3355");
    px(ctx, baseX+1, baseY, "#ff3355");
    // baseline
    for(let gx=4;gx<60;gx++) if(gx%2===0) px(ctx, gx, baseY, "#334");
    // hitbox rough (bounding box around trunk+canopy)
    for(let x=8;x<56;x++){ px(ctx,x,8,"#233"); px(ctx,x,55,"#233"); }
    for(let y=8;y<56;y++){ px(ctx,8,y,"#233"); px(ctx,55,y,"#233"); }
  }
}

/* ---------- Boot ---------- */
const tiles = Array.from(document.querySelectorAll("canvas"));
const ctxs  = tiles.map(c=>{
  const ctx = c.getContext("2d", {alpha:true});
  ctx.imageSmoothingEnabled = false;
  return ctx;
});
const variants = ["A","B","C","D"];
const seeds = [0xA11CE, 0xBEE5, 0xC0FFEE, 0xD15EA5];

let SHOW_GUIDES = false;

// Animation: 6 frames @ 120ms (≈8.333 fps)
const FRAMES = 6, FRAME_MS = 120;
let start = performance.now();

function frame(now){
  const elapsed = now - start;
  const frameIndex = Math.floor(elapsed / FRAME_MS) % FRAMES;
  const tNorm = frameIndex / FRAMES;

  for(let i=0;i<ctxs.length;i++){
    drawTree(ctxs[i], seeds[i], tNorm, variants[i]);
  }

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* ---------- Export buttons ---------- */
document.getElementById("png").addEventListener("click", ()=>{
  // Compose a 2×2 sheet (each 64×64) into a single PNG
  const sheet = document.createElement("canvas");
  sheet.width = 128; sheet.height = 128;
  const sctx = sheet.getContext("2d");
  sctx.imageSmoothingEnabled = false;

  // Draw current frame from visible canvases
  for(let i=0;i<4;i++){
    const sx = (i%2)*64, sy = Math.floor(i/2)*64;
    sctx.drawImage(tiles[i], 0,0,64,64, sx, sy, 64,64);
  }

  const link = document.createElement("a");
  link.download = "jungle_trees_2x2_64px.png";
  link.href = sheet.toDataURL("image/png");
  link.click();
});

document.getElementById("guides").addEventListener("click", ()=>{
  SHOW_GUIDES = !SHOW_GUIDES;
});
</script>
</body>
</html>
