<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tiny Top-Down Pixel Helicopter — Mouse-Aim Chin Gun + WASD Body</title>
<style>
  html, body { height: 100%; }
  body {
    margin: 0;
    display: grid;
    place-items: center;
    background: #0f0f12;
    color: #d7d7db;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: min(90vmin, 640px);
    height: min(90vmin, 640px);
    background: #0c0c10;
    display: block;
    border-radius: 12px;
    box-shadow: inset 0 0 0 1px #26262e;
  }
</style>
</head>
<body>
<canvas id="game" width="512" height="512"></canvas>
<script>
/* ----------------------------------
   Setup
---------------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const W = canvas.width, H = canvas.height;

function randPalette() {
  const h = 130 + Math.floor(Math.random()*80) - 40; // hover between teal/green/blue
  const s = 40 + Math.floor(Math.random()*25);
  const base = 30 + Math.floor(Math.random()*10);
  return {
    hull: `hsl(${h} ${s}% ${base+8}%)`,
    hullDark: `hsl(${h} ${s}% ${base-4}%)`,
    hullLight: `hsl(${h} ${s+8}% ${base+16}%)`,
    canopy: `hsl(${(h+200)%360} ${s+10}% ${base+22}%)`,
    metal: `hsl(${h} ${Math.max(20,s-15)}% ${base-10}%)`
  };
}
let palette = randPalette();

const COLORS = {
  shadow: 'rgba(0,0,0,0.28)',
  rotorBlur: 'rgba(230,230,235,0.08)',
  rotorDark: '#1a1a1a',
  skid: '#141414',
  glow: 'rgba(255,255,255,0.06)',
  grid: '#000'
};

/* ----------------------------------
   Sprite Canvases (pixel art up-facing)
---------------------------------- */
const SPR_W = 24, SPR_H = 24;      // body sprite size (up-facing)
const SCALE = 2;                   // world scale
const bodyCanvas = document.createElement('canvas');
bodyCanvas.width = SPR_W; bodyCanvas.height = SPR_H;
const bctx = bodyCanvas.getContext('2d');

const rotorCanvas = document.createElement('canvas'); // main rotor (same size, centered)
rotorCanvas.width = SPR_W; rotorCanvas.height = SPR_H;
const rctx = rotorCanvas.getContext('2d');

const tailCanvas = document.createElement('canvas');  // tail rotor (small)
tailCanvas.width = 10; tailCanvas.height = 10;
const trctx = tailCanvas.getContext('2d');

const gunCanvas = document.createElement('canvas');   // chin gun (tiny, up-facing)
gunCanvas.width = 8; gunCanvas.height = 8;
const gctx = gunCanvas.getContext('2d');

/* ----------------------------------
   Pixel helpers
---------------------------------- */
function px(ctx, x, y, w=1, h=1, color='#fff'){ ctx.fillStyle = color; ctx.fillRect(x, y, w, h); }

/* ----------------------------------
   Draw Helicopter (up-facing)
---------------------------------- */
function drawHeliBodyUp() {
  bctx.clearRect(0,0,SPR_W,SPR_H);
  // skids
  for (let x = 4; x <= 19; x++) px(bctx, x, 18, 1, 1, COLORS.skid);
  for (let x = 5; x <= 20; x++) px(bctx, x, 20, 1, 1, COLORS.skid);
  // struts
  px(bctx, 6,16,1,3, COLORS.skid);
  px(bctx, 18,16,1,3, COLORS.skid);

  // fuselage core
  for (let y = 8; y <= 17; y++) for (let x = 6; x <= 17; x++) px(bctx, x, y, 1, 1, palette.hull);
  // shading + highlights
  for (let y = 8; y <= 13; y++) for (let x = 6; x <= 10; x++) px(bctx, x, y, 1, 1, palette.hullDark);
  for (let y = 8; y <= 11; y++) for (let x = 12; x <= 17; x++) px(bctx, x, y, 1, 1, palette.hullLight);

  // canopy (nose)
  for (let y = 4; y <= 9; y++) for (let x = 9; x <= 14; x++) px(bctx, x, y, 1, 1, palette.canopy);
  // canopy glint
  px(bctx, 10,5,1,1, '#fff');
  px(bctx, 11,5,1,1, '#e0f2ff');

  // tail boom
  for (let y = 2; y <= 9; y++) for (let x = 11; x <= 12; x++) px(bctx, x, y, 1, 1, palette.hull);
  // tail cap
  for (let y = 1; y <= 2; y++) for (let x = 10; x <= 13; x++) px(bctx, x, y, 1, 1, palette.hullDark);
  // tail stub to side (mount for tail rotor, right side)
  for (let y = 2; y <= 3; y++) for (let x = 15; x <= 17; x++) px(bctx, x, y, 1, 1, palette.metal);

  // engine hump (behind mast)
  for (let y = 12; y <= 15; y++) for (let x = 8; x <= 15; x++) px(bctx, x, y, 1, 1, palette.hullLight);

  // mast base (center)
  for (let y = 10; y <= 11; y++) for (let x = 11; x <= 12; x++) px(bctx, x, y, 1, 1, palette.metal);

  // tiny rivets
  px(bctx, 7,9,1,1, '#000'); px(bctx, 16,9,1,1, '#000');
  px(bctx, 7,16,1,1, '#000'); px(bctx, 16,16,1,1, '#000');
}

function drawMainRotorPattern() {
  rctx.clearRect(0,0,SPR_W,SPR_H);
  const cx = SPR_W/2, cy = SPR_H/2;
  rctx.save();
  rctx.translate(cx, cy);
  // 3 blades base pattern (we'll rotate this each frame in world)
  const bladeLen = 11, bladeThick = 2;
  for (let i = 0; i < 3; i++) {
    rctx.save();
    rctx.rotate((i * Math.PI * 2) / 3);
    rctx.fillStyle = COLORS.rotorDark;
    rctx.fillRect(-bladeThick/2, -bladeLen, bladeThick, bladeLen);
    // faint blur halo near tips
    rctx.fillStyle = COLORS.rotorBlur;
    rctx.fillRect(-bladeThick*2, -bladeLen, bladeThick*4, 1);
    rctx.restore();
  }
  // hub
  rctx.fillStyle = palette.metal;
  rctx.fillRect(-2,-2,4,4);
  rctx.restore();
}

function drawTailRotorPattern() {
  trctx.clearRect(0,0,tailCanvas.width, tailCanvas.height);
  const cx = tailCanvas.width/2, cy = tailCanvas.height/2;
  trctx.save();
  trctx.translate(cx, cy);
  // 2-blade tail rotor pattern (we'll spin this)
  trctx.fillStyle = COLORS.rotorDark;
  trctx.fillRect(-1, -4, 2, 8);
  trctx.fillRect(-4, -1, 8, 2);
  // hub
  trctx.fillStyle = palette.metal;
  trctx.fillRect(-1,-1,2,2);
  trctx.restore();
}

function drawChinGunUp() {
  gctx.clearRect(0,0,8,8);
  // tiny turret base
  for (let y=3;y<=5;y++) for (let x=2;x<=5;x++) px(gctx, x, y, 1, 1, palette.metal);
  // barrel forward (up)
  for (let y=0;y<=2;y++) px(gctx, 3, y, 2, 1, '#0c0c0c');
  // muzzle glint
  px(gctx, 4,0,1,1,'#666');
}

function rebuildSprites() {
  drawHeliBodyUp();
  drawMainRotorPattern();
  drawTailRotorPattern();
  drawChinGunUp();
}
rebuildSprites();

/* ----------------------------------
   Entity + Input
---------------------------------- */
const heli = {
  x: W/2, y: H/2,
  bodyAngle: -Math.PI/2,   // up
  turretAngle: 0,          // mouse-aim chin gun
  speed: 115,              // px/s
  rotSpeed: Math.PI * 1.2, // rad/s
  rotorSpin: 0,
  tailSpin: 0,
  rpm: 22,                 // main rotor rad/s
  tailRpm: 44,             // tail rotor rad/s
};

const keys = new Set();
let mouse = { x: W/2, y: H/2 };

canvas.tabIndex = 0;
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
});
canvas.addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); });
canvas.addEventListener('keyup', e => { keys.delete(e.key.toLowerCase()); });

/* ----------------------------------
   Draw helpers
---------------------------------- */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

function drawSprite(spriteCanvas, x, y, angleRad, scale=1) {
  const w = spriteCanvas.width, h = spriteCanvas.height;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angleRad);
  ctx.scale(scale, scale);
  ctx.translate(-w/2, -h/2);
  ctx.drawImage(spriteCanvas, 0, 0);
  ctx.restore();
}

function drawMainRotor(x, y, bodyAngle, rotorAngle, scale=1) {
  const w = rotorCanvas.width, h = rotorCanvas.height;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(bodyAngle + Math.PI/2); // align to body frame
  ctx.rotate(rotorAngle);            // spin within body frame
  ctx.scale(scale, scale);
  ctx.translate(-w/2, -h/2);
  ctx.drawImage(rotorCanvas, 0, 0);
  ctx.restore();
}

function drawTailRotor(x, y, bodyAngle, tailAngle, scale=1) {
  // Tail offset in BODY LOCAL pixels (up-facing body):
  // near front/top (nose up), tail stub to the right side near y=2
  const localOffset = { x: 6, y: -9 }; // relative to sprite center (12,12) -> (18,3)
  const w = tailCanvas.width, h = tailCanvas.height;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(bodyAngle + Math.PI/2); // into body frame
  ctx.scale(scale, scale);
  // translate to local tail-rotor mount
  ctx.translate(localOffset.x, localOffset.y);
  // spin tail rotor
  ctx.rotate(tailAngle);
  ctx.translate(-w/2, -h/2);
  ctx.drawImage(tailCanvas, 0, 0);
  ctx.restore();
}

function drawChinGun(x, y, bodyAngle, turretWorldAngle, scale=1) {
  // Chin mount offset under nose
  const localOffset = { x: 0, y: -8 };
  const w = gunCanvas.width, h = gunCanvas.height;
  const rel = turretWorldAngle - bodyAngle; // rotate from body-forward to aim
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(bodyAngle + Math.PI/2); // into body frame (sprite up = forward)
  ctx.scale(scale, scale);
  ctx.translate(localOffset.x, localOffset.y);
  ctx.rotate(rel);
  ctx.translate(-w/2, -h/2);
  ctx.drawImage(gunCanvas, 0, 0);
  ctx.restore();
}

function drawShadow(x, y, wobble=0) {
  ctx.save();
  ctx.translate(x, y + 7 + wobble);
  ctx.scale(1.5, 0.65);
  ctx.beginPath();
  ctx.arc(0, 0, (SPR_W*SCALE*0.46), 0, Math.PI*2);
  ctx.fillStyle = COLORS.shadow;
  ctx.fill();
  ctx.restore();
}

/* ----------------------------------
   Loop
---------------------------------- */
let last = performance.now();
function loop(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  // input → rotation + movement (same as tank)
  const turn = (keys.has('a') ? -1 : 0) + (keys.has('d') ? 1 : 0);
  heli.bodyAngle += turn * heli.rotSpeed * dt;

  const forward = (keys.has('w') ? 1 : 0) + (keys.has('s') ? -1 : 0);
  if (forward !== 0) {
    heli.x += Math.cos(heli.bodyAngle) * heli.speed * forward * dt;
    heli.y += Math.sin(heli.bodyAngle) * heli.speed * forward * dt;
  }

  // bounds
  const r = (SPR_W * SCALE) * 0.5 + 6;
  heli.x = clamp(heli.x, r, W - r);
  heli.y = clamp(heli.y, r, H - r);

  // mouse-aim chin gun
  const dx = mouse.x - heli.x;
  const dy = mouse.y - heli.y;
  heli.turretAngle = Math.atan2(dy, dx);

  // rotors spin (constant rpm with slight boost while moving)
  const rpmBoost = 3 * Math.abs(forward);
  heli.rotorSpin += (heli.rpm + rpmBoost) * dt;
  heli.tailSpin  += (heli.tailRpm + rpmBoost*2) * dt;

  // subtle hover wobble
  const wobble = Math.sin(now * 0.006) * 1.2;

  // draw
  ctx.clearRect(0, 0, W, H);

  // faint grid
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = COLORS.grid;
  for (let i = 0; i <= W; i += 32) ctx.fillRect(i, 0, 1, H);
  for (let j = 0; j <= H; j += 32) ctx.fillRect(0, j, W, 1);
  ctx.globalAlpha = 1;

  // shadow
  drawShadow(heli.x, heli.y, wobble);

  // body
  drawSprite(bodyCanvas,  heli.x, heli.y + wobble*0.2, heli.bodyAngle + Math.PI/2, SCALE);

  // main rotor (above)
  drawMainRotor(heli.x, heli.y + wobble*0.2, heli.bodyAngle, heli.rotorSpin, SCALE);

  // tail rotor
  drawTailRotor(heli.x, heli.y + wobble*0.2, heli.bodyAngle, heli.tailSpin, SCALE);

  // chin gun (mouse-aim)
  drawChinGun(heli.x, heli.y + wobble*0.2, heli.bodyAngle, heli.turretAngle, SCALE);

  // soft glow over body (subtle)
  ctx.save();
  ctx.globalAlpha = 0.07;
  ctx.beginPath();
  ctx.ellipse(heli.x, heli.y - 6, 28, 10, 0, 0, Math.PI*2);
  ctx.fillStyle = COLORS.glow;
  ctx.fill();
  ctx.restore();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ----------------------------------
   Palette swap (optional): press 'p'
---------------------------------- */
window.addEventListener('keydown', (e)=>{
  if (e.key.toLowerCase() === 'p') { palette = randPalette(); rebuildSprites(); }
});
</script>
</body>
</html>
