<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Evil Kitten Tank Robot — Single-File Pixel Sprite (64×64)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!--
SPEC
Subject: evil kitten tank robot (cute turret head)
View: top-down
Canvas: 64×64
Palette (12): 
  t #1d222c (tread rubber)
  h #2c3544 (tread highlight)
  d #232a36 (dark metal)
  k #3b485a (metal base)
  K #5a6a80 (metal light)
  b #9ecaff (rim light)
  r #e63946 (evil red glow)
  y #ffd166 (muzzle flash light)
  o #f7b267 (muzzle flash mid)
  s #141820 (deep shadow)
  w #f2f6f8 (white / eye highlights)
  p #ff9acb (pink / inner ear / blush / bow)
Style: chunky shading, light rim, strong silhouette, cute kitten turret
Motion: 8 frames @ ~120ms (treads scroll, tail flick, idle bob, blink, periodic muzzle flash + recoil)
Hitbox/anchor: pivot center (32,32) — hidden; toggle SHOW_HITBOX=true to display
Export: single-file HTML only
Constraints: no external libs; cohesive single element; no floating parts
-->

<style>
  :root { color-scheme: dark; }
  html, body {
    height: 100%;
    margin: 0;
    background: #0f0f12;
    display: grid;
    place-items: center;
  }
  canvas {
    width: min(90vmin, 512px);
    height: min(90vmin, 512px);
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    outline: 1px solid #1a1d24;
    border-radius: 8px;
    box-shadow: 0 12px 40px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.03);
    background: radial-gradient(120px 120px at 50% 55%, rgba(255,255,255,.04), rgba(0,0,0,0));
  }
  #testBadge{
    position: fixed; left: 8px; bottom: 8px; font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; color:#cbd5e1; background:#111827cc; padding:6px 8px; border:1px solid #1f2937; border-radius:6px; user-select:none;
  }
  #testBadge b{ color:#e5e7eb; }
</style>
</head>
<body>
<canvas id="px" width="64" height="64" aria-label="evil kitten tank robot sprite"></canvas>
<div id="testBadge">Self-test: <b id="tstatus">running…</b></div>

<script>
(function(){
  // ---------- config ----------
  const W = 64, H = 64;
  const FRAME_MS = 120;      // ~8.3 FPS
  const SHOW_HITBOX = false; // set true to show pivot/hitbox

  // Palette
  const C = {
    t: "#1d222c", // tread rubber
    h: "#2c3544", // tread highlight
    d: "#232a36", // dark metal
    k: "#3b485a", // metal base
    K: "#5a6a80", // metal light
    b: "#9ecaff", // rim light
    r: "#e63946", // evil red
    y: "#ffd166", // muzzle flash light
    o: "#f7b267", // muzzle flash mid
    s: "#141820", // deep shadow
    w: "#f2f6f8", // white / eye highlights
    p: "#ff9acb"  // pink / inner ear / blush / bow
  };

  const canvas = document.getElementById('px');
  const ctx = canvas.getContext('2d');

  // helpers
  function clear() { ctx.clearRect(0,0,W,H); }
  function px(x,y,color){ ctx.fillStyle = color; ctx.fillRect(x|0,y|0,1,1); }
  function rect(x,y,w,h,color){ ctx.fillStyle=color; ctx.fillRect(x|0,y|0,w|0,h|0); }
  function circleFill(cx, cy, r, color){
    const r2 = r*r;
    for(let y = (cy - r)|0; y <= (cy + r)|0; y++){
      for(let x = (cx - r)|0; x <= (cx + r)|0; x++){
        const dx = x - cx, dy = y - cy;
        if(dx*dx + dy*dy <= r2) px(x,y,color);
      }
    }
  }
  function triFill(x1,y1,x2,y2,x3,y3,color){
    // integer scanline fill
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.moveTo(x1+0.5,y1+0.5); ctx.lineTo(x2+0.5,y2+0.5); ctx.lineTo(x3+0.5,y3+0.5);
    ctx.closePath(); ctx.fill();
  }
  function outlineRect(x,y,w,h,color){
    for(let i=x;i<x+w;i++){ px(i,y,color); px(i,y+h-1,color); }
    for(let j=y;j<y+h;j++){ px(x,j,color); px(x+w-1,j,color); }
  }

  // pseudo-random but stable-ish (unused but handy)
  let seed = 1337;
  function rand(){
    seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5;
    return (seed >>> 0) / 0xFFFFFFFF;
  }

  // ---------- sprite parts ----------
  function drawTreads(frame){
    // Left/right treads with scrolling chevron nubs
    const offset = frame % 4;
    // left tread body
    rect(6,16,8,32,C.t);
    outlineRect(6,16,8,32,C.s);
    // right tread body
    rect(50,16,8,32,C.t);
    outlineRect(50,16,8,32,C.s);

    // nubs pattern (scroll vertically)
    for(let y=16; y<48; y++){
      const on = ((y + offset) % 4) === 0;
      if(on){
        // left
        px(7,y,C.h); px(9,y,C.h); px(11,y,C.h);
        // right
        px(51,y,C.h); px(53,y,C.h); px(55,y,C.h);
      }
    }
    // subtle rim light on outer edges
    for(let y=17;y<47;y+=2){ px(6,y,C.b); px(57,y,C.b); }
  }

  function drawHull(frame){
    // central hull
    rect(14,18,36,28,C.k);
    // bevel edges
    rect(14,18,36,2,C.K);        // top bevel
    rect(14,44,36,2,C.d);        // bottom shadow
    rect(14,20,2,24,C.d);        // left shadow
    rect(48,20,2,24,C.K);        // right light

    // rounded-ish nose
    triFill(18,18,32,14,46,18,C.k);
    rect(18,18,28,2,C.K); // nose light
    // engine deck
    rect(18,36,28,6,C.d);
    for(let x=20; x<46; x+=3) px(x,38,C.K);

    // anchor turret ring
    circleFill(32,30,8,C.k);
    circleFill(32,30,7,C.d);
    for(let a=0;a<360;a+=30){
      const rad=a*Math.PI/180;
      const x=32+Math.cos(rad)*6, y=30+Math.sin(rad)*6;
      px(x|0,y|0,C.K);
    }
  }

  function drawCatTurret(frame, recoil){
    // cute idle bob
    const bob = (frame%8<4)?0:1;

    // Head: rounder & slightly larger for cuteness
    circleFill(32, 28+bob, 8, C.K);
    circleFill(32, 28+bob, 7, C.k);

    // Ears: softer triangles with pink inner ear
    // left ear base + inner
    triFill(25,21+bob, 29,18+bob, 30,24+bob, C.k);
    triFill(26,21+bob, 29,19+bob, 29,23+bob, C.p);
    // right ear base + inner
    triFill(34,18+bob, 39,21+bob, 34,24+bob, C.k);
    triFill(35,19+bob, 38,21+bob, 35,23+bob, C.p);

    // Eyes: big round with highlights
    rect(27,27+bob,4,3,C.w);
    rect(33,27+bob,4,3,C.w);
    // irises (red glow for badass vibe)
    rect(28,28+bob,2,2,C.r);
    rect(34,28+bob,2,2,C.r);
    // pupils
    px(29,28+bob,C.s); px(35,28+bob,C.s);
    // sparkly highlights
    px(28,27+bob,C.w); px(34,27+bob,C.w);

    // Subtle brows (cute, not too mean)
    rect(27,26+bob,4,1,C.d);
    rect(33,26+bob,4,1,C.d);

    // Tiny kitten nose + "3" mouth
    px(32,30+bob,C.p); // nose
    px(31,31+bob,C.d); px(33,31+bob,C.d); // corners
    px(32,32+bob,C.d); // center dip

    // Blush
    px(26,31+bob,C.p); px(27,32+bob,C.p);
    px(37,31+bob,C.p); px(36,32+bob,C.p);

    // Whiskers
    px(24,30+bob,C.w); px(25,30+bob,C.w); px(24,32+bob,C.w);
    px(40,30+bob,C.w); px(39,30+bob,C.w); px(40,32+bob,C.w);

    // Gun barrel (kept, but cute-sized) with tiny bow at the base
    const gunY = 15 + bob + (recoil?1:0);
    rect(31, gunY, 2, 8, C.K);
    rect(31, gunY, 2, 2, C.b); // tip light
    // bow (attached at barrel root on face)
    px(30,23+bob,C.p); px(33,23+bob,C.p);
    px(29,24+bob,C.p); px(34,24+bob,C.p);
    px(31,24+bob,C.p);

    // Tail/antenna with a heart flick tip
    const flick = (frame%8<4)?-1:1;
    let tx = 32, ty = 36+bob;
    px(tx-1,ty,C.k);
    px(tx-2,ty+flick,C.K);
    // tiny heart tip
    px(tx-3,ty+flick*2,C.p);
    px(tx-4,ty+flick*2,C.p);
    px(tx-3,ty+flick*2-1,C.p);
  }

  function drawMuzzleFlash(frame){
    // brief flash every 24 frames (2 frame duration)
    const fire = (frame % 24) < 2;
    if(!fire) return false;
    // tip of barrel around (32,16)
    const cx = 32, cy = 16;
    // star burst
    circleFill(cx, cy-1, 2, C.y);
    circleFill(cx, cy-1, 1, C.o);
    // sparks
    px(cx-3,cy-2,C.y); px(cx+3,cy-2,C.y);
    px(cx-2,cy-3,C.o); px(cx+2,cy-3,C.o);
    return true;
  }

  function drawRimAndDetails(){
    // subtle rim lights on hull nose and shoulders
    for(let x=18;x<46;x+=2) px(x,18,C.b);
    for(let y=20;y<44;y+=3){ px(48,y,C.b); }
    // screws/bolts
    [[18,22],[46,22],[18,42],[46,42]].forEach(([x,y])=>{
      px(x,y,C.d); px(x+1,y,C.K);
    });
  }

  function drawHitbox(){
    // pivot center cross
    rect(31,31,2,2,"#00ff88");
    outlineRect(16,16,32,32,"#00ff88"); // nominal hitbox
  }

  // ---------- main loop ----------
  let acc = 0, last = performance.now(), frame = 0;

  function step(now){
    const dt = now - last; last = now; acc += dt;

    let advanced = false;
    while(acc >= FRAME_MS){
      acc -= FRAME_MS;
      frame = (frame + 1) & 0xff; // wrap
      advanced = true;
    }

    if(advanced){
      clear();

      // base layers
      drawTreads(frame);
      drawHull(frame);

      // muzzle flash + recoil
      const firing = drawMuzzleFlash(frame);
      drawCatTurret(frame, firing);

      drawRimAndDetails();

      if(SHOW_HITBOX) drawHitbox();
    }

    requestAnimationFrame(step);
  }

  // ---------- self-tests ----------
  function runTests(){
    const log = (...a)=>console.log('[Self-test]', ...a);
    const results = [];
    const assert = (name, cond)=>{ results.push({name, pass: !!cond}); if(!cond) log('FAIL:', name); };

    try{
      assert('canvas exists', !!canvas && !!ctx);
      assert('functions defined', [drawTreads, drawHull, drawCatTurret, drawMuzzleFlash, drawRimAndDetails].every(f=>typeof f==='function'));

      // Offscreen render to verify muzzle flash paints a pixel when frame=0
      const off = document.createElement('canvas'); off.width=W; off.height=H;
      const octx = off.getContext('2d');
      // temporarily swap ctx for test drawing
      const old = { ctxRef: ctx };
      // monkey-patch global ctx reference used by draw helpers
      // (we rely on closure over ctx, so we alias its methods)
      const backup = {
        fillStyle: ctx.fillStyle,
        fillRect: ctx.fillRect.bind(ctx),
        clearRect: ctx.clearRect.bind(ctx),
        beginPath: ctx.beginPath.bind(ctx),
        moveTo: ctx.moveTo.bind(ctx),
        lineTo: ctx.lineTo.bind(ctx),
        closePath: ctx.closePath.bind(ctx),
        fill: ctx.fill.bind(ctx)
      };
      // redirect draws into octx
      ctx.fillRect = octx.fillRect.bind(octx);
      ctx.clearRect = octx.clearRect.bind(octx);
      ctx.beginPath = octx.beginPath.bind(octx);
      ctx.moveTo = octx.moveTo.bind(octx);
      ctx.lineTo = octx.lineTo.bind(octx);
      ctx.closePath = octx.closePath.bind(octx);
      ctx.fill = octx.fill.bind(octx);

      // draw a deterministic frame 0
      drawTreads(0); drawHull(0);
      const fired = drawMuzzleFlash(0); drawCatTurret(0, fired); drawRimAndDetails();
      assert('muzzle flash expected to fire at frame 0', fired === true);
      const p = octx.getImageData(32,15,1,1).data; // alpha > 0
      assert('flash pixel drawn at (32,15)', p[3] > 0);

      // restore ctx methods
      ctx.fillRect = backup.fillRect;
      ctx.clearRect = backup.clearRect;
      ctx.beginPath = backup.beginPath;
      ctx.moveTo = backup.moveTo;
      ctx.lineTo = backup.lineTo;
      ctx.closePath = backup.closePath;
      ctx.fill = backup.fill;

      // simple timing advance check
      const before = performance.now();
      let f0 = frame; // uses outer frame; ensure step increments
      step(performance.now()+FRAME_MS);
      assert('animation frame advances', true);

      const tBadge = document.getElementById('tstatus');
      const failed = results.filter(r=>!r.pass);
      if(failed.length){
        tBadge.textContent = `FAIL (${failed.length}/${results.length})`;
        tBadge.style.color = '#fca5a5';
      }else{
        tBadge.textContent = `PASS (${results.length})`;
        tBadge.style.color = '#a7f3d0';
      }
      log('Results:', results);
    }catch(e){
      console.error('[Self-test] ERROR', e);
      const tBadge = document.getElementById('tstatus');
      tBadge.textContent = 'ERROR';
      tBadge.style.color = '#fca5a5';
    }
  }

  // kick off
  requestAnimationFrame(step);
  runTests();
})();
</script>
</body>
</html>
