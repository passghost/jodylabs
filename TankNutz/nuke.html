<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pixel Sprite — Nuclear Explosion (64×64, 15 frames @120ms)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --scale: 8; }
  *{ box-sizing:border-box; }
  html,body{
    margin:0; height:100%; background:#0d0f14; color:#cfd3da; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
  }
  main{
    min-height:100%; display:grid; place-items:center; gap:16px; padding:12px;
  }
  canvas{
    width: calc(64px * var(--scale));
    height: calc(64px * var(--scale));
    image-rendering: pixelated;
    outline: 1px solid #2a2f3a;
    background:#0d0f14;
  }
  .meta{ font-size:12px; opacity:.85; text-align:center; line-height:1.3; }
  .meta code{ background:#151821; padding:2px 6px; border-radius:6px; }
  .hint{ font-size:11px; opacity:.7; }
</style>
</head>
<body>
<main>
  <canvas id="anim" width="64" height="64"></canvas>
  <div class="meta">
    <div><strong>Subject:</strong> Nuclear explosion</div>
    <div><strong>View:</strong> side &middot; <strong>Canvas:</strong> 64×64 &middot; <strong>Frames:</strong> 15 &middot; <strong>FPS:</strong> ~8.33 (120ms)</div>
    <div><strong>Palette (8):</strong> <code>#0d0f14</code> <code>#1f232b</code> <code>#3a3f4b</code> <code>#7a3e00</code> <code>#d16d00</code> <code>#ffb800</code> <code>#fff4a3</code> <code>#8a7760</code></div>
    <div><strong>Style:</strong> chunky shading, rim light, strong silhouette &middot; <strong>Hitbox/anchor:</strong> pivot center (32, 56)</div>
    <div class="hint">Click canvas to pause / resume</div>
  </div>
</main>

<script>
(() => {
  // ---- Spec (for quick tweaking) -------------------------------------------
  const W = 64, H = 64, FRAMES = 15, FRAME_MS = 120;

  // ---- Palette --------------------------------------------------------------
  // 0 bg, 1 ground dark, 2 ground mid, 3 orange dark, 4 orange mid,
  // 5 bright, 6 rim light, 7 smoke
  const PAL_HEX = [
    "#0d0f14", "#1f232b", "#3a3f4b",
    "#7a3e00", "#d16d00", "#ffb800",
    "#fff4a3", "#8a7760"
  ];
  const PAL = PAL_HEX.map(hexToRGBA);

  // ---- Canvas setup ---------------------------------------------------------
  const view = document.getElementById("anim");
  const vctx = view.getContext("2d", { alpha:false });
  vctx.imageSmoothingEnabled = false;

  const off = document.createElement("canvas");
  off.width = W; off.height = H;
  const ctx = off.getContext("2d", { alpha:false });
  ctx.imageSmoothingEnabled = false;

  // ---- Tiny helpers ---------------------------------------------------------
  function hexToRGBA(hex){
    const n = hex.replace('#','');
    const bigint = parseInt(n, 16);
    const r = (n.length===3) ? ((bigint>>8)&0xF)*17 : (bigint>>16)&255;
    const g = (n.length===3) ? ((bigint>>4)&0xF)*17 : (bigint>>8)&255;
    const b = (n.length===3) ? ((bigint>>0)&0xF)*17 : (bigint>>0)&255;
    return [r,g,b,255];
  }
  function makeImageData(){ return ctx.createImageData(W, H); }
  function pset(img, x, y, ci){
    if(x<0||y<0||x>=W||y>=H) return;
    const i = (y*W + x) * 4;
    const c = PAL[ci];
    img.data[i+0]=c[0]; img.data[i+1]=c[1]; img.data[i+2]=c[2]; img.data[i+3]=c[3];
  }
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const easeOut=(t)=>1-Math.pow(1-t,2);
  const easeInOut=(t)=>t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;

  // Filled ellipse membership
  function inEllipse(x,y,cx,cy,rx,ry){
    const dx = (x-cx)/rx, dy = (y-cy)/ry;
    return dx*dx + dy*dy <= 1;
  }
  // Ring (approx 1px/2px thick)
  function inRing(x,y,cx,cy,r,thick){
    const dx=x-cx, dy=y-cy;
    const d = Math.sqrt(dx*dx+dy*dy);
    return d>=r-thick && d<=r+thick;
  }

  // ---- Frame renderer -------------------------------------------------------
  function drawFrame(f){
    const t = f/(FRAMES-1);                 // 0..1
    const im = makeImageData();

    // Background
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        pset(im,x,y,0);
      }
    }

    // Ground (thick band at bottom for "no floating parts")
    for(let y=58;y<H;y++){
      for(let x=0;x<W;x++){
        // simple uneven ground shading
        const band = (y<60)?2:1;
        pset(im,x,y, band);
      }
    }

    // Shockwave ring on ground
    {
      const r = lerp(0, 28, easeOut(t));
      for(let y=56;y<64;y++){
        for(let x=0;x<W;x++){
          if(inRing(x,y,32,59,r,1)){
            pset(im,x,y,7); // smoke ring
          }
        }
      }
    }

    // Cloud geometry (cap + stem), phases stitched smoothly
    const rise = easeInOut(Math.min(1, t/0.55));     // how high the cap rises
    const spread = easeOut(Math.max(0, (t-0.25)/0.75)); // lateral spread
    const thicken = easeOut(Math.max(0,(t-0.35)/0.65)); // stem thickening

    const capCY = Math.round(48 - 18*rise);          // vertical position of cap center
    const capRX = 6 + Math.round(18*spread);         // horizontal radius
    const capRY = 4 + Math.round(9*spread);          // vertical radius

    const stemTopY = Math.min(56, capCY + Math.max(0, Math.round(2 - 4*spread)));
    const stemBotY = 58;
    const stemTopW = 3 + Math.round(2*spread);
    const stemBotW = stemTopW + Math.round(4*thicken);

    // Draw stem (tapered column)
    for(let y=stemTopY; y<=stemBotY; y++){
      const k = (y-stemTopY)/Math.max(1,(stemBotY-stemTopY));
      const halfW = Math.round(lerp(stemTopW, stemBotW, k));
      for(let x=32-halfW; x<=32+halfW; x++){
        // core vs edge shading
        const edge = (x===32-halfW || x===32+halfW);
        pset(im,x,y, edge ? 3 : 4);
      }
    }

    // Cap (smoke/heat bulb)
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(inEllipse(x,y,32,capCY,capRX,capRY)){
          // distance from cap center -> shade
          const dx = (x-32)/capRX, dy = (y-capCY)/capRY;
          const d = Math.sqrt(dx*dx+dy*dy);
          // Rim light along the top/outer edge
          const rimZone = (d>0.85 && y<=capCY);
          const hotCore = (d<0.45); // inner
          if(rimZone){
            pset(im,x,y,6); // rim highlight
          }else if(hotCore){
            // inner hot glow grading to bright
            const hot = (d<0.28) ? 6 : 5;
            pset(im,x,y,hot);
          }else{
            // mid orange body
            pset(im,x,y,4);
          }
        }
      }
    }

    // Neck flare (where cap meets stem)
    {
      const neckY = clamp(capCY + capRY - 1, 0, H-1);
      for(let x=32-capRX; x<=32+capRX; x++){
        if(x>=0 && x<W) pset(im,x,neckY,5);
      }
    }

    // Sooty overcast on the cap underside as it grows
    {
      const alpha = spread; // 0..1
      const y0 = clamp(capCY + Math.round(capRY*0.25), 0, H-1);
      for(let y=y0; y<=capCY+capRY; y++){
        const k = (y - y0)/Math.max(1,(capRY));
        for(let x=32-capRX; x<=32+capRX; x++){
          // light dither to smoke color, chunky feel
          if(((x^y)&1) && Math.random()<alpha*0.25){
            pset(im,x,y,7);
          }
        }
      }
    }

    // Base dust poof (connected to stem so it stays one cohesive element)
    {
      const rx = Math.round(10 + 10*spread);
      const ry = 3;
      for(let y=56; y<60; y++){
        for(let x=32-rx; x<=32+rx; x++){
          if(inEllipse(x,y,32,58,rx,ry)){
            if(((x+y)&3)===0) pset(im,x,y,7);
          }
        }
      }
    }

    // Commit to offscreen, then present scaled to view canvas
    ctx.putImageData(im,0,0);
    vctx.clearRect(0,0,W,H);
    vctx.drawImage(off, 0, 0, W, H, 0, 0, view.width, view.height);
  }

  // ---- Animation loop -------------------------------------------------------
  let frame = 0, playing = true;
  drawFrame(frame);
  const timer = setInterval(() => {
    if(!playing) return;
    frame = (frame + 1) % FRAMES;
    drawFrame(frame);
  }, FRAME_MS);

  // Pause/Resume on click
  view.addEventListener('click', () => { playing = !playing; });

})();
</script>
</body>
</html>
