<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pixel Health Hearts — 2×2 Grid (HTML-only)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --scale: 6; }
  * { box-sizing: border-box; }
  html, body {
    height: 100%;
    background: #0e0f13;
    color: #cfd3da;
    margin: 0;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
  }
  .wrap {
    min-height: 100%;
    display: grid;
    place-items: center;
    padding: 24px;
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(2, calc(48px * var(--scale)));
    grid-auto-rows: calc(48px * var(--scale));
    gap: 18px;
  }
  canvas.pixel {
    width: calc(48px * var(--scale));
    height: calc(48px * var(--scale));
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    display: block;
    background: linear-gradient(#0f1016, #0a0b10);
    border-radius: 12px;
    box-shadow:
      0 10px 30px rgba(0,0,0,.6),
      inset 0 0 0 2px rgba(255,255,255,.03);
  }
  .label {
    position: absolute;
    inset: auto auto 8px 10px;
    font-size: 12px;
    color: #9aa0ab;
    letter-spacing: .02em;
  }
  .cell {
    position: relative;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="grid" id="grid">
      <div class="cell">
        <canvas class="pixel" width="48" height="48" data-variant="classic" aria-label="Red health heart"></canvas>
        <div class="label">Classic</div>
      </div>
      <div class="cell">
        <canvas class="pixel" width="48" height="48" data-variant="medic" aria-label="Red heart with medical cross"></canvas>
        <div class="label">Medic</div>
      </div>
      <div class="cell">
        <canvas class="pixel" width="48" height="48" data-variant="vital" aria-label="Green vitality heart"></canvas>
        <div class="label">Vital</div>
      </div>
      <div class="cell">
        <canvas class="pixel" width="48" height="48" data-variant="mend" aria-label="Purple mending heart"></canvas>
        <div class="label">Mend</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---- Config ----
  const FRAME_MS = 120;                 // 6 frames, 120ms
  const STEPS = [0.00, 0.45, 1.00, 0.45, 0.00, -0.20]; // heart-beat curve
  const SIZE_MAIN = 48;                 // main canvas size
  const LOWRES = 24;                    // offscreen render (pixel-chunky source)

  // Palettes per variant: outline, dark, mid, light, rim, glow
  const palettes = {
    classic: { outline:"#3b0d12", dark:"#8b0f1a", mid:"#b51625", light:"#ff4a56", rim:"#ffe4e8", glow:"#ff2a3a" },
    medic:   { outline:"#3b0d12", dark:"#8b101d", mid:"#b81e2a", light:"#ff5c68", rim:"#fff2f4", glow:"#ff2a3a" },
    vital:   { outline:"#0f2e1a", dark:"#0c6a32", mid:"#1aa24c", light:"#6cf09b", rim:"#e3ffe5", glow:"#46ff88" },
    mend:    { outline:"#2a123d", dark:"#5a2796", mid:"#8b3fd8", light:"#d7a8ff", rim:"#f4e9ff", glow:"#b06bff" },
  };

  // Utility: create offscreen low-res canvas
  function makeLowres() {
    const c = document.createElement('canvas');
    c.width = LOWRES; c.height = LOWRES;
    return c;
  }

  // Heart vector path (centered), tuned for compact pixel presence
  function heartPath(ctx, cx, cy, s) {
    // s ≈ "radius" for lobes; bottom point at cy + s*1.1
    ctx.moveTo(cx, cy + s * 0.95);
    ctx.bezierCurveTo(cx + s, cy + s * 0.55, cx + s * 1.05, cy - s * 0.35, cx, cy - s * 0.15);
    ctx.bezierCurveTo(cx - s * 1.05, cy - s * 0.35, cx - s, cy + s * 0.55, cx, cy + s * 0.95);
  }

  function posterizedGradient(ctx, topY, bottomY, colors) {
    // 3-stop chunky gradient
    const g = ctx.createLinearGradient(0, topY, 0, bottomY);
    g.addColorStop(0.00, colors.light);
    g.addColorStop(0.55, colors.mid);
    g.addColorStop(1.00, colors.dark);
    return g;
  }

  function drawHeartLowRes(ctx, palette, beat, variant) {
    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2 + 0.5);

    const base = 9.5;
    const s = base * (1 + 0.14 * beat); // pulse scale

    // Soft outer glow (expands/brightens on beat)
    ctx.globalAlpha = 0.35 * (0.4 + 0.6 * (beat > 0 ? beat : 0));
    ctx.fillStyle = palette.glow;
    ctx.beginPath(); heartPath(ctx, 0, 0, s + 1.8); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 1;

    // Outline
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = palette.outline;
    ctx.lineWidth = 3;
    ctx.beginPath(); heartPath(ctx, 0, 0, s); ctx.closePath(); ctx.stroke();

    // Fill (chunky tri-stop gradient)
    ctx.fillStyle = posterizedGradient(ctx, -s, s, palette);
    ctx.beginPath(); heartPath(ctx, 0, 0, s - 0.9); ctx.closePath(); ctx.fill();

    // Rim light (upper-left) within heart clip
    ctx.save();
    ctx.beginPath(); heartPath(ctx, 0, 0, s - 0.9); ctx.closePath(); ctx.clip();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.9;
    const rg = ctx.createRadialGradient(-s*0.7, -s*0.75, 0, -s*0.7, -s*0.75, s*1.0);
    rg.addColorStop(0.00, palette.rim);
    rg.addColorStop(0.25, "rgba(255,255,255,0.55)");
    rg.addColorStop(0.60, "rgba(255,255,255,0.0)");
    ctx.fillStyle = rg;
    ctx.fillRect(-s, -s, s*2, s*2);
    ctx.restore();

    // Specular "pixel" glints (tiny 1px blocks to enhance chunkiness)
    ctx.fillStyle = palette.rim;
    ctx.fillRect(Math.round(-s*0.25), Math.round(-s*0.50), 1, 1);
    ctx.fillRect(Math.round(-s*0.10), Math.round(-s*0.35), 1, 1);

    // Variants (in-heart overlays; cohesive, no floating parts)
    if (variant === 'medic') {
      // White medical cross centered (pixel blocks)
      ctx.fillStyle = "#ffffff";
      const w = 2, h = 2; // unit pixels
      // Vertical bar
      for (let y=-3; y<=3; y++) ctx.fillRect(-h, y, h*2, 1);
      // Horizontal bar
      for (let x=-3; x<=3; x++) ctx.fillRect(x, -h, 1, h*2);
    } else if (variant === 'vital') {
      // Subtle inner pulse ring (lighter band) to suggest regen
      ctx.save();
      ctx.globalAlpha = 0.40 * (0.5 + 0.5 * (beat > 0 ? beat : 0));
      ctx.strokeStyle = "#eafff0";
      ctx.lineWidth = 1;
      ctx.beginPath();
      const r = s * (0.55 + 0.10 * beat);
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    } else if (variant === 'mend') {
      // "Mending" crack seam (inside fill), with bright stitches on beat
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.strokeStyle = "#1c0c29";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, -s*0.2);
      ctx.lineTo(-2, -s*0.05);
      ctx.lineTo(1,  s*0.10);
      ctx.lineTo(-1, s*0.25);
      ctx.stroke();

      // stitches
      const blink = beat > 0.8 ? 1 : 0;
      ctx.strokeStyle = blink ? "#ffffff" : "#f3defe";
      ctx.beginPath();
      ctx.moveTo(-1.5, -s*0.08); ctx.lineTo(0.5, -s*0.02);
      ctx.moveTo(-0.2,  s*0.06); ctx.lineTo(1.8,  s*0.12);
      ctx.moveTo(-1.2,  s*0.19); ctx.lineTo(0.8,  s*0.25);
      ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  }

  // Main render loop: draw low-res, then copy to main at 48×48 with NN scaling
  const cells = Array.from(document.querySelectorAll('canvas.pixel')).map((c, i) => {
    const variant = c.dataset.variant;
    const off = makeLowres();
    const ctxLow = off.getContext('2d');
    const ctxMain = c.getContext('2d');
    // Fixed phase offsets so each heart animates slightly differently
    const phaseOffset = i * 2; // frames
    return { canvas: c, off, ctxLow, ctxMain, variant, phaseOffset };
  });

  function render(t) {
    for (const item of cells) {
      const { ctxLow, ctxMain, off, phaseOffset, variant } = item;
      const frame = Math.floor((t / FRAME_MS)) % STEPS.length;
      const f = STEPS[(frame + phaseOffset) % STEPS.length];
      const palette =
        variant === 'classic' ? palettes.classic :
        variant === 'medic'   ? palettes.medic   :
        variant === 'vital'   ? palettes.vital   :
                                palettes.mend;

      // Draw low-res heart
      drawHeartLowRes(ctxLow, palette, f, variant);

      // Blit to main 48×48 with crisp edges
      ctxMain.save();
      ctxMain.clearRect(0, 0, SIZE_MAIN, SIZE_MAIN);
      ctxMain.imageSmoothingEnabled = false;
      ctxMain.drawImage(off, 0, 0, SIZE_MAIN, SIZE_MAIN);
      ctxMain.restore();
    }
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
})();
</script>
</body>
</html>
