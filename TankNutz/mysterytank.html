<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"/> <title>Top-Down Pixel Tank — THEME: &lt;smiley face&gt;</title> <style> :root { color-scheme: dark; } body { margin:0; background:#0b0e12; font:14px/1.2 system-ui, sans-serif; display:grid; place-items:center; height:100vh; } .wrap { background:#131922; border:1px solid #1f2734; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.03); padding:14px 14px 10px; } .title { color:#c9d4e6; font-weight:600; letter-spacing:.2px; margin:0 0 8px 2px; font-size:13px; opacity:.9;} #sprite { display:block; width:256px; height:256px; image-rendering: pixelated; background:#0e141c; border-radius:8px; outline:1px solid #263042; } .ui { display:flex; gap:8px; margin-top:10px; align-items:center; } button { appearance:none; border:none; padding:8px 12px; border-radius:10px; background:#1b2433; color:#d4def3; box-shadow: inset 0 0 0 1px #2a3953; cursor:pointer; font-weight:600; letter-spacing:.2px; } button:hover { box-shadow: inset 0 0 0 1px #395277; background:#212e42; } .hint { color:#9fb3d9; opacity:.85; font-size:12px; margin-left:6px; } </style> </head> <body> <div class="wrap"> <div class="title">Top-Down Tank Sprite — THEME: &lt;smiley face&gt;</div> <canvas id="sprite" width="256" height="256"></canvas> <div class="ui"> <button id="playPause">Pause</button> <button id="replay">Replay</button> <div class="hint">Press “H” to toggle hitbox/pivot overlay</div> </div> </div> <script> /* ===== Constants ===== */ const GRID=64, SCALE=4, FRAMES=24, FRAME_MS=60; const CENTER={x:32,y:32}, PIVOT=CENTER; const HITBOX={x:12,y:16,w:40,h:32}; const THEME = "<smiley face>"; /* ===== Canvas setup (offscreen logical buffer -> scaled to main) ===== */ const main = document.getElementById('sprite'); const mctx = main.getContext('2d', { alpha: false }); mctx.imageSmoothingEnabled = false; const buf = document.createElement('canvas'); buf.width = GRID; buf.height = GRID; const ctx = buf.getContext('2d', { alpha: false }); ctx.imageSmoothingEnabled = false; /* ===== Palette builder ===== */ function paletteForTheme(themeRaw){ const theme = (themeRaw||"").toLowerCase(); // base steel/rubber/shadow const outline = "#0a0a0c"; const black = "#000000"; const steelDD = "#2a3342"; const steelD = "#3a4760"; const steelM = "#506287"; const steelL = "#6f86b2"; const steelXL = "#9bb3dc"; const steelSpec = "#cfe2ff"; const rubber = "#111418"; const rubberHi = "#2b313a"; const shadow = "#0b0f16"; // defaults let accent1="#ffd21a", accent2="#111111", accent3="#ff9b1a", goldOrSpec="#ffd76a"; // mapping for common themes const t = theme.replace(/[<>]/g,'').trim(); if (t.includes("smiley")) { accent1="#ffd21a"; accent2="#111111"; accent3="#ff9b1a"; goldOrSpec="#ffe27a"; } else if (t.includes("america")||t.includes("usa")) { accent1="#2247ff"; accent2="#ffffff"; accent3="#d91f2a"; goldOrSpec="#f3c74a"; } else if (t.includes("desert")) { accent1="#c2a268"; accent2="#8b6b3a"; accent3="#e3c28a"; goldOrSpec="#f1d89a"; } else if (t.includes("arctic")) { accent1="#dfe9ff"; accent2="#7fb9ff"; accent3="#a2d4ff"; goldOrSpec="#eaf6ff"; } else if (t.includes("cyber")) { accent1="#ff3ba3"; accent2="#00ffd6"; accent3="#26a8ff"; goldOrSpec="#ffe14a"; } else if (t.includes("pirate")) { accent1="#0c0c0c"; accent2="#ece3c9"; accent3="#9a6c34"; goldOrSpec="#caa35a"; } return { outline, black, steelDD, steelD, steelM, steelL, steelXL, steelSpec, rubber, rubberHi, shadow, accent1, accent2, accent3, goldOrSpec }; } const PAL = paletteForTheme(THEME); /* ===== Pixel helpers ===== */ function px(c,x,y,w=1,h=1,color=PAL.steelM){ c.fillStyle=color; c.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); } function fillRect(c,x,y,w,h,color){ c.fillStyle=color; c.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); } function outlineRect(c,x,y,w,h,color){ x=Math.round(x); y=Math.round(y); w=Math.round(w); h=Math.round(h); px(c,x,y,w,1,color); px(c,x,y+h-1,w,1,color); px(c,x,y,1,h,color); px(c,x+w-1,y,1,h,color); } function fillCircle(c,xc,yc,r,color){ for(let y=-r;y<=r;y++){ const s = Math.floor(Math.sqrt(r*r - y*y)); c.fillStyle=color; c.fillRect(Math.round(xc)-s, Math.round(yc)+y, 2*s+1, 1); } } function circle(c,xc,yc,r,color){ for(let a=0;a<360;a+=2){ const rad=a*Math.PI/180; const x=xc+Math.cos(rad)*r, y=yc+Math.sin(rad)*r; px(c,Math.round(x),Math.round(y),1,1,color); } } function lineThin(c,x0,y0,x1,y1,color){ x0=Math.round(x0); y0=Math.round(y0); x1=Math.round(x1); y1=Math.round(y1); let dx=Math.abs(x1-x0), sx=x0<x1?1:-1; let dy=-Math.abs(y1-y0), sy=y0<y1?1:-1; let err=dx+dy; while(true){ px(c,x0,y0,1,1,color); if(x0===x1&&y0===y1) break; const e2=2*err; if(e2>=dy){ err+=dy; x0+=sx; } if(e2<=dx){ err+=dx; y0+=sy; } } } function lineThick(c,x0,y0,x1,y1,th,color){ const dx=x1-x0, dy=y1-y0; const len=Math.hypot(dx,dy)||1; const nx=-(dy/len), ny=(dx/len); const half=(th-1)/2; for(let i=-half;i<=half;i++){ const ox=nx*i, oy=ny*i; lineThin(c, Math.round(x0+ox), Math.round(y0+oy), Math.round(x1+ox), Math.round(y1+oy), color); } } function rot(x,y,a,cx=PIVOT.x,cy=PIVOT.y){ const s=Math.sin(a), co=Math.cos(a); const dx=x-cx, dy=y-cy; return { x: Math.round(cx + dx*co - dy*s), y: Math.round(cy + dx*s + dy*co) }; } /* ===== Theming decals ===== */ function drawSmiley(c,x,y,r,edge,fill,eye=PAL.accent2){ fillCircle(c,x,y,r,fill); circle(c,x,y,r,edge); // eyes px(c,x-2,y-1,2,2,eye); px(c,x+1,y-1,2,2,eye); // smile lineThin(c,x-4,y+2,x+4,y+2,edge); lineThin(c,x-3,y+3,x+3,y+3,edge); } /* ===== Track assembly ===== */ function drawTrackAssembly(side, phase, bounce){ const left = (side==="left"); const x0 = left ? 4 : GRID-4-8; // 8px wide belt const yTop = 12 + bounce; const yBot = GRID-10 + bounce; const beltW=8; // Belt rubber fillRect(ctx,x0,yTop,beltW,yBot-yTop, PAL.rubber); outlineRect(ctx,x0,yTop,beltW,yBot-yTop, PAL.outline); // Link plates (every ~3px), animated by phase const p = phase % 6; for(let y=yTop+(p%3); y<yBot; y+=3){ // upper & lower run plates px(ctx,x0+1,y, beltW-2,1, PAL.rubberHi); } // Inner guide teeth hints (center of belt) for(let y=yTop+((p+1)%6); y<yBot; y+=6){ px(ctx,x0 + Math.floor(beltW/2)-1, y, 2,1, PAL.steelXL); } // Road wheels (~5) const count=5; for(let i=0;i<count;i++){ const t=i/(count-1); const wx=x0 + Math.floor(beltW/2); const wy=Math.round(yBot-3 - t*(yBot - (yTop+14))); fillCircle(ctx,wx,wy,3, PAL.steelM); circle(ctx,wx,wy,3, PAL.outline); fillCircle(ctx,wx,wy,1, PAL.steelXL); } // Return rollers (~2) under top run const rollers=2; for(let i=0;i<rollers;i++){ const t=i/(rollers-1); const wx=x0 + Math.floor(beltW/2); const wy=yTop+3 + Math.round(t*10); fillCircle(ctx,wx,wy,2, PAL.steelD); circle(ctx,wx,wy,2, PAL.outline); } // Side-skirts above tracks with rivets + theme pips const skirtY = yTop-6; fillRect(ctx,x0-1,skirtY,beltW+2,5, PAL.steelD); outlineRect(ctx,x0-1,skirtY,beltW+2,5, PAL.outline); // rivets for(let i=0;i<4;i++){ px(ctx,x0+1,skirtY+1+i%2,1,1,PAL.steelXL); px(ctx,x0+beltW-2,skirtY+3-(i%2),1,1,PAL.steelXL); } // theme pips px(ctx,x0+Math.floor(beltW/2)-1,skirtY+2,2,1,PAL.accent1); px(ctx,x0+Math.floor(beltW/2)-3,skirtY+2,1,1,PAL.accent3); px(ctx,x0+Math.floor(beltW/2)+2,skirtY+2,1,1,PAL.accent3); } /* ===== Hull ===== */ function drawHullDetailed(frame){ // Ground/shadow base fillRect(ctx,0,0,GRID,GRID,PAL.shadow); const bounce = ((Math.sin((frame/FRAMES)*Math.PI*2)>0)?1:0); // Tracks (phase offset per side) drawTrackAssembly("left", frame%6, bounce); drawTrackAssembly("right",(frame+3)%6, bounce); // Main hull slab const hx=12, hy=16, hw=40, hh=32; fillRect(ctx,hx,hy,hw,hh, PAL.steelM); outlineRect(ctx,hx,hy,hw,hh, PAL.outline); // Lighter mid-panel fillRect(ctx,hx+6,hy+8,hw-12,hh-16, PAL.steelL); outlineRect(ctx,hx+6,hy+8,hw-12,hh-16, PAL.steelD); // Glacis (front slope) for(let i=0;i<4;i++){ fillRect(ctx,hx+4+i,hy-1+i,hw-8-2*i,1, PAL.steelD); } // Rear engine bevel for(let i=0;i<3;i++){ fillRect(ctx,hx+5+i,hy+hh-i,hw-10-2*i,1, PAL.steelD); } // Tow hooks at front corners px(ctx,hx-1,hy+2,2,2,PAL.steelXL); outlineRect(ctx,hx-1,hy+2,2,2,PAL.outline); px(ctx,hx+hw-1,hy+2,2,2,PAL.steelXL); outlineRect(ctx,hx+hw-1,hy+2,2,2,PAL.outline); // Stowage boxes left/right fillRect(ctx,hx-3,hy+12,3,10,PAL.steelD); outlineRect(ctx,hx-3,hy+12,3,10,PAL.outline); fillRect(ctx,hx+hw,hy+12,3,10,PAL.steelD); outlineRect(ctx,hx+hw,hy+12,3,10,PAL.outline); // Rear deck grilles for(let i=0;i<6;i++){ px(ctx,hx+6+i*5,hy+hh-6,3,1,PAL.black); px(ctx,hx+6+i*5,hy+hh-5,3,1,PAL.steelDD); } // Panel lines & bolts for(let x=hx+4; x<hx+hw-4; x+=6){ px(ctx,x,hy+Math.floor(hh/2),1,1,PAL.steelDD); } for(let y=hy+4; y<hy+hh-4; y+=6){ px(ctx,hx+Math.floor(hw/2),y,1,1,PAL.steelDD); } // Rim-light highlights lineThin(ctx,hx+1,hy+1,hx+hw-2,hy+1,PAL.steelXL); lineThin(ctx,hx+1,hy+hh-2,hx+hw-2,hy+hh-2,PAL.steelXL); // Turret ring guard (fixed on hull) + visible teeth const rr=10; circle(ctx,PIVOT.x,PIVOT.y,rr, PAL.steelXL); for(let t=0;t<16;t++){ const ang=t*(Math.PI*2/16); const ix= Math.round(PIVOT.x + Math.cos(ang)*(rr-2)); const iy= Math.round(PIVOT.y + Math.sin(ang)*(rr-2)); px(ctx,ix,iy,1,1,PAL.steelXL); } // Roof band decal reserved for THEME const bandY=hy+6; fillRect(ctx,hx+4,bandY,hw-8,5,PAL.accent1); outlineRect(ctx,hx+4,bandY,hw-8,5,PAL.accent2); // repeating mini smileys across band for(let x=hx+6; x<hx+hw-8; x+=8){ drawSmiley(ctx,x,bandY+2,2,PAL.accent2,PAL.accent1,PAL.accent2); } // Side-skirt additional theme pips already added in track assemblies. } /* ===== Turret (rotates) ===== */ function drawTurret(angle, frame){ const cx=PIVOT.x, cy=PIVOT.y; const dirx = Math.sin(angle), diry = -Math.cos(angle); // up at 0 rad const nx = -diry, ny = dirx; // left normal // Turret disc fillCircle(ctx,cx,cy,9, PAL.steelD); circle(ctx,cx,cy,9, PAL.outline); // Directional highlight on disc (rotates visually) const hx = cx + Math.round(dirx*6), hy = cy + Math.round(diry*6); px(ctx,hx,hy,2,1,PAL.steelXL); px(ctx,hx-1,hy+1,4,1,PAL.steelL); // Cupola + hatch line fillCircle(ctx,cx+Math.round(nx*3),cy+Math.round(ny*3),3, PAL.steelM); circle(ctx,cx+Math.round(nx*3),cy+Math.round(ny*3),3, PAL.outline); lineThin(ctx,cx+Math.round(nx*1),cy+Math.round(ny*1),cx+Math.round(nx*5),cy+Math.round(ny*5), PAL.steelXL); // Periscopes/optics (two tiny) px(ctx, cx+Math.round(dirx*4)+Math.round(nx*2), cy+Math.round(diry*4)+Math.round(ny*2), 1,1, PAL.steelXL); px(ctx, cx+Math.round(dirx*4)-Math.round(nx*2), cy+Math.round(diry*4)-Math.round(ny*2), 1,1, PAL.steelXL); // Main barrel (~20px) with muzzle vents const startX = cx + Math.round(dirx*9), startY = cy + Math.round(diry*9); const endX = startX + Math.round(dirx*20), endY = startY + Math.round(diry*20); lineThick(ctx,startX,startY,endX,endY,3, PAL.steelM); // barrel outline hint lineThick(ctx,startX,startY,endX,endY,1, PAL.outline); // muzzle vents near tip const ventBaseX = endX - Math.round(dirx*3), ventBaseY = endY - Math.round(diry*3); lineThick(ctx, ventBaseX+Math.round(nx*1), ventBaseY+Math.round(ny*1), ventBaseX+Math.round(nx*3), ventBaseY+Math.round(ny*3), 1, PAL.black); lineThick(ctx, ventBaseX-Math.round(nx*1), ventBaseY-Math.round(ny*1), ventBaseX-Math.round(nx*3), ventBaseY-Math.round(ny*3), 1, PAL.black); // Coax MG parallel and offset const mgStartX = startX - Math.round(ny*0) + Math.round(nx* -3); const mgStartY = startY - Math.round(nx*0) + Math.round(ny* -3); const mgEndX = mgStartX + Math.round(dirx*14); const mgEndY = mgStartY + Math.round(diry*14); lineThick(ctx,mgStartX,mgStartY,mgEndX,mgEndY,1, PAL.steelXL); // Antenna with pennant (fluttering) const rearX = cx - Math.round(dirx*6) + Math.round(nx*6); const rearY = cy - Math.round(diry*6) + Math.round(ny*6); const antX = rearX + Math.round(nx*0), antY = rearY + Math.round(ny*0); const antTipX = antX + Math.round(dirx* -6), antTipY = antY + Math.round(diry* -6); lineThick(ctx,antX,antY,antTipX,antTipY,1, PAL.steelXL); // fluttering pennant (world wind → right), oscillate width const flutter = 1 + ((Math.sin(frame/FRAMES*2*Math.PI*2)+1)/2); // 1..2 const flagBaseX = antTipX, flagBaseY = antTipY; px(ctx, flagBaseX, flagBaseY, 1,1, PAL.accent2); // tiny triangle to the right lineThin(ctx, flagBaseX, flagBaseY, flagBaseX + 2 + Math.round(flutter), flagBaseY - 1, PAL.accent1); lineThin(ctx, flagBaseX, flagBaseY, flagBaseX + 2 + Math.round(flutter), flagBaseY + 1, PAL.accent3); // Rear ventilation slots on turret (parallel to barrel) const vent1sX = cx - Math.round(dirx*4) + Math.round(nx*2); const vent1sY = cy - Math.round(diry*4) + Math.round(ny*2); const vent1eX = vent1sX + Math.round(nx*3), vent1eY = vent1sY + Math.round(ny*3); lineThin(ctx,vent1sX,vent1sY,vent1eX,vent1eY,PAL.black); const vent2sX = cx - Math.round(dirx*5) - Math.round(nx*2); const vent2sY = cy - Math.round(diry*5) - Math.round(ny*2); const vent2eX = vent2sX + Math.round(nx*3), vent2eY = vent2sY + Math.round(ny*3); lineThin(ctx,vent2sX,vent2sY,vent2eX,vent2eY,PAL.black); // Tiny emblem on turret top (smiley) drawSmiley(ctx,cx,cy-1,2,PAL.accent2,PAL.accent1,PAL.accent2); } /* ===== Overlay ===== */ let showOverlay=false; function drawHitboxOverlay(show){ if(!show) return; outlineRect(ctx,HITBOX.x,HITBOX.y,HITBOX.w,HITBOX.h, "#00ffdd"); // pivot crosshair lineThin(ctx,PIVOT.x-4,PIVOT.y, PIVOT.x+4,PIVOT.y, "#00ffdd"); lineThin(ctx,PIVOT.x,PIVOT.y-4, PIVOT.x,PIVOT.y+4, "#00ffdd"); px(ctx,PIVOT.x,PIVOT.y,1,1,"#00ffdd"); } /* ===== Animation loop ===== */ let frame=0, timer=null, playing=true; function render(){ // clear logical buffer fillRect(ctx,0,0,GRID,GRID,PAL.shadow); // draw order: tracks -> hull -> turret -> highlights -> overlay drawHullDetailed(frame); const angle = (frame/FRAMES) * Math.PI*2; drawTurret(angle, frame); // subtle extra highlights (glints) px(ctx, 10,10,1,1, PAL.steelSpec); px(ctx, GRID-11, GRID-11,1,1, PAL.steelSpec); drawHitboxOverlay(showOverlay); // blit to main scaled canvas mctx.clearRect(0,0,main.width,main.height); mctx.imageSmoothingEnabled=false; mctx.drawImage(buf, 0,0,GRID,GRID, 0,0,GRID*SCALE,GRID*SCALE); frame = (frame+1)%FRAMES; } function start(){ if(timer) return; timer = setInterval(render, FRAME_MS); } function stop(){ if(timer){ clearInterval(timer); timer=null; }} /* ===== Controls ===== */ const btnPP = document.getElementById('playPause'); const btnReplay = document.getElementById('replay'); btnPP.addEventListener('click', ()=>{ if(playing){ stop(); btnPP.textContent="Play"; } else { start(); btnPP.textContent="Pause"; } playing=!playing; }); btnReplay.addEventListener('click', ()=>{ frame=0; if(!playing){ render(); } }); window.addEventListener('keydown', (e)=>{ if(e.key==='h' || e.key==='H'){ showOverlay=!showOverlay; } }); /* ===== Init ===== */ render(); start(); </script> </body> </html>