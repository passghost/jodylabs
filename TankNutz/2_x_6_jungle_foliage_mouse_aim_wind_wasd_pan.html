<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>4×2 Jungle People — Mouse-Aim Direction + WASD Pan</title>
<style>
  html, body { height: 100%; }
  body {
    margin: 0;
    display: grid;
    place-items: center;
    background: #0f0f12;
    color: #d7d7db;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    width: min(96vmin, 960px);
    height: min(70vmin, 540px);
    background: #0b0d0e radial-gradient(80% 140% at 50% 0%, rgba(50,120,90,.16), rgba(0,0,0,0));
    display: block;
    border-radius: 12px;
    box-shadow: inset 0 0 0 1px #26262e;
  }
  .hint {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    font-size: 12px; opacity: .6; letter-spacing: .2px; user-select: none;
  }
</style>
</head>
<body>
<canvas id="game" width="1200" height="675" aria-label="4x2 jungle people grid"></canvas>
<div class="hint">WASD: pan • Move mouse: everyone looks/aims that way • P: recolor</div>
<script>
/* ================================
   Setup
================================ */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const W = canvas.width, H = canvas.height;

// World camera (WASD) and shared look direction (mouse angle)
const cam = { x: 0, y: 0, speed: 160 };
const keys = new Set();
let mouse = { x: W/2, y: H/2 };

canvas.tabIndex = 0;
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top)  * (canvas.height / r.height);
});
canvas.addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); });
canvas.addEventListener('keyup',   e => { keys.delete(e.key.toLowerCase()); });

/* ================================
   Palette
================================ */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rint(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function junglePalette(){
  const g = 110 + rint(-10,25);
  const s = 45 + rint(-10,10);
  const l = 24 + rint(-6,8);
  return {
    leaf:      `hsl(${g} ${s+8}% ${l}%)`,
    leafDark:  `hsl(${g} ${s}% ${clamp(l-8,6,60)}%)`,
    cloth1:    `hsl(${(g+40)%360} 60% 42%)`,
    cloth2:    `hsl(${(g+180)%360} 55% 52%)`,
    skinLt:    '#f2c6a5',
    skinMd:    '#c78e64',
    skinDk:    '#8a5b39',
    hair:      '#2b221a',
    bandana:   '#d33',
    metal:     '#9ea4aa',
    shadow:    'rgba(0,0,0,.28)',
    grid:      '#000'
  };
}
let PAL = junglePalette();

/* ================================
   Grid + Tiles
================================ */
const COLS = 4, ROWS = 2;
const TILE_PX = 72;        // internal pixel art size
const SCALE = 2;           // onscreen scale inside tile
const GAP = 10;
const totalW = COLS * (TILE_PX*SCALE) + (COLS+1)*GAP;
const totalH = ROWS * (TILE_PX*SCALE) + (ROWS+1)*GAP;
const startX = (W - totalW)/2;
const startY = (H - totalH)/2;

function makeTileCanvas(){
  const c = document.createElement('canvas');
  c.width = TILE_PX; c.height = TILE_PX;
  const g = c.getContext('2d'); g.imageSmoothingEnabled = false;
  return { c, g };
}

/* ================================
   Pixel helpers
================================ */
function px(g,x,y,w=1,h=1,color='#fff'){ g.fillStyle = color; g.fillRect(x|0,y|0,w|0,h|0); }
function ellipseShadow(g, cx, cy, rx, ry, col){
  g.save(); g.translate(cx, cy); g.scale(rx, ry); g.beginPath(); g.arc(0,0,1,0,Math.PI*2); g.fillStyle = col; g.fill(); g.restore();
}

/* ================================
   Character base renderer
   - Draws body, head, arms; separate function to draw rotated arms/gun
================================ */
function drawBoots(g, x, y){ px(g,x-2,y,5,2,'#1a1a1a'); }
function drawLegs(g, x, y, tone){ px(g,x-1,y-6,2,6,tone); px(g,x+2,y-6,2,6,tone); }
function drawPants(g, x, y){ px(g,x-3,y-7,8,3,PAL.cloth1); }
function drawTorso(g, x, y, color){ px(g,x-4,y-14,9,7,color); }
function drawHead(g, x, y, skin){ px(g,x-3,y-21,7,7,skin); }
function drawHair(g, x, y){ px(g,x-3,y-21,7,2,PAL.hair); }
function drawBandana(g, x, y){ px(g,x-3,y-22,7,2,PAL.bandana); }
function drawVest(g, x, y){ px(g,x-4,y-14,9,7, PAL.cloth2); px(g,x-1,y-14,3,7, PAL.cloth1); }
function drawSatchel(g, x, y){ px(g,x+4,y-13,3,5, '#4a3b28'); }
function drawShoulderStrap(g, x, y){ for(let i=0;i<7;i++) px(g,x-5+i,y-14+i,1,1,'#4a3b28'); }

function drawRifle(g, cx, cy, ang){
  // very tiny rotated rifle using per-pixel stepping
  const len = 18; const steps = len; const vx=Math.cos(ang), vy=Math.sin(ang);
  for(let i=0;i<steps;i++){
    const x = cx + vx*i, y = cy + vy*i;
    px(g,x,y,1,1, i<3 ? '#3b2a1a' : (i>len-3?PAL.metal:'#221a14'));
  }
}
function drawPistol(g, cx, cy, ang){ const len=8, vx=Math.cos(ang), vy=Math.sin(ang);
  for(let i=0;i<len;i++){ const x=cx+vx*i, y=cy+vy*i; px(g,x,y,1,1, i>len-2?PAL.metal:'#222'); }
}

function drawArmsAiming(g, x, y, ang, skin){
  // anchor near chest
  const ax = x+1, ay = y-11;
  // front arm toward ang
  const len = 6, vx=Math.cos(ang), vy=Math.sin(ang);
  for(let i=0;i<len;i++) px(g, ax+vx*i, ay+vy*i, 1,1, skin);
  // rear arm for depth
  for(let i=0;i<len-1;i++) px(g, ax-1+vx*i*0.9, ay+1+vy*i*0.9, 1,1, skin);
}

/* ================================
   NPC factories (8 unique looks)
   Each returns update(time, lookAngle, lookMag)
================================ */
function makeCommando(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA, lookM)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    // ground shadow
    ellipseShadow(g, cx, baseY-1, 12, 3, PAL.shadow);
    const breathe = Math.sin(t*0.004)*1.2;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinDk); drawPants(g,cx,baseY);
    drawTorso(g,cx,baseY, PAL.cloth1); drawVest(g,cx,baseY); drawHead(g,cx,baseY, PAL.skinDk); drawHair(g,cx,baseY); drawBandana(g,cx,baseY);
    drawArmsAiming(g,cx,baseY+breathe,lookA, PAL.skinDk); drawRifle(g,cx+2,baseY-11+breathe,lookA);
  };
}
function makeScout(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 11, 3, PAL.shadow);
    const sway = Math.sin(t*0.005)*1.0;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinMd); drawPants(g,cx,baseY);
    drawTorso(g,cx,baseY, PAL.cloth2); drawHead(g,cx,baseY, PAL.skinMd); drawHair(g,cx,baseY);
    drawShoulderStrap(g,cx,baseY);
    drawArmsAiming(g,cx,baseY+sway,lookA, PAL.skinMd); drawPistol(g,cx+2,baseY-11+sway,lookA);
  };
}
function makeHeavy(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.8;
  return (t, lookA, lookM)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 13, 3.4, PAL.shadow);
    const wob = Math.sin(t*0.003)*0.8;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinDk); px(g,cx-4,baseY-7,10,4,'#3a3a3a'); // dark pants block
    drawTorso(g,cx,baseY, '#2d3b33'); drawSatchel(g,cx,baseY); drawHead(g,cx,baseY, PAL.skinDk); drawHair(g,cx,baseY);
    drawArmsAiming(g,cx,baseY+wob,lookA, PAL.skinDk); drawRifle(g,cx+1,baseY-11+wob,lookA);
  };
}
function makeMedic(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 11, 3, PAL.shadow);
    const b = Math.sin(t*0.004)*1.1;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinLt); drawPants(g,cx,baseY);
    drawTorso(g,cx,baseY, '#3f5148'); px(g,cx-1,baseY-12,3,3,'#d33'); // red cross patch
    drawHead(g,cx,baseY, PAL.skinLt); drawHair(g,cx,baseY);
    drawArmsAiming(g,cx,baseY+b,lookA, PAL.skinLt); drawPistol(g,cx+2,baseY-11+b,lookA);
  };
}
function makeVillager1(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 10.5, 3, PAL.shadow);
    const sway = Math.sin(t*0.004)*0.9;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinMd); px(g,cx-3,baseY-7,8,3,'#6b5b3a'); // skirt/shorts
    drawTorso(g,cx,baseY, '#5b7d64'); drawHead(g,cx,baseY, PAL.skinMd); // straw hat
    px(g,cx-4,baseY-22,9,2,'#caa84a'); px(g,cx-5,baseY-21,11,1,'#caa84a');
    drawArmsAiming(g,cx,baseY+sway,lookA, PAL.skinMd);
  };
}
function makeVillager2(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 10.5, 3, PAL.shadow);
    const sway = Math.cos(t*0.0035)*0.8;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinLt); px(g,cx-3,baseY-7,8,3,'#335c4a');
    drawTorso(g,cx,baseY, '#496b55'); drawHead(g,cx,baseY, PAL.skinLt);
    // sling bag
    for(let i=0;i<7;i++) px(g,cx-5+i,baseY-14+i,1,1,'#2a2a2a'); px(g,cx+4,baseY-10,3,4,'#2a2a2a');
    drawArmsAiming(g,cx,baseY+sway,lookA, PAL.skinLt);
  };
}
function makeGuide(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 11, 3, PAL.shadow);
    const b = Math.sin(t*0.0045)*1.0;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinDk); drawPants(g,cx,baseY);
    drawTorso(g,cx,baseY, '#355546'); drawHead(g,cx,baseY, PAL.skinDk);
    // machete on belt
    px(g,cx+4,baseY-10,4,1,PAL.metal); px(g,cx+7,baseY-11,1,3,'#3b2a1a');
    drawArmsAiming(g,cx,baseY+b,lookA, PAL.skinDk);
  };
}
function makeRadioOp(tile){
  const {g} = tile; const cx=TILE_PX/2, baseY=TILE_PX*0.78;
  return (t, lookA)=>{
    g.clearRect(0,0,TILE_PX,TILE_PX);
    ellipseShadow(g, cx, baseY, 11, 3, PAL.shadow);
    const wob = Math.sin(t*0.0038)*0.9;
    drawBoots(g,cx,baseY); drawLegs(g,cx,baseY, PAL.skinMd); drawPants(g,cx,baseY);
    drawTorso(g,cx,baseY, '#3b4e44'); drawHead(g,cx,baseY, PAL.skinMd); drawHair(g,cx,baseY);
    // radio backpack + antenna
    px(g,cx-7,baseY-13,4,6,'#2a2f34'); for(let i=0;i<7;i++) px(g,cx-8,baseY-14-i,1,1,'#aab');
    drawArmsAiming(g,cx,baseY+wob,lookA, PAL.skinMd); drawPistol(g,cx+2,baseY-11+wob,lookA);
  };
}

/* ================================
   Build 8 characters (4x2)
================================ */
const makers = [
  makeCommando,
  makeScout,
  makeHeavy,
  makeMedic,
  makeVillager1,
  makeVillager2,
  makeGuide,
  makeRadioOp,
];

const tiles = [];
let idx=0;
for(let r=0;r<ROWS;r++){
  for(let c=0;c<COLS;c++){
    const tile = makeTileCanvas();
    tile.update = makers[idx % makers.length](tile);
    tiles.push(tile); idx++;
  }
}

/* ================================
   Drawing helpers
================================ */
function drawTile(t, x, y, scale){
  const w=t.c.width, h=t.c.height;
  ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale); ctx.drawImage(t.c,0,0); ctx.restore();
}
function drawBackdrop(){
  ctx.save(); ctx.globalAlpha=.08; ctx.fillStyle=PAL.grid; for(let i=0;i<=W;i+=32) ctx.fillRect(i,0,1,H); for(let j=0;j<=H;j+=32) ctx.fillRect(0,j,W,1); ctx.restore();
  const vg = ctx.createRadialGradient(W/2,H/2,Math.min(W,H)*.2, W/2,H/2, Math.max(W,H)*.72);
  vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,.6)'); ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);
}

/* ================================
   Main loop
================================ */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  // WASD pan (vector)
  const fx = (keys.has('d')?1:0) + (keys.has('a')?-1:0);
  const fy = (keys.has('s')?1:0) + (keys.has('w')?-1:0);
  if (fx || fy){ const ang=Math.atan2(fy,fx); cam.x += Math.cos(ang)*cam.speed*dt; cam.y += Math.sin(ang)*cam.speed*dt; }

  // Everyone looks toward mouse
  const dx = mouse.x - W/2, dy = mouse.y - H/2;
  const lookA = Math.atan2(dy, dx);
  const lookM = clamp(Math.hypot(dx,dy)/(Math.max(W,H)*0.5), 0, 1);

  ctx.clearRect(0,0,W,H); drawBackdrop();

  // draw grid with mild parallax
  let index=0; for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const tile = tiles[index++];
      tile.update(now, lookA, lookM);
      const layer = (r*COLS+c)%3; const par=[0.2,0.35,0.5][layer];
      const pxOff = -cam.x*par, pyOff = -cam.y*par;
      const x = startX + GAP + c*(TILE_PX*SCALE + GAP) + pxOff;
      const y = startY + GAP + r*(TILE_PX*SCALE + GAP) + pyOff;
      // card
      ctx.save(); ctx.translate(x-4,y-4); ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(0,0,TILE_PX*SCALE+8, TILE_PX*SCALE+8); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.strokeRect(0.5,0.5,TILE_PX*SCALE+7, TILE_PX*SCALE+7); ctx.restore();
      drawTile(tile, x, y, SCALE);
    }
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ================================
   Interactions
================================ */
window.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='p'){ PAL = junglePalette(); } });
</script>
</body>
</html>
